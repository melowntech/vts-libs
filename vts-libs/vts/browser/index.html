<html>
<head>
    <title>Melown Maps Viewer</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style/>


#vadstena-engine-tools {
    font-family: helvetica, arial, sans-serif;
    font-size: 14px;
    position:absolute;
    right:10px;
    top:10px;
    cursor: default;
    background-color: rgba(255,255,255,0.95);
    border-radius: 5px;
    border: solid 1px #ccc;
    text-align: left;
    z-index: 4;
}

.vadstena-engine-tools * { margin: 0; padding: 0; }

#vadstena-engine-tools-menu {
    width:100%;
    height: 29px;
    text-align: right;
    border-bottom: 1px solid #ccc;
}

#vadstena-engine-tools-menu ul {
    display: inline-block;
    margin-right: 20px;
    margin-left: 20px;
    top: -3px;
    position: relative;
}

#vadstena-engine-tools-menu ul li {
    list-style-type: none;
    display: inline;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    border: solid 1px #ccc;
    padding: 2px 4px;
    margin-right: 2px;
    background-color: rgba(0,0,0,0.1);
    cursor: pointer;
}

#vadstena-engine-tools-menu ul li.vadstena-engine-tools-tab-selected {
    background-color: rgba(250,250,250,0.5);
    border-bottom: solid 1px #f0f0f0;
}

.vadstena-engine-img-help {
    background: no-repeat url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjY1MCIKICAgaGVpZ2h0PSIzMDAiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuNDguNCByOTkzOSIKICAgc29kaXBvZGk6ZG9jbmFtZT0icGFnZTAyLnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjQ2Ij4KICAgICAgPHN0b3AKICAgICAgICAgaWQ9InN0b3A3NjUyIgogICAgICAgICBvZmZzZXQ9IjAiCiAgICAgICAgIHN0eWxlPSJzdG9wLWNvbG9yOiNjZWI2NzQ7c3RvcC1vcGFjaXR5OjE7IiAvPgogICAgICA8c3RvcAogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojOTFkYzdkO3N0b3Atb3BhY2l0eToxOyIKICAgICAgICAgb2Zmc2V0PSIxIgogICAgICAgICBpZD0ic3RvcDc2NTAiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjMwIj4KICAgICAgPHN0b3AKICAgICAgICAgaWQ9InN0b3A3NjMyIgogICAgICAgICBvZmZzZXQ9IjAiCiAgICAgICAgIHN0eWxlPSJzdG9wLWNvbG9yOiNmNWU0YmI7c3RvcC1vcGFjaXR5OjE7IiAvPgogICAgICA8c3RvcAogICAgICAgICBpZD0ic3RvcDc2MzQiCiAgICAgICAgIG9mZnNldD0iMSIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2E3ODkyZDtzdG9wLW9wYWNpdHk6MTsiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjIwIj4KICAgICAgPHN0b3AKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2ZmZmZmZjtzdG9wLW9wYWNpdHk6MTsiCiAgICAgICAgIG9mZnNldD0iMCIKICAgICAgICAgaWQ9InN0b3A3NjIyIiAvPgogICAgICA8c3RvcAogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojNzViZGRhO3N0b3Atb3BhY2l0eToxOyIKICAgICAgICAgb2Zmc2V0PSIxIgogICAgICAgICBpZD0ic3RvcDc2MjQiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNwaXJvIgogICAgICAgaWQ9InBhdGgtZWZmZWN0NzYxMCIKICAgICAgIGlzX3Zpc2libGU9InRydWUiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic3Bpcm8iCiAgICAgICBpZD0icGF0aC1lZmZlY3Q3NjA2IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxzdGFydCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxzdGFydCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGgzODg3IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMSwwLDAsMS4xLDEuMSwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTHN0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxTHN0YXJ0IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM4NjkiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgMCwwIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MXB0IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjgsMCwwLDAuOCwxMCwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNwaXJvIgogICAgICAgaWQ9InBhdGgtZWZmZWN0NDQ1NyIKICAgICAgIGlzX3Zpc2libGU9InRydWUiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic3Bpcm8iCiAgICAgICBpZD0icGF0aC1lZmZlY3Q0NDIxIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM4OTAiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic3Bpcm8iCiAgICAgICBpZD0icGF0aC1lZmZlY3QzMDU2IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJzcGlybyIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDMwNTYtMCIKICAgICAgIGlzX3Zpc2libGU9InRydWUiIC8+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cyTGVuZC00IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDM4OTAtOCIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTUiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC01IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxlbmQtMSIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgzODkwLTUyIgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNwaXJvIgogICAgICAgaWQ9InBhdGgtZWZmZWN0NDQ1Ny00IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTMiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC0yIgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjQ0OTQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNDQ5NiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJtYXJrZXI0NTAwIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDQ1MDIiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNDUwNiIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg0NTA4IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNwaXJvIgogICAgICAgaWQ9InBhdGgtZWZmZWN0NDQ1Ny04IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTM0IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDM4OTAtMSIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJtYXJrZXI0NjM5IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDQ2NDEiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNDY0NSIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg0NjQ3IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjQ2NTEiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNDY1MyIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJzcGlybyIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDQ0NTctOC05IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTAiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC0yNCIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTA5IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDM4OTAtMCIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTgiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC05IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxlbmQtNiIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgzODkwLTA2IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxlbmQtNDkiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC02IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxlbmQtODIiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoMzg5MC05MSIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJtYXJrZXI0ODkxIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDQ4OTMiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNDg5NyIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg0ODk5IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjQ5MDMiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNDkwNSIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJzcGlybyIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDQ0NTctOC0zIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kLTEyIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDM4OTAtMDAiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIiAvPgogICAgPC9tYXJrZXI+CiAgICA8ZmlsdGVyCiAgICAgICBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiCiAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICBpZD0iZmlsdGVyNDMyNS0xLTYtOC0wLTYtMy0zLTEiCiAgICAgICB4PSItMC4wMTMyMDQ1MDkiCiAgICAgICB3aWR0aD0iMS4wMjY0MDkiCiAgICAgICB5PSItMS4wNjk1NjY0IgogICAgICAgaGVpZ2h0PSIzLjEzOTEzMyI+CiAgICAgIDxmZUdhdXNzaWFuQmx1cgogICAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICAgIHN0ZERldmlhdGlvbj0iMC4xOTA0NDk2NyIKICAgICAgICAgaWQ9ImZlR2F1c3NpYW5CbHVyNDMyNy03LTgtNy02MS0xLTctNS00IiAvPgogICAgPC9maWx0ZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNTA2MSIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg1MDYzIgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGZpbHRlcgogICAgICAgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIgogICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgaWQ9ImZpbHRlcjQzMjUtMS02LTgtMC02LTktNiIKICAgICAgIHg9Ii0wLjAxMzIwNDUwOSIKICAgICAgIHdpZHRoPSIxLjAyNjQwOSIKICAgICAgIHk9Ii0xLjA2OTU2NjQiCiAgICAgICBoZWlnaHQ9IjMuMTM5MTMzIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyCiAgICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgICAgc3RkRGV2aWF0aW9uPSIwLjE5MDQ0OTY3IgogICAgICAgICBpZD0iZmVHYXVzc2lhbkJsdXI0MzI3LTctOC03LTYxLTEtOC0wIiAvPgogICAgPC9maWx0ZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNTA2NyIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg1MDY5IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGZpbHRlcgogICAgICAgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIgogICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgaWQ9ImZpbHRlcjQzMjUtMS02LTgtMC0zLTQtNyIKICAgICAgIHg9Ii0wLjAxMzIwNDUwOSIKICAgICAgIHdpZHRoPSIxLjAyNjQwOSIKICAgICAgIHk9Ii0xLjA2OTU2NjQiCiAgICAgICBoZWlnaHQ9IjMuMTM5MTMzIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyCiAgICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgICAgc3RkRGV2aWF0aW9uPSIwLjE5MDQ0OTY3IgogICAgICAgICBpZD0iZmVHYXVzc2lhbkJsdXI0MzI3LTctOC03LTYxLTQtMC0xIiAvPgogICAgPC9maWx0ZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNTA3MyIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg1MDc1IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGZpbHRlcgogICAgICAgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIgogICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgaWQ9ImZpbHRlcjQzMjUtMS02LTgtMC03LTciCiAgICAgICB4PSItMC4wMTMyMDQ1MDkiCiAgICAgICB3aWR0aD0iMS4wMjY0MDkiCiAgICAgICB5PSItMS4wNjk1NjY0IgogICAgICAgaGVpZ2h0PSIzLjEzOTEzMyI+CiAgICAgIDxmZUdhdXNzaWFuQmx1cgogICAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICAgIHN0ZERldmlhdGlvbj0iMC4xOTA0NDk2NyIKICAgICAgICAgaWQ9ImZlR2F1c3NpYW5CbHVyNDMyNy03LTgtNy02MS02LTciIC8+CiAgICA8L2ZpbHRlcj4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJzcGlybyIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDQ0NTctOC0zLTciCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIiAvPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjUwODAiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTA4MiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxmaWx0ZXIKICAgICAgIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIGlkPSJmaWx0ZXI0MzI1LTEtNi04LTAtNi0zLTciCiAgICAgICB4PSItMC4wMTMyMDQ1MDkiCiAgICAgICB3aWR0aD0iMS4wMjY0MDkiCiAgICAgICB5PSItMS4wNjk1NjY0IgogICAgICAgaGVpZ2h0PSIzLjEzOTEzMyI+CiAgICAgIDxmZUdhdXNzaWFuQmx1cgogICAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICAgIHN0ZERldmlhdGlvbj0iMC4xOTA0NDk2NyIKICAgICAgICAgaWQ9ImZlR2F1c3NpYW5CbHVyNDMyNy03LTgtNy02MS0xLTctMyIgLz4KICAgIDwvZmlsdGVyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjUwODYiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTA4OCIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxmaWx0ZXIKICAgICAgIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIGlkPSJmaWx0ZXI0MzI1LTEtNi04LTAtNi0zNSIKICAgICAgIHg9Ii0wLjAxMzIwNDUwOSIKICAgICAgIHdpZHRoPSIxLjAyNjQwOSIKICAgICAgIHk9Ii0xLjA2OTU2NjQiCiAgICAgICBoZWlnaHQ9IjMuMTM5MTMzIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyCiAgICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgICAgc3RkRGV2aWF0aW9uPSIwLjE5MDQ0OTY3IgogICAgICAgICBpZD0iZmVHYXVzc2lhbkJsdXI0MzI3LTctOC03LTYxLTEtOSIgLz4KICAgIDwvZmlsdGVyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjUwOTIiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTA5NCIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxmaWx0ZXIKICAgICAgIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIGlkPSJmaWx0ZXI0MzI1LTEtNi04LTAtMy05IgogICAgICAgeD0iLTAuMDEzMjA0NTA5IgogICAgICAgd2lkdGg9IjEuMDI2NDA5IgogICAgICAgeT0iLTEuMDY5NTY2NCIKICAgICAgIGhlaWdodD0iMy4xMzkxMzMiPgogICAgICA8ZmVHYXVzc2lhbkJsdXIKICAgICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgICBzdGREZXZpYXRpb249IjAuMTkwNDQ5NjciCiAgICAgICAgIGlkPSJmZUdhdXNzaWFuQmx1cjQzMjctNy04LTctNjEtNC04IiAvPgogICAgPC9maWx0ZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyNTA5OCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg1MTAwIgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGZpbHRlcgogICAgICAgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIgogICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgaWQ9ImZpbHRlcjQzMjUtMS02LTgtMC0xIgogICAgICAgeD0iLTAuMDEzMjA0NTA5IgogICAgICAgd2lkdGg9IjEuMDI2NDA5IgogICAgICAgeT0iLTEuMDY5NTY2NCIKICAgICAgIGhlaWdodD0iMy4xMzkxMzMiPgogICAgICA8ZmVHYXVzc2lhbkJsdXIKICAgICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgICBzdGREZXZpYXRpb249IjAuMTkwNDQ5NjciCiAgICAgICAgIGlkPSJmZUdhdXNzaWFuQmx1cjQzMjctNy04LTctNjEtOCIgLz4KICAgIDwvZmlsdGVyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjUxMDQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTEwNiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxmaWx0ZXIKICAgICAgIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIGlkPSJmaWx0ZXI0MzI1LTEtNi04LTgtMiIKICAgICAgIHg9Ii0wLjAxMzIwNDUwOSIKICAgICAgIHdpZHRoPSIxLjAyNjQwOSIKICAgICAgIHk9Ii0xLjA2OTU2NjQiCiAgICAgICBoZWlnaHQ9IjMuMTM5MTMzIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyCiAgICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgICAgc3RkRGV2aWF0aW9uPSIwLjE5MDQ0OTY3IgogICAgICAgICBpZD0iZmVHYXVzc2lhbkJsdXI0MzI3LTctOC03LTYtNiIgLz4KICAgIDwvZmlsdGVyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cyTGVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjUxMTAiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTExMiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiIC8+CiAgICA8L21hcmtlcj4KICAgIDxmaWx0ZXIKICAgICAgIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIGlkPSJmaWx0ZXI0MzI1LTEtNi04LTYiCiAgICAgICB4PSItMC4wMTMyMDQ1MDkiCiAgICAgICB3aWR0aD0iMS4wMjY0MDkiCiAgICAgICB5PSItMS4wNjk1NjY0IgogICAgICAgaGVpZ2h0PSIzLjEzOTEzMyI+CiAgICAgIDxmZUdhdXNzaWFuQmx1cgogICAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICAgIHN0ZERldmlhdGlvbj0iMC4xOTA0NDk2NyIKICAgICAgICAgaWQ9ImZlR2F1c3NpYW5CbHVyNDMyNy03LTgtNy0wIiAvPgogICAgPC9maWx0ZXI+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic3Bpcm8iCiAgICAgICBpZD0icGF0aC1lZmZlY3Q0NDU3LTgtOS0zIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJzcGlybyIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDQ0NTctOC04IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIgLz4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJtYXJrZXI1MTEwLTMiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoNTExMi00IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLjEsMCwwLC0xLjEsLTEuMSwwKSIgLz4KICAgIDwvbWFya2VyPgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjQ2LTciPgogICAgICA8c3RvcAogICAgICAgICBpZD0ic3RvcDc2NTItOCIKICAgICAgICAgb2Zmc2V0PSIwIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojY2ViNjc0O3N0b3Atb3BhY2l0eToxOyIgLz4KICAgICAgPHN0b3AKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6IzkxZGM3ZDtzdG9wLW9wYWNpdHk6MTsiCiAgICAgICAgIG9mZnNldD0iMSIKICAgICAgICAgaWQ9InN0b3A3NjUwLTUiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjMwLTMiPgogICAgICA8c3RvcAogICAgICAgICBpZD0ic3RvcDc2MzItOSIKICAgICAgICAgb2Zmc2V0PSIwIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojZjVlNGJiO3N0b3Atb3BhY2l0eToxOyIgLz4KICAgICAgPHN0b3AKICAgICAgICAgaWQ9InN0b3A3NjM0LTQiCiAgICAgICAgIG9mZnNldD0iMSIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2E3ODkyZDtzdG9wLW9wYWNpdHk6MTsiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICB4bGluazpocmVmPSIjbGluZWFyR3JhZGllbnQ3NjIwLTYiCiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQ3NjI2LTQiCiAgICAgICB4MT0iMTA0Mi40NjU3IgogICAgICAgeTE9IjY1Mi4zNjIxOCIKICAgICAgIHgyPSIxMDMxLjUwNjgiCiAgICAgICB5Mj0iNDA4LjUyNjU1IgogICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIC8+CiAgICA8bGluZWFyR3JhZGllbnQKICAgICAgIGlkPSJsaW5lYXJHcmFkaWVudDc2MjAtNiI+CiAgICAgIDxzdG9wCiAgICAgICAgIHN0eWxlPSJzdG9wLWNvbG9yOiNmZmZmZmY7c3RvcC1vcGFjaXR5OjE7IgogICAgICAgICBvZmZzZXQ9IjAiCiAgICAgICAgIGlkPSJzdG9wNzYyMi05IiAvPgogICAgICA8c3RvcAogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojNzViZGRhO3N0b3Atb3BhY2l0eToxOyIKICAgICAgICAgb2Zmc2V0PSIxIgogICAgICAgICBpZD0ic3RvcDc2MjQtOCIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIxLjkzOTkxIgogICAgIGlua3NjYXBlOmN4PSIzODcuMDUxMzEiCiAgICAgaW5rc2NhcGU6Y3k9IjEyNy45MTg4NiIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE2MTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODg1IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIxOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ijg0IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiIC8+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNzUyLjM2MjE4KSI+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC43MjkxNjc1OHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDU1MS44MTMxOSw4MzMuMTc0NjkgYyAtMC40NDg2MywtMS45OTY0OSAtMC4xMDcxMSwtNC4xNTk0NiAwLjkzNDgzLC01LjkyMDU5IDEuMTM1MDEsLTEuOTE4NDUgMy4wNDMyNiwtMy4zMDg5OCA1LjEzNjc5LC00LjA3NDM4IDIuMDkzNTIsLTAuNzY1NDEgNC4zNjU5MSwtMC45NDIwNyA2LjU5MDY2LC0wLjgwMzY3IDQuNDQ5NTEsMC4yNzY3OSA4Ljc1MzMxLDEuNzc0MjcgMTMuMjAxMzYsMi4wNzM1NiAyLjgzMDc0LDAuMTkwNDcgNS42OTgwNCwtMC4xMTI3NSA4LjQxMzQ3LC0wLjkzNDgzIDEuNDI5MzksLTAuNDMyNzQgMi44MjY4MywtMS4wMTQwOSA0LjA1MDkzLC0xLjg2OTY2IDEuODcwNzUsLTEuMzA3NTQgMy4yODc1MSwtMy4yNTIxMyAzLjk1ODczLC01LjQzMzYgMC42NzEyMywtMi4xODE0OCAwLjU5MjcxLC00LjU4NjE1IC0wLjIxOTQsLTYuNzE5MTkiCiAgICAgICBpZD0icGF0aDQ0NTUtOS0zLTciCiAgICAgICBpbmtzY2FwZTpwYXRoLWVmZmVjdD0iI3BhdGgtZWZmZWN0NDQ1Ny04LTktMyIKICAgICAgIGlua3NjYXBlOm9yaWdpbmFsLWQ9Im0gNTUxLjgxMzE5LDgzMy4xNzQ2OSBjIDAuNjg1MjIsLTEuNzY0MDcgMC4xMjY2LC00LjMwNDEzIDAuOTM0ODMsLTUuOTIwNTkgMi4zMDc4OCwtNC42MTU3NSAyMS40NjA0NywtMi42MzEwOCAyNC45Mjg4MSwtMi44MDQ0OSAyLjM5OTI2LC0wLjExOTk3IDYuMDQ0NjcsLTAuMTQ1MjMgOC40MTM0NywtMC45MzQ4MyAxLjU3NTU0LC0wLjUyNTE4IDIuNzE4OTEsLTEuNTM2NjUgNC4wNTA5MywtMS44Njk2NiAzLjA4MTY1LC0wLjc3MDQxIDMuMzA4NTQsLTEwLjIxNDI4IDMuNzM5MzMsLTEyLjE1Mjc5IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjcyOTE2NzU4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIKICAgICAgIGlkPSJyZWN0MzAzNi0yLTEtOCIKICAgICAgIHdpZHRoPSI4LjcyNTA4MjQiCiAgICAgICBoZWlnaHQ9IjUuNjA4OTgxMSIKICAgICAgIHg9IjU0Ny43OTA0MSIKICAgICAgIHk9IjgyOS4yNTgwNiIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIKICAgICAgIGlkPSJyZWN0Mjk4NS0xLTctOS0zIgogICAgICAgd2lkdGg9IjY0LjI1MzM4IgogICAgICAgaGVpZ2h0PSI5Mi40MDkzNTUiCiAgICAgICB4PSI1MTkuODkzNTUiCiAgICAgICB5PSI4MzMuMTYwODkiCiAgICAgICByeD0iMjUuMzc1MDMxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIgogICAgICAgZD0ibSA1NDUuMTU2NDcsODMzLjE4NTkgYyAtMTQuMDU3NzcsMCAtMjUuMzYxMzYsMTEuMzI2MzggLTI1LjM2MTM2LDI1LjM4NDE0IGwgMCwxMi40NDE0MiAzMi4zNTY4MSwwIDAsLTM3LjgyNTU2IC02Ljk5NTQ1LDAgeiIKICAgICAgIGlkPSJyZWN0Mjk4NS05LTgtNSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBkPSJtIDU1OS4wMTE2Miw4MzMuMDY3ODkgYyAxNC4wNTc3NywwIDI1LjM2MTM2LDExLjMyNjM3IDI1LjM2MTM2LDI1LjM4NDEzIGwgMCwxMi40NDE0MyAtMzIuMzU2ODEsMCAwLC0zNy44MjU1NiA2Ljk5NTQ1LDAgeiIKICAgICAgIGlkPSJyZWN0Mjk4NS00LTUtNi0xIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojZmZkNWQ1O3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIKICAgICAgIGlkPSJyZWN0MzAzMS00LTUtMiIKICAgICAgIHdpZHRoPSI3LjQ3ODY0MiIKICAgICAgIGhlaWdodD0iMjguMzU2NTE4IgogICAgICAgeD0iNTQ4LjQxMzY0IgogICAgICAgeT0iODM2LjQyNTExIgogICAgICAgcng9IjI1LjM3NTAzMSIgLz4KICAgIDxnCiAgICAgICBpZD0iZzg2NDUiPgogICAgICA8cGF0aAogICAgICAgICBzdHlsZT0iZm9udC1zaXplOm1lZGl1bTtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXN0cmV0Y2g6bm9ybWFsO3RleHQtaW5kZW50OjA7dGV4dC1hbGlnbjpzdGFydDt0ZXh0LWRlY29yYXRpb246bm9uZTtsaW5lLWhlaWdodDpub3JtYWw7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO3dvcmQtc3BhY2luZzpub3JtYWw7dGV4dC10cmFuc2Zvcm06bm9uZTtkaXJlY3Rpb246bHRyO2Jsb2NrLXByb2dyZXNzaW9uOnRiO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtiYXNlbGluZS1zaGlmdDpiYXNlbGluZTtjb2xvcjojMDAwMDAwO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Mi41O21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2ZpbHRlcjp1cmwoI2ZpbHRlcjQzMjUtMS02LTgtNik7ZW5hYmxlLWJhY2tncm91bmQ6YWNjdW11bGF0ZTtmb250LWZhbWlseTpTYW5zOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246U2FucyIKICAgICAgICAgZD0ibSAzMzQuODQzNzUsMjI2Ljg0Mzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc1NDcyLDAuMzA0OTcgLTIyLjc4MTI1LDAuMzc1IC0yLjAxMzI2LDAuMDM1IC0zLjI3MDM3LDAuMDQ2OCAtMy45Njg3NSwwLjA2MjUgLTAuMjU0MTUsMC4wMDYgLTAuMzc2MTUsMC4wMjcyIC0wLjUsMC4wMzEyIC0wLjA0NjMsMC4wMDEgLTAuMTU0MTgsLTAuMDAxIC0wLjE4NzUsMCAtMC4wMzA2LDAuMDAxIC0wLjAzODIsLTAuMDA1IC0wLjA5MzcsMCAtMC4wMTM5LDAuMDAxIC0wLjAzMjMsLTAuMDA0IC0wLjA2MjUsMCAtMC4wMzAyLDAuMDA0IC0wLjE4NjkyLDAuMDMxMSAtMC4xODc1LDAuMDMxMiAtNS44ZS00LDEuOGUtNCAtMC4zNzUyNCwyLjIxODU4IC0wLjM3NSwyLjIxODc1IDIuNGUtNCwxLjdlLTQgMC40ODAwNSwwLjIxMTIgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTU4NjMsMC4wMzA1IDAuMTg3NSwwLjAzMTIgMC4wMjg5LDcuNWUtNCAwLjA2MTYsLTNlLTQgMC4wOTM3LDAgMC41MTQ1MiwwLjAwNSAyLjM3MzU0LC0wLjAxNjggNC4wOTM3NSwtMC4wMzEyIDAuODYwMTEsLTAuMDA3IDEuNjc2NTMsLTAuMDI4MiAyLjI1LC0wLjAzMTIgMC4yNTgwNiwtMC4wMDEgMC40MjYzMiwtM2UtNCAwLjU2MjUsMCAtMC4wMDQsLTguNmUtNCAtMC4wNTM0LC0wLjA1NDkgLTAuMDYyNSwtMC4wNjI1IDAuMDc2MywtMC4wMDEgMC4yOTY5MSwwLjAwMSAwLjM3NSwwIGwgMCwwLjA2MjUgYyAwLjAxNzQsLTAuMDAxIDAuMDE3MSwwLjAwNSAwLjA2MjUsMCAwLjAyMjcsLTAuMDAzIDAuMDQ0NiwtMC4wMTM2IDAuMTI1LC0wLjAzMTIgMC4wMDQsLTcuN2UtNCAwLjAyNDcsLTAuMDU3NSAwLjAzMTIsLTAuMDYyNSA0LjIwNzE4LC0wLjA3MTMgOS42OTI4NywtMC4xNTIzOCAxOS45Mzc1LC0wLjMxMjUgbCAtMC4wMzEyLC0yLjUgeiIKICAgICAgICAgaWQ9InBhdGgzMDk1LTEtMi04LTAiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsMC43MjkxNjc1OSwtMC43MjkxNjc1OSwwLDcxOC44MjUwOSw2MzkuODY5NzgpIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBkPSJtIDU2MC4yOTQwNCw4NjQuNDMzOTcgLTcuNzEzMDEsMjIuMDMxOTEgLTguMzk3NzgsLTIxLjc4MDExIGMgNC44MTA2LDMuNDI1MzMgMTEuMzE3MTksMy4zMDM0NyAxNi4xMTA3OSwtMC4yNTE4IHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBpZD0icGF0aDg2NTEiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgaWQ9Imc4NjUzIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7YmFzZWxpbmUtc2hpZnQ6YmFzZWxpbmU7Y29sb3I6IzAwMDAwMDtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjIuNTttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtmaWx0ZXI6dXJsKCNmaWx0ZXI0MzI1LTEtNi04LTgtMik7ZW5hYmxlLWJhY2tncm91bmQ6YWNjdW11bGF0ZTtmb250LWZhbWlseTpTYW5zOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246U2FucyIKICAgICAgICAgZD0ibSAzMzQuODQzNzUsMjI2Ljg0Mzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc1NDcyLDAuMzA0OTcgLTIyLjc4MTI1LDAuMzc1IC0yLjAxMzI2LDAuMDM1IC0zLjI3MDM3LDAuMDQ2OCAtMy45Njg3NSwwLjA2MjUgLTAuMjU0MTUsMC4wMDYgLTAuMzc2MTUsMC4wMjcyIC0wLjUsMC4wMzEyIC0wLjA0NjMsMC4wMDEgLTAuMTU0MTgsLTAuMDAxIC0wLjE4NzUsMCAtMC4wMzA2LDAuMDAxIC0wLjAzODIsLTAuMDA1IC0wLjA5MzcsMCAtMC4wMTM5LDAuMDAxIC0wLjAzMjMsLTAuMDA0IC0wLjA2MjUsMCAtMC4wMzAyLDAuMDA0IC0wLjE4NjkyLDAuMDMxMSAtMC4xODc1LDAuMDMxMiAtNS44ZS00LDEuOGUtNCAtMC4zNzUyNCwyLjIxODU4IC0wLjM3NSwyLjIxODc1IDIuNGUtNCwxLjdlLTQgMC40ODAwNSwwLjIxMTIgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTU4NjMsMC4wMzA1IDAuMTg3NSwwLjAzMTIgMC4wMjg5LDcuNWUtNCAwLjA2MTYsLTNlLTQgMC4wOTM3LDAgMC41MTQ1MiwwLjAwNSAyLjM3MzU0LC0wLjAxNjggNC4wOTM3NSwtMC4wMzEyIDAuODYwMTEsLTAuMDA3IDEuNjc2NTMsLTAuMDI4MiAyLjI1LC0wLjAzMTIgMC4yNTgwNiwtMC4wMDEgMC40MjYzMiwtM2UtNCAwLjU2MjUsMCAtMC4wMDQsLTguNmUtNCAtMC4wNTM0LC0wLjA1NDkgLTAuMDYyNSwtMC4wNjI1IDAuMDc2MywtMC4wMDEgMC4yOTY5MSwwLjAwMSAwLjM3NSwwIGwgMCwwLjA2MjUgYyAwLjAxNzQsLTAuMDAxIDAuMDE3MSwwLjAwNSAwLjA2MjUsMCAwLjAyMjcsLTAuMDAzIDAuMDQ0NiwtMC4wMTM2IDAuMTI1LC0wLjAzMTIgMC4wMDQsLTcuN2UtNCAwLjAyNDcsLTAuMDU3NSAwLjAzMTIsLTAuMDYyNSA0LjIwNzE4LC0wLjA3MTMgOS42OTI4NywtMC4xNTIzOCAxOS45Mzc1LC0wLjMxMjUgbCAtMC4wMzEyLC0yLjUgeiIKICAgICAgICAgaWQ9InBhdGgzMDk1LTEtMi04LTUtMSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMC43MjkxNjc1OSwtMC43MjkxNjc1OSwwLDcxOC44MjUwOSwxMDYxLjI4NjMpIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBkPSJtIDU2MC4yOTQwNCw4MzYuNzIyMTEgLTcuNzEzMDEsLTIyLjAzMTkxIC04LjM5Nzc4LDIxLjc4MDExIGMgNC44MTA2LC0zLjQyNTMzIDExLjMxNzE5LC0zLjMwMzQ3IDE2LjExMDc5LDAuMjUxOCB6IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgaWQ9InBhdGg4NjU5IiAvPgogICAgPC9nPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNzI5MTY3NThweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzMzYuNjM1NTksODMyLjgxNDc2IGMgLTAuNDQ4NjMsLTEuOTk2NDkgLTAuMTA3MTEsLTQuMTU5NDYgMC45MzQ4MywtNS45MjA1OSAxLjEzNTAxLC0xLjkxODQ1IDMuMDQzMjYsLTMuMzA4OTggNS4xMzY3OSwtNC4wNzQzOCAyLjA5MzUyLC0wLjc2NTQxIDQuMzY1OSwtMC45NDIwNyA2LjU5MDY2LC0wLjgwMzY3IDQuNDQ5NSwwLjI3Njc5IDguNzUzMywxLjc3NDI3IDEzLjIwMTM1LDIuMDczNTYgMi44MzA3NSwwLjE5MDQ3IDUuNjk4MDQsLTAuMTEyNzUgOC40MTM0OCwtMC45MzQ4MyAxLjQyOTM5LC0wLjQzMjc0IDIuODI2ODMsLTEuMDE0MDkgNC4wNTA5MywtMS44Njk2NiAxLjg3MDc1LC0xLjMwNzU0IDMuMjg3NTEsLTMuMjUyMTMgMy45NTg3MywtNS40MzM2IDAuNjcxMjIsLTIuMTgxNDggMC41OTI3LC00LjU4NjE1IC0wLjIxOTQxLC02LjcxOTE5IgogICAgICAgaWQ9InBhdGg0NDU1LTktMCIKICAgICAgIGlua3NjYXBlOnBhdGgtZWZmZWN0PSIjcGF0aC1lZmZlY3Q0NDU3LTgtOCIKICAgICAgIGlua3NjYXBlOm9yaWdpbmFsLWQ9Im0gMzM2LjYzNTU5LDgzMi44MTQ3NiBjIDAuNjg1MjIsLTEuNzY0MDcgMC4xMjY2LC00LjMwNDEzIDAuOTM0ODMsLTUuOTIwNTkgMi4zMDc4OCwtNC42MTU3NiAyMS40NjA0NywtMi42MzEwNyAyNC45Mjg4LC0yLjgwNDQ5IDIuMzk5MjcsLTAuMTE5OTYgNi4wNDQ2OCwtMC4xNDUyNCA4LjQxMzQ4LC0wLjkzNDgzIDEuNTc1NTQsLTAuNTI1MTggMi43MTg5MSwtMS41MzY2NSA0LjA1MDkzLC0xLjg2OTY2IDMuMDgxNjQsLTAuNzcwNDEgMy4zMDg1NCwtMTAuMjE0MjkgMy43MzkzMiwtMTIuMTUyNzkiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNzI5MTY3NTg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIgogICAgICAgaWQ9InJlY3QzMDM2LTItMTIiCiAgICAgICB3aWR0aD0iOC43MjUwODI0IgogICAgICAgaGVpZ2h0PSI1LjYwODk4MTEiCiAgICAgICB4PSIzMzIuNjEyNzMiCiAgICAgICB5PSI4MjguODk4MDciIC8+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBpZD0icmVjdDI5ODUtMS03LTUiCiAgICAgICB3aWR0aD0iNjQuMjUzMzgiCiAgICAgICBoZWlnaHQ9IjkyLjQwOTM1NSIKICAgICAgIHg9IjMwNC43MTU5MSIKICAgICAgIHk9IjgzMi44MDA5IgogICAgICAgcng9IjI1LjM3NTAzMSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIKICAgICAgIGQ9Im0gMzI5Ljk3ODg3LDgzMi44MjU5NyBjIC0xNC4wNTc3NywwIC0yNS4zNjEzNiwxMS4zMjYzOCAtMjUuMzYxMzYsMjUuMzg0MTQgbCAwLDEyLjQ0MTQyIDMyLjM1NjgxLDAgMCwtMzcuODI1NTYgLTYuOTk1NDUsMCB6IgogICAgICAgaWQ9InJlY3QyOTg1LTktMCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZDVkNTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBkPSJtIDM0My44MzQwMiw4MzIuNzA3OTUgYyAxNC4wNTc3NywwIDI1LjM2MTM2LDExLjMyNjM4IDI1LjM2MTM2LDI1LjM4NDE0IGwgMCwxMi40NDE0MiAtMzIuMzU2ODEsMCAwLC0zNy44MjU1NiA2Ljk5NTQ1LDAgeiIKICAgICAgIGlkPSJyZWN0Mjk4NS00LTUtOSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBpZD0icmVjdDMwMzEtNC00IgogICAgICAgd2lkdGg9IjcuNDc4NjQyIgogICAgICAgaGVpZ2h0PSIyOC4zNTY1MTgiCiAgICAgICB4PSIzMzMuMjM1OTkiCiAgICAgICB5PSI4MzYuMDY1MTIiCiAgICAgICByeD0iMjUuMzc1MDMxIiAvPgogICAgPGcKICAgICAgIGlkPSJnODY3NyI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO2NvbG9yOiMwMDAwMDA7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjU7bWFya2VyOm5vbmU7dmlzaWJpbGl0eTp2aXNpYmxlO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7ZmlsdGVyOnVybCgjZmlsdGVyNDMyNS0xLTYtOC0wLTEpO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6U2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOlNhbnMiCiAgICAgICAgIGQ9Im0gNDMxLjg3NSw3MDQuMzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc4NTk3LDAuMzA0OTcgLTIyLjgxMjUsMC4zNzUgLTEuODcwNjcsMC4wMzI1IC0yLjk2NDY0LDAuMDc4MSAtMy42ODc1LDAuMDkzNyAtMC4wNTUxLDAuMDAxIC0wLjIzMTc5LC0wLjAwMSAtMC4yODEyNSwwIC0wLjEwODA1LDIuMWUtNCAtMC41MDg5LDVlLTQgLTAuNTYyNSwwIC0wLjAyMDksNy43ZS00IC0wLjA3NjMsLTcuN2UtNCAtMC4wOTM3LDAgLTAuMDMwNiwwLjAwMSAtMC4wMzgyLC0wLjAwNSAtMC4wOTM3LDAgLTAuMDEzOSwwLjAwMSAtMC4wMzIzLDAuMDI3MiAtMC4wNjI1LDAuMDMxMiAtMC4wMzAyLDAuMDA0IC0wLjIxODE3LDAuMDMxMSAtMC4yMTg3NSwwLjAzMTIgLTUuOGUtNCwxLjhlLTQgLTAuMzQzOTksMi4yMTg1OCAtMC4zNDM3NSwyLjIxODc1IDIuNGUtNCwxLjdlLTQgMC40ODAwNSwwLjIxMTIgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTU4NjMsLTcuNWUtNCAwLjE4NzUsMCAwLjAyODksNy41ZS00IDAuMDYxNiwtM2UtNCAwLjA5MzcsMCAwLjAwOCw3ZS01IDAuMDU0LC02ZS01IDAuMDYyNSwwIDAuMDc2OSw1LjdlLTQgMC40MzkzMSwyLjFlLTQgMC41NjI1LDAgMC4wNTQxLC0wLjAwMSAwLjI1MTI4LDAuMDAxIDAuMzEyNSwwIDAuODA4ODUsLTAuMDAzIDEuODAxNzQsLTAuMDIwMSAzLjEyNSwtMC4wMzEyIDAuODYwMTEsLTAuMDA3IDEuNjc2NTMsMC4wMDMgMi4yNSwwIDAuMjg2NzMsLTAuMDAyIDAuNTIzNDMsLTUuN2UtNCAwLjY1NjI1LDAgLTAuMDE4MiwtMC4wMDIgLTAuMDE5MiwtMC4wMjI4IC0wLjA2MjUsLTAuMDMxMiAtMC4wMDQsLTguN2UtNCAtMC4wNTM0LC0wLjA1NDggLTAuMDYyNSwtMC4wNjI1IDAuMDcsLTAuMDAxIDAuMjcyMywwLjAwMSAwLjM0Mzc1LDAgbCAwLDAuMDkzNyBjIDAuMDE3NCwtMC4wMDEgMC4wNDg0LDAuMDA1IDAuMDkzNywwIDAuMDIyNywtMC4wMDMgMC4wNDQ2LC0wLjAxMzYgMC4xMjUsLTAuMDMxMiAwLjAwNiwtMC4wMDEgMC4wNDg1LC0wLjA4MSAwLjA2MjUsLTAuMDkzNyA0LjIwODM1LC0wLjA3MTMgOS42Nzc2NywtMC4xNTI2MyAxOS45MDYyNSwtMC4zMTI1IGwgLTAuMDMxMiwtMi41IHoiCiAgICAgICAgIGlkPSJwYXRoMzA5NS0xLTItOC0zLTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuNzI5MTY3NTksMCwwLDAuNzI5MTY3NTksODQuMjA4MTM0LDM2OC44MTk1NCkiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGQ9Im0gMzc5LjUxMzgxLDg3NS41NjQ0IDIyLjAzMTkyLDcuNzEzMDEgLTIxLjc4MDExLDguMzk3NzggYyAzLjQyNTMzLC00LjgxMDYgMy4zMDM0NiwtMTEuMzE3MTggLTAuMjUxODEsLTE2LjExMDc5IHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBpZD0icGF0aDg2ODMiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgaWQ9Imc4NjYxIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7YmFzZWxpbmUtc2hpZnQ6YmFzZWxpbmU7Y29sb3I6IzAwMDAwMDtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjIuNTttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtmaWx0ZXI6dXJsKCNmaWx0ZXI0MzI1LTEtNi04LTAtMy05KTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OlNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpTYW5zIgogICAgICAgICBkPSJtIDMxNS44NzUsMTQwLjA5Mzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc4NTk3LDAuMzA0OTcgLTIyLjgxMjUsMC4zNzUgLTIuMDEzMjYsMC4wMzUgLTMuMjcwMzcsMC4wNDY4IC0zLjk2ODc1LDAuMDYyNSAtMC4yOTk0MiwwLjAwNyAtMC40MzcyLDAuMDI2NiAtMC41NjI1LDAuMDMxMiAtMC4wMjA4LDcuN2UtNCAtMC4wNzYzLC03LjdlLTQgLTAuMDkzNywwIC0wLjAzMDYsMC4wMDEgLTAuMDY5NSwtMC4wMDUgLTAuMTI1LDAgLTAuMDEzOSwwLjAwMSAtMC4wMDEsLTAuMDA0IC0wLjAzMTIsMCAtMC4wMzAyLDAuMDA0IC0wLjIxODE3LDAuMDYyMyAtMC4yMTg3NSwwLjA2MjUgLTUuOGUtNCwxLjhlLTQgLTAuMzQzOTksMi4yMTg1OCAtMC4zNDM3NSwyLjIxODc1IDIuNGUtNCwxLjdlLTQgMC40ODAwNSwwLjIxMTIgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTU4NjMsLTcuNWUtNCAwLjE4NzUsMCAwLjAyODksNy41ZS00IDAuMDYxNiwtM2UtNCAwLjA5MzcsMCAwLjAwNiwtMi43ZS00IDAuMDUzNCwzLjRlLTQgMC4wNjI1LDAgMC41NDY2LDAuMDA0IDIuMzA2MjUsLTAuMDE3IDQsLTAuMDMxMiAwLjg2MDExLC0wLjAwNyAxLjY3NjUzLDAuMDAzIDIuMjUsMCAwLjI4NjczLC0wLjAwMiAwLjUyMzQzLC01LjdlLTQgMC42NTYyNSwwIC0wLjAxODIsLTAuMDAyIC0wLjAxOTIsLTAuMDIyOCAtMC4wNjI1LC0wLjAzMTIgLTAuMDA0LC04LjdlLTQgLTAuMDUzNCwtMC4wNTQ4IC0wLjA2MjUsLTAuMDYyNSAwLjA3LC0wLjAwMSAwLjI3MjMsMC4wMDEgMC4zNDM3NSwwIGwgMCwwLjA5MzcgYyAwLjAxNzQsLTAuMDAxIDAuMDQ4NCwwLjAwNSAwLjA5MzcsMCAwLjAyMjcsLTAuMDAzIDAuMDQ0NiwtMC4wMTM2IDAuMTI1LC0wLjAzMTIgMC4wMDYsLTAuMDAxIDAuMDQ4NSwtMC4wODEgMC4wNjI1LC0wLjA5MzcgNC4yMDgzNSwtMC4wNzEzIDkuNjc3NjcsLTAuMTUyNjMgMTkuOTA2MjUsLTAuMzEyNSBsIC0wLjAzMTIsLTIuNSB6IgogICAgICAgICBpZD0icGF0aDMwOTUtMS0yLTgtMy00LTQiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjcyOTE2NzU5LDAsMCwwLjcyOTE2NzU5LDUwNC45ODU1Myw3ODAuMjc5MzMpIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBkPSJtIDI5NC4yNjQ0Niw4NzUuNTY0NCAtMjIuMDMxOTIsNy43MTMwMSAyMS43ODAxMSw4LjM5Nzc4IGMgLTMuNDI1MzMsLTQuODEwNiAtMy4zMDM0NiwtMTEuMzE3MTggMC4yNTE4MSwtMTYuMTEwNzkgeiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGlkPSJwYXRoODY2NyIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzg2NjkiPgogICAgICA8cGF0aAogICAgICAgICBzdHlsZT0iZm9udC1zaXplOm1lZGl1bTtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXN0cmV0Y2g6bm9ybWFsO3RleHQtaW5kZW50OjA7dGV4dC1hbGlnbjpzdGFydDt0ZXh0LWRlY29yYXRpb246bm9uZTtsaW5lLWhlaWdodDpub3JtYWw7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO3dvcmQtc3BhY2luZzpub3JtYWw7dGV4dC10cmFuc2Zvcm06bm9uZTtkaXJlY3Rpb246bHRyO2Jsb2NrLXByb2dyZXNzaW9uOnRiO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtiYXNlbGluZS1zaGlmdDpiYXNlbGluZTtjb2xvcjojMDAwMDAwO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Mi41O21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2ZpbHRlcjp1cmwoI2ZpbHRlcjQzMjUtMS02LTgtMC02LTM1KTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OlNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpTYW5zIgogICAgICAgICBkPSJtIDM5My41MzEyNSw0MS4xNTYyNSBjIC0xMS43MDY2MiwwLjE4Mjk3IC0xOC43ODU5NywwLjMwNDk2OCAtMjIuODEyNSwwLjM3NSAtMi4wMTMyNiwwLjAzNTAyIC0zLjI3MDM3LDAuMDQ2NzggLTMuOTY4NzUsMC4wNjI1IC0wLjI5OTQyLDAuMDA2NyAtMC40MzcyLDAuMDI2NjEgLTAuNTYyNSwwLjAzMTI1IC0wLjAyMDgsNy43MWUtNCAtMC4wNzYzLC03LjdlLTQgLTAuMDkzNywwIC0wLjAzMDYsMC4wMDE0IC0wLjAzODIsLTAuMDA1IC0wLjA5MzcsMCAtMC4wMTM5LDAuMDAxMiAtMC4wMzIzLC0wLjAwNDEgLTAuMDYyNSwwIC0wLjAzMDIsMC4wMDQxIC0wLjIxODE3LDAuMDYyMzIgLTAuMjE4NzUsMC4wNjI1IC01LjhlLTQsMS43OGUtNCAtMC4zNDM5OSwyLjIxODU4NSAtMC4zNDM3NSwyLjIxODc1IDIuNGUtNCwxLjY1ZS00IDAuNDgwMDUsMC4yMTEyMDEgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAxOSAwLjE1ODYzLC03LjUzZS00IDAuMTg3NSwwIDAuMDI4OSw3LjUzZS00IDAuMDYxNiwtMi45OGUtNCAwLjA5MzcsMCAwLjAwNiwtMi43ZS00IDAuMDUzNCwzLjM4ZS00IDAuMDYyNSwwIDAuNTQ2NiwwLjAwNCAyLjMwNjI1LC0wLjAxNjk4IDQsLTAuMDMxMjUgMC44NjAxMSwtMC4wMDcyIDEuNjc2NTMsMC4wMDMxIDIuMjUsMCAwLjI4NjczLC0wLjAwMTUgMC41MjM0MywtNS42OWUtNCAwLjY1NjI1LDAgLTAuMDE4MiwtMC4wMDIxIC0wLjAxOTIsLTAuMDIyOCAtMC4wNjI1LC0wLjAzMTI1IC0wLjAwNCwtOC43NmUtNCAtMC4wNTMyLC0wLjA1NDY0IC0wLjA2MjUsLTAuMDYyNSAwLjA3LC0wLjAwMTIgMC4yNzIzLDAuMDAxMiAwLjM0Mzc1LDAgbCAwLDAuMDkzNzUgYyAwLjAxNzQsLTAuMDAxMSAwLjA0ODQsMC4wMDUzIDAuMDkzNywwIDAuMDIyNywtMC4wMDI2IDAuMDQ0NiwtMC4wMTM2MSAwLjEyNSwtMC4wMzEyNSAwLjAwNiwtMC4wMDEzIDAuMDQ4NSwtMC4wODEwMiAwLjA2MjUsLTAuMDkzNzUgNC4yMDgzNSwtMC4wNzEzMyA5LjY3NzY3LC0wLjE1MjYzMSAxOS45MDYyNSwtMC4zMTI1IGwgLTAuMDMxMiwtMi41IHoiCiAgICAgICAgIGlkPSJwYXRoMzA5NS0xLTItOC0zLTgtMCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwwLjcyOTE2NzU5LC0wLjcyOTE2NzU5LDAsMzY4LjI0MzY5LDY2Ny41NDU3MikiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGQ9Im0gMzQ1LjA5OTY3LDkzNC44OTM2MyAtNy43MTMwMSwyMi4wMzE5MiAtOC4zOTc3OCwtMjEuNzgwMTEgYyA0LjgxMDYsMy40MjUzMyAxMS4zMTcxOSwzLjMwMzQ2IDE2LjExMDc5LC0wLjI1MTgxIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBpZD0icGF0aDg2NzUiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgaWQ9Imc4Njg1Ij4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7YmFzZWxpbmUtc2hpZnQ6YmFzZWxpbmU7Y29sb3I6IzAwMDAwMDtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjIuNTttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtmaWx0ZXI6dXJsKCNmaWx0ZXI0MzI1LTEtNi04LTAtNi0zLTcpO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6U2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOlNhbnMiCiAgICAgICAgIGQ9Im0gMzkzLjUzMTI1LDQxLjE1NjI1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc4NTk3LDAuMzA0OTY4IC0yMi44MTI1LDAuMzc1IC0yLjAxMzI2LDAuMDM1MDIgLTMuMjcwMzcsMC4wNDY3OCAtMy45Njg3NSwwLjA2MjUgLTAuMjk5NDIsMC4wMDY3IC0wLjQzNzIsMC4wMjY2MSAtMC41NjI1LDAuMDMxMjUgLTAuMDIwOCw3LjcxZS00IC0wLjA3NjMsLTcuN2UtNCAtMC4wOTM3LDAgLTAuMDMwNiwwLjAwMTQgLTAuMDM4MiwtMC4wMDUgLTAuMDkzNywwIC0wLjAxMzksMC4wMDEyIC0wLjAzMjMsLTAuMDA0MSAtMC4wNjI1LDAgLTAuMDMwMiwwLjAwNDEgLTAuMjE4MTcsMC4wNjIzMiAtMC4yMTg3NSwwLjA2MjUgLTUuOGUtNCwxLjc4ZS00IC0wLjM0Mzk5LDIuMjE4NTg1IC0wLjM0Mzc1LDIuMjE4NzUgMi40ZS00LDEuNjVlLTQgMC40ODAwNSwwLjIxMTIwMSAwLjUzMTI1LDAuMjE4NzUgMC4yMDQ4MSwwLjAzMDE5IDAuMTU4NjMsLTcuNTNlLTQgMC4xODc1LDAgMC4wMjg5LDcuNTNlLTQgMC4wNjE2LC0yLjk4ZS00IDAuMDkzNywwIDAuMDA2LC0yLjdlLTQgMC4wNTM0LDMuMzhlLTQgMC4wNjI1LDAgMC41NDY2LDAuMDA0IDIuMzA2MjUsLTAuMDE2OTggNCwtMC4wMzEyNSAwLjg2MDExLC0wLjAwNzIgMS42NzY1MywwLjAwMzEgMi4yNSwwIDAuMjg2NzMsLTAuMDAxNSAwLjUyMzQzLC01LjY5ZS00IDAuNjU2MjUsMCAtMC4wMTgyLC0wLjAwMjEgLTAuMDE5MiwtMC4wMjI4IC0wLjA2MjUsLTAuMDMxMjUgLTAuMDA0LC04Ljc2ZS00IC0wLjA1MzIsLTAuMDU0NjQgLTAuMDYyNSwtMC4wNjI1IDAuMDcsLTAuMDAxMiAwLjI3MjMsMC4wMDEyIDAuMzQzNzUsMCBsIDAsMC4wOTM3NSBjIDAuMDE3NCwtMC4wMDExIDAuMDQ4NCwwLjAwNTMgMC4wOTM3LDAgMC4wMjI3LC0wLjAwMjYgMC4wNDQ2LC0wLjAxMzYxIDAuMTI1LC0wLjAzMTI1IDAuMDA2LC0wLjAwMTMgMC4wNDg1LC0wLjA4MTAyIDAuMDYyNSwtMC4wOTM3NSA0LjIwODM1LC0wLjA3MTMzIDkuNjc3NjcsLTAuMTUyNjMxIDE5LjkwNjI1LC0wLjMxMjUgbCAtMC4wMzEyLC0yLjUgeiIKICAgICAgICAgaWQ9InBhdGgzMDk1LTEtMi04LTMtOC04LTYiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsLTAuNzI5MTY3NTksMC43MjkxNjc1OSwwLDMwNS44NDQ4NiwxMDg0LjEwMjEpIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBkPSJtIDMyOC45ODg4OCw4MTYuNzU0MTkgNy43MTMwMSwtMjIuMDMxOTIgOC4zOTc3OCwyMS43ODAxMSBjIC00LjgxMDYsLTMuNDI1MzMgLTExLjMxNzE5LC0zLjMwMzQ2IC0xNi4xMTA3OSwwLjI1MTgxIHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kIgogICAgICAgICBpZD0icGF0aDg2OTEiIC8+CiAgICA8L2c+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC43MjkxNjc1OHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDExMi44MDg3Myw4MzIuODE0NzYgYyAtMC40NDg2MywtMS45OTY0OSAtMC4xMDcxMSwtNC4xNTk0NiAwLjkzNDgzLC01LjkyMDU5IDEuMTM1MDEsLTEuOTE4NDUgMy4wNDMyNiwtMy4zMDg5NyA1LjEzNjc4LC00LjA3NDM4IDIuMDkzNTMsLTAuNzY1NCA0LjM2NTkxLC0wLjk0MjA2IDYuNTkwNjYsLTAuODAzNjcgNC40NDk1MSwwLjI3NjggOC43NTMzLDEuNzc0MjggMTMuMjAxMzUsMi4wNzM1NiAyLjgzMDc1LDAuMTkwNDcgNS42OTgwNCwtMC4xMTI3NiA4LjQxMzQ4LC0wLjkzNDg0IDEuNDI5MzksLTAuNDMyNzQgMi44MjY4MywtMS4wMTQwOSA0LjA1MDkzLC0xLjg2OTY2IDEuODcwNzUsLTEuMzA3NTQgMy4yODc1MSwtMy4yNTIxMiAzLjk1ODczLC01LjQzMzYgMC42NzEyMiwtMi4xODE0NyAwLjU5MjcsLTQuNTg2MTQgLTAuMjE5NDEsLTYuNzE5MTgiCiAgICAgICBpZD0icGF0aDQ0NTUtOS02LTEiCiAgICAgICBpbmtzY2FwZTpwYXRoLWVmZmVjdD0iI3BhdGgtZWZmZWN0NDQ1Ny04LTMtNyIKICAgICAgIGlua3NjYXBlOm9yaWdpbmFsLWQ9Im0gMTEyLjgwODczLDgzMi44MTQ3NiBjIDAuNjg1MjIsLTEuNzY0MDggMC4xMjY1OSwtNC4zMDQxMyAwLjkzNDgzLC01LjkyMDU5IDIuMzA3ODgsLTQuNjE1NzYgMjEuNDYwNDUsLTIuNjMxMDggMjQuOTI4NzksLTIuODA0NDkgMi4zOTkyNywtMC4xMTk5NyA2LjA0NDY4LC0wLjE0NTI0IDguNDEzNDgsLTAuOTM0ODQgMS41NzU1MywtMC41MjUxNyAyLjcxODkxLC0xLjUzNjY1IDQuMDUwOTMsLTEuODY5NjYgMy4wODE2NCwtMC43NzA0MSAzLjMwODU0LC0xMC4yMTQyOCAzLjczOTMyLC0xMi4xNTI3OCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC43MjkxNjc1ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBpZD0icmVjdDMwMzYtMi0xNS04IgogICAgICAgd2lkdGg9IjguNzI1MDgyNCIKICAgICAgIGhlaWdodD0iNS42MDg5ODExIgogICAgICAgeD0iMTA4Ljc4NTg5IgogICAgICAgeT0iODI4Ljg5ODA3IiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIgogICAgICAgaWQ9InJlY3QyOTg1LTEtNy00LTkiCiAgICAgICB3aWR0aD0iNjQuMjUzMzgiCiAgICAgICBoZWlnaHQ9IjkyLjQwOTM1NSIKICAgICAgIHg9IjgwLjg4OTA2MSIKICAgICAgIHk9IjgzMi44MDA5NiIKICAgICAgIHJ4PSIyNS4zNzUwMzEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZDVkNTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjAiCiAgICAgICBkPSJtIDEwNi4xNTIsODMyLjgyNTk3IGMgLTE0LjA1Nzc2MiwwIC0yNS4zNjEzNTMsMTEuMzI2MzggLTI1LjM2MTM1MywyNS4zODQxNCBsIDAsMTIuNDQxNDIgMzIuMzU2ODAzLDAgMCwtMzcuODI1NTYgLTYuOTk1NDUsMCB6IgogICAgICAgaWQ9InJlY3QyOTg1LTktMi04IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIKICAgICAgIGQ9Im0gMTIwLjAwNzE2LDgzMi43MDc5NSBjIDE0LjA1Nzc2LDAgMjUuMzYxMzUsMTEuMzI2MzggMjUuMzYxMzUsMjUuMzg0MTQgbCAwLDEyLjQ0MTQyIC0zMi4zNTY4MSwwIDAsLTM3LjgyNTU2IDYuOTk1NDYsMCB6IgogICAgICAgaWQ9InJlY3QyOTg1LTQtNS0wLTQiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIgogICAgICAgaWQ9InJlY3QzMDMxLTQtOS0xIgogICAgICAgd2lkdGg9IjcuNDc4NjQyIgogICAgICAgaGVpZ2h0PSIyOC4zNTY1MTgiCiAgICAgICB4PSIxMDkuNDA5MTMiCiAgICAgICB5PSI4MzYuMDY1MTIiCiAgICAgICByeD0iMjUuMzc1MDMxIiAvPgogICAgPGcKICAgICAgIGlkPSJnODYzNyI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO2NvbG9yOiMwMDAwMDA7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjU7bWFya2VyOm5vbmU7dmlzaWJpbGl0eTp2aXNpYmxlO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7ZmlsdGVyOnVybCgjZmlsdGVyNDMyNS0xLTYtOC0wLTctNyk7ZW5hYmxlLWJhY2tncm91bmQ6YWNjdW11bGF0ZTtmb250LWZhbWlseTpTYW5zOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246U2FucyIKICAgICAgICAgZD0ibSAyMjUuMTU2MjUsNzAzLjg0Mzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc1NDcyLDAuMzA0OTcgLTIyLjc4MTI1LDAuMzc1IC0xLjg3MDY3LDAuMDMyNSAtMi45NjQ2NCwwLjA3ODEgLTMuNjg3NSwwLjA5MzcgLTAuMDU1MSwwLjAwMSAtMC4yMzE3OSwtMC4wMDEgLTAuMjgxMjUsMCAtMC4xMDkyNywyLjJlLTQgLTAuNTA4NDgsNWUtNCAtMC41NjI1LDAgLTAuMDI3OSw5LjllLTQgLTAuMTAyNzQsLTkuOGUtNCAtMC4xMjUsMCAtMC4wMzA2LDAuMDAxIC0wLjAzODIsLTAuMDA1IC0wLjA5MzcsMCAtMC4wMTM5LDAuMDAxIC0wLjAzMjMsMC4wMjcyIC0wLjA2MjUsMC4wMzEyIC0wLjAzMDIsMC4wMDQgLTAuMTg2OTIsMC4wMzExIC0wLjE4NzUsMC4wMzEyIC01LjhlLTQsMS44ZS00IC0wLjM3NTI0LDIuMjE4NTggLTAuMzc1LDIuMjE4NzUgMi40ZS00LDEuN2UtNCAwLjUxMTMsMC4yMTEyIDAuNTYyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTI3MzgsLTcuNWUtNCAwLjE1NjI1LDAgMC4wMjg5LDcuNWUtNCAwLjA2MTYsLTNlLTQgMC4wOTM3LDAgMC4wMTE4LDEuMWUtNCAwLjA4MDYsLTllLTUgMC4wOTM3LDAgMC4wNzksNS4yZS00IDAuNDM4MywyLjRlLTQgMC41NjI1LDAgMC4wNTQ2LC0wLjAwMSAwLjI1MDc0LDAuMDAxIDAuMzEyNSwwIDAuODExNTYsLTAuMDAzIDEuODExODQsLTAuMDIwMiAzLjEyNSwtMC4wMzEyIDAuODYwMTEsLTAuMDA3IDEuNjc2NTMsMC4wMDMgMi4yNSwwIDAuMjg2NzMsLTAuMDAyIDAuNTIzNDMsLTUuN2UtNCAwLjY1NjI1LDAgLTAuMDE4MiwtMC4wMDEgLTAuMDMxMiwtMC4wMTkgLTAuMDkzNywtMC4wMzEyIC0wLjAwNCwtOC44ZS00IC0wLjA1MzIsLTAuMDU0NiAtMC4wNjI1LC0wLjA2MjUgMC4wNzYyLC0wLjAwMSAwLjI5NzA0LDAuMDAxIDAuMzc1LDAgbCAwLDAuMDkzNyBjIDAuMDE3NCwtMC4wMDEgMC4wMTcxLDAuMDA1IDAuMDYyNSwwIDAuMDIyNywtMC4wMDMgMC4wNzU4LC0wLjAxMzYgMC4xNTYyNSwtMC4wMzEyIDAuMDA2LC0wLjAwMSAwLjA0ODUsLTAuMDgxIDAuMDYyNSwtMC4wOTM3IDQuMjA5MzYsLTAuMDcxMyA5LjY5MTY4LC0wLjE1Mjg1IDE5LjkwNjI1LC0wLjMxMjUgbCAtMC4wNjI1LC0yLjUgeiIKICAgICAgICAgaWQ9InBhdGgzMDk1LTEtMi04LTMtNy00IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjcyOTE2NzU5LDAsMCwwLjcyOTE2NzU5LDExLjEwMTc1MSwzNjIuMTQ4NDMpIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBkPSJtIDE1NS42ODY5NCw4NjguNTA1NDQgMjIuMDMxOTEsNy43MTMwMSAtMjEuNzgwMTEsOC4zOTc3OCBjIDMuNDI1MzMsLTQuODEwNiAzLjMwMzQ3LC0xMS4zMTcxOCAtMC4yNTE4LC0xNi4xMTA3OSB6IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgaWQ9InBhdGg4NjQzIiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODcwMSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO2NvbG9yOiMwMDAwMDA7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjU7bWFya2VyOm5vbmU7dmlzaWJpbGl0eTp2aXNpYmxlO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7ZmlsdGVyOnVybCgjZmlsdGVyNDMyNS0xLTYtOC0wLTMtNC03KTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OlNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpTYW5zIgogICAgICAgICBkPSJtIDMxNS44NzUsMTQwLjA5Mzc1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc4NTk3LDAuMzA0OTcgLTIyLjgxMjUsMC4zNzUgLTIuMDEzMjYsMC4wMzUgLTMuMjcwMzcsMC4wNDY4IC0zLjk2ODc1LDAuMDYyNSAtMC4yOTk0MiwwLjAwNyAtMC40MzcyLDAuMDI2NiAtMC41NjI1LDAuMDMxMiAtMC4wMjA4LDcuN2UtNCAtMC4wNzYzLC03LjdlLTQgLTAuMDkzNywwIC0wLjAzMDYsMC4wMDEgLTAuMDY5NSwtMC4wMDUgLTAuMTI1LDAgLTAuMDEzOSwwLjAwMSAtMC4wMDEsLTAuMDA0IC0wLjAzMTIsMCAtMC4wMzAyLDAuMDA0IC0wLjIxODE3LDAuMDYyMyAtMC4yMTg3NSwwLjA2MjUgLTUuOGUtNCwxLjhlLTQgLTAuMzQzOTksMi4yMTg1OCAtMC4zNDM3NSwyLjIxODc1IDIuNGUtNCwxLjdlLTQgMC40ODAwNSwwLjIxMTIgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAyIDAuMTU4NjMsLTcuNWUtNCAwLjE4NzUsMCAwLjAyODksNy41ZS00IDAuMDYxNiwtM2UtNCAwLjA5MzcsMCAwLjAwNiwtMi43ZS00IDAuMDUzNCwzLjRlLTQgMC4wNjI1LDAgMC41NDY2LDAuMDA0IDIuMzA2MjUsLTAuMDE3IDQsLTAuMDMxMiAwLjg2MDExLC0wLjAwNyAxLjY3NjUzLDAuMDAzIDIuMjUsMCAwLjI4NjczLC0wLjAwMiAwLjUyMzQzLC01LjdlLTQgMC42NTYyNSwwIC0wLjAxODIsLTAuMDAyIC0wLjAxOTIsLTAuMDIyOCAtMC4wNjI1LC0wLjAzMTIgLTAuMDA0LC04LjdlLTQgLTAuMDUzNCwtMC4wNTQ4IC0wLjA2MjUsLTAuMDYyNSAwLjA3LC0wLjAwMSAwLjI3MjMsMC4wMDEgMC4zNDM3NSwwIGwgMCwwLjA5MzcgYyAwLjAxNzQsLTAuMDAxIDAuMDQ4NCwwLjAwNSAwLjA5MzcsMCAwLjAyMjcsLTAuMDAzIDAuMDQ0NiwtMC4wMTM2IDAuMTI1LC0wLjAzMTIgMC4wMDYsLTAuMDAxIDAuMDQ4NSwtMC4wODEgMC4wNjI1LC0wLjA5MzcgNC4yMDgzNSwtMC4wNzEzIDkuNjc3NjcsLTAuMTUyNjMgMTkuOTA2MjUsLTAuMzEyNSBsIC0wLjAzMTIsLTIuNSB6IgogICAgICAgICBpZD0icGF0aDMwOTUtMS0yLTgtMy00LTMtMyIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuNzI5MTY3NTksMCwwLDAuNzI5MTY3NTksMjgxLjE1ODY2LDc3My4yMjAzNykiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGQ9Im0gNzAuNDM3NTg4LDg2OC41MDU0NCAtMjIuMDMxOTE1LDcuNzEzMDEgMjEuNzgwMTExLDguMzk3NzggYyAtMy40MjUzMzIsLTQuODEwNiAtMy4zMDM0NjcsLTExLjMxNzE4IDAuMjUxODA0LC0xNi4xMTA3OSB6IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgaWQ9InBhdGg4NzA3IiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODY5MyI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO2NvbG9yOiMwMDAwMDA7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjU7bWFya2VyOm5vbmU7dmlzaWJpbGl0eTp2aXNpYmxlO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7ZmlsdGVyOnVybCgjZmlsdGVyNDMyNS0xLTYtOC0wLTYtOS02KTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OlNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpTYW5zIgogICAgICAgICBkPSJtIDM5My41MzEyNSw0MS4xNTYyNSBjIC0xMS43MDY2MiwwLjE4Mjk3IC0xOC43ODU5NywwLjMwNDk2OCAtMjIuODEyNSwwLjM3NSAtMi4wMTMyNiwwLjAzNTAyIC0zLjI3MDM3LDAuMDQ2NzggLTMuOTY4NzUsMC4wNjI1IC0wLjI5OTQyLDAuMDA2NyAtMC40MzcyLDAuMDI2NjEgLTAuNTYyNSwwLjAzMTI1IC0wLjAyMDgsNy43MWUtNCAtMC4wNzYzLC03LjdlLTQgLTAuMDkzNywwIC0wLjAzMDYsMC4wMDE0IC0wLjAzODIsLTAuMDA1IC0wLjA5MzcsMCAtMC4wMTM5LDAuMDAxMiAtMC4wMzIzLC0wLjAwNDEgLTAuMDYyNSwwIC0wLjAzMDIsMC4wMDQxIC0wLjIxODE3LDAuMDYyMzIgLTAuMjE4NzUsMC4wNjI1IC01LjhlLTQsMS43OGUtNCAtMC4zNDM5OSwyLjIxODU4NSAtMC4zNDM3NSwyLjIxODc1IDIuNGUtNCwxLjY1ZS00IDAuNDgwMDUsMC4yMTEyMDEgMC41MzEyNSwwLjIxODc1IDAuMjA0ODEsMC4wMzAxOSAwLjE1ODYzLC03LjUzZS00IDAuMTg3NSwwIDAuMDI4OSw3LjUzZS00IDAuMDYxNiwtMi45OGUtNCAwLjA5MzcsMCAwLjAwNiwtMi43ZS00IDAuMDUzNCwzLjM4ZS00IDAuMDYyNSwwIDAuNTQ2NiwwLjAwNCAyLjMwNjI1LC0wLjAxNjk4IDQsLTAuMDMxMjUgMC44NjAxMSwtMC4wMDcyIDEuNjc2NTMsMC4wMDMxIDIuMjUsMCAwLjI4NjczLC0wLjAwMTUgMC41MjM0MywtNS42OWUtNCAwLjY1NjI1LDAgLTAuMDE4MiwtMC4wMDIxIC0wLjAxOTIsLTAuMDIyOCAtMC4wNjI1LC0wLjAzMTI1IC0wLjAwNCwtOC43NmUtNCAtMC4wNTMyLC0wLjA1NDY0IC0wLjA2MjUsLTAuMDYyNSAwLjA3LC0wLjAwMTIgMC4yNzIzLDAuMDAxMiAwLjM0Mzc1LDAgbCAwLDAuMDkzNzUgYyAwLjAxNzQsLTAuMDAxMSAwLjA0ODQsMC4wMDUzIDAuMDkzNywwIDAuMDIyNywtMC4wMDI2IDAuMDQ0NiwtMC4wMTM2MSAwLjEyNSwtMC4wMzEyNSAwLjAwNiwtMC4wMDEzIDAuMDQ4NSwtMC4wODEwMiAwLjA2MjUsLTAuMDkzNzUgNC4yMDgzNSwtMC4wNzEzMyA5LjY3NzY3LC0wLjE1MjYzMSAxOS45MDYyNSwtMC4zMTI1IGwgLTAuMDMxMiwtMi41IHoiCiAgICAgICAgIGlkPSJwYXRoMzA5NS0xLTItOC0zLTgtNy05IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDAuNzI5MTY3NTksLTAuNzI5MTY3NTksMCwxNDQuNDE2ODIsNjY3LjU0NTcyKSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgZD0ibSAxMjEuMjcyOCw5MzQuODkzNjMgLTcuNzEzMDEsMjIuMDMxOTIgLTguMzk3NzgsLTIxLjc4MDExIGMgNC44MTA2LDMuNDI1MzMgMTEuMzE3MTksMy4zMDM0NiAxNi4xMTA3OSwtMC4yNTE4MSB6IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgaWQ9InBhdGg4Njk5IiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODcwOSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO2NvbG9yOiMwMDAwMDA7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjU7bWFya2VyOm5vbmU7dmlzaWJpbGl0eTp2aXNpYmxlO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7ZmlsdGVyOnVybCgjZmlsdGVyNDMyNS0xLTYtOC0wLTYtMy0zLTEpO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6U2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOlNhbnMiCiAgICAgICAgIGQ9Im0gMzkzLjUzMTI1LDQxLjE1NjI1IGMgLTExLjcwNjYyLDAuMTgyOTcgLTE4Ljc4NTk3LDAuMzA0OTY4IC0yMi44MTI1LDAuMzc1IC0yLjAxMzI2LDAuMDM1MDIgLTMuMjcwMzcsMC4wNDY3OCAtMy45Njg3NSwwLjA2MjUgLTAuMjk5NDIsMC4wMDY3IC0wLjQzNzIsMC4wMjY2MSAtMC41NjI1LDAuMDMxMjUgLTAuMDIwOCw3LjcxZS00IC0wLjA3NjMsLTcuN2UtNCAtMC4wOTM3LDAgLTAuMDMwNiwwLjAwMTQgLTAuMDM4MiwtMC4wMDUgLTAuMDkzNywwIC0wLjAxMzksMC4wMDEyIC0wLjAzMjMsLTAuMDA0MSAtMC4wNjI1LDAgLTAuMDMwMiwwLjAwNDEgLTAuMjE4MTcsMC4wNjIzMiAtMC4yMTg3NSwwLjA2MjUgLTUuOGUtNCwxLjc4ZS00IC0wLjM0Mzk5LDIuMjE4NTg1IC0wLjM0Mzc1LDIuMjE4NzUgMi40ZS00LDEuNjVlLTQgMC40ODAwNSwwLjIxMTIwMSAwLjUzMTI1LDAuMjE4NzUgMC4yMDQ4MSwwLjAzMDE5IDAuMTU4NjMsLTcuNTNlLTQgMC4xODc1LDAgMC4wMjg5LDcuNTNlLTQgMC4wNjE2LC0yLjk4ZS00IDAuMDkzNywwIDAuMDA2LC0yLjdlLTQgMC4wNTM0LDMuMzhlLTQgMC4wNjI1LDAgMC41NDY2LDAuMDA0IDIuMzA2MjUsLTAuMDE2OTggNCwtMC4wMzEyNSAwLjg2MDExLC0wLjAwNzIgMS42NzY1MywwLjAwMzEgMi4yNSwwIDAuMjg2NzMsLTAuMDAxNSAwLjUyMzQzLC01LjY5ZS00IDAuNjU2MjUsMCAtMC4wMTgyLC0wLjAwMjEgLTAuMDE5MiwtMC4wMjI4IC0wLjA2MjUsLTAuMDMxMjUgLTAuMDA0LC04Ljc2ZS00IC0wLjA1MzIsLTAuMDU0NjQgLTAuMDYyNSwtMC4wNjI1IDAuMDcsLTAuMDAxMiAwLjI3MjMsMC4wMDEyIDAuMzQzNzUsMCBsIDAsMC4wOTM3NSBjIDAuMDE3NCwtMC4wMDExIDAuMDQ4NCwwLjAwNTMgMC4wOTM3LDAgMC4wMjI3LC0wLjAwMjYgMC4wNDQ2LC0wLjAxMzYxIDAuMTI1LC0wLjAzMTI1IDAuMDA2LC0wLjAwMTMgMC4wNDg1LC0wLjA4MTAyIDAuMDYyNSwtMC4wOTM3NSA0LjIwODM1LC0wLjA3MTMzIDkuNjc3NjcsLTAuMTUyNjMxIDE5LjkwNjI1LC0wLjMxMjUgbCAtMC4wMzEyLC0yLjUgeiIKICAgICAgICAgaWQ9InBhdGgzMDk1LTEtMi04LTMtOC04LTItOCIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMC43MjkxNjc1OSwwLjcyOTE2NzU5LDAsODIuMDE3OTk4LDEwODQuMTAyMSkiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGQ9Im0gMTA1LjE2MjAxLDgxNi43NTQxOSA3LjcxMzAyLC0yMi4wMzE5MiA4LjM5Nzc3LDIxLjc4MDExIGMgLTQuODEwNiwtMy40MjUzMyAtMTEuMzE3MTgsLTMuMzAzNDYgLTE2LjExMDc5LDAuMjUxODEgeiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDowLjYyNTtzdHJva2UtbGluZWpvaW46cm91bmQiCiAgICAgICAgIGlkPSJwYXRoODcxNSIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjI3NTIzOTksMCwwLDEuMjc1MjM5OSwtNjAuMTAzODU5LDYzMS4yNDE0MikiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjE2cHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDtsaW5lLWhlaWdodDoxMjUlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsIgogICAgICAgaWQ9ImZsb3dSb290NDk3OS04Ij4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxMDIuMjk2ODgsMjg0Ljg2OTE4IDAsLTExLjQ1MzEzIDQuMzIwMzEsMCBjIDAuNzYwNDEsMWUtNSAxLjM0MTE0LDAuMDM2NSAxLjc0MjE5LDAuMTA5MzggMC41NjI0OSwwLjA5MzggMS4wMzM4NCwwLjI3MjE0IDEuNDE0MDYsMC41MzUxNSAwLjM4MDIsMC4yNjMwMyAwLjY4NjE5LDAuNjMxNTIgMC45MTc5NywxLjEwNTQ3IDAuMjMxNzYsMC40NzM5NyAwLjM0NzY0LDAuOTk0OCAwLjM0NzY1LDEuNTYyNSAtMWUtNSwwLjk3Mzk3IC0wLjMwOTksMS43OTgxOCAtMC45Mjk2OCwyLjQ3MjY2IC0wLjYxOTgxLDAuNjc0NDggLTEuNzM5NiwxLjAxMTcyIC0zLjM1OTM4LDEuMDExNzIgbCAtMi45Mzc1LDAgMCw0LjY1NjI1IHogbSAxLjUxNTYyLC02LjAwNzgyIDIuOTYwOTQsMCBjIDAuOTc5MTYsMWUtNSAxLjY3NDQ3LC0wLjE4MjI4IDIuMDg1OTQsLTAuNTQ2ODcgMC40MTE0NSwtMC4zNjQ1OCAwLjYxNzE3LC0wLjg3NzYgMC42MTcxOCwtMS41MzkwNiAtMWUtNSwtMC40NzkxNiAtMC4xMjExLC0wLjg4OTMyIC0wLjM2MzI4LC0xLjIzMDQ3IC0wLjI0MjE5LC0wLjM0MTE0IC0wLjU2MTIsLTAuNTY2NCAtMC45NTcwMywtMC42NzU3OCAtMC4yNTUyMiwtMC4wNjc3IC0wLjcyNjU3LC0wLjEwMTU2IC0xLjQxNDA2LC0wLjEwMTU3IGwgLTIuOTI5NjksMCB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1OTUiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTE4LjIxODc1LDI4My44NDU3NCBjIC0wLjUyMDg0LDAuNDQyNzEgLTEuMDIyMTQsMC43NTUyMSAtMS41MDM5MSwwLjkzNzUgLTAuNDgxNzcsMC4xODIyOSAtMC45OTg3LDAuMjczNDQgLTEuNTUwNzgsMC4yNzM0NCAtMC45MTE0NiwwIC0xLjYxMTk4LC0wLjIyMjY2IC0yLjEwMTU2LC0wLjY2Nzk3IC0wLjQ4OTU4LC0wLjQ0NTMxIC0wLjczNDM4LC0xLjAxNDMyIC0wLjczNDM3LC0xLjcwNzAzIC0xZS01LC0wLjQwNjI1IDAuMDkyNCwtMC43NzczNSAwLjI3NzM0LC0xLjExMzI5IDAuMTg0ODksLTAuMzM1OTMgMC40MjcwOCwtMC42MDU0NiAwLjcyNjU2LC0wLjgwODU5IDAuMjk5NDgsLTAuMjAzMTIgMC42MzY3MiwtMC4zNTY3NyAxLjAxMTcyLC0wLjQ2MDk0IDAuMjc2MDQsLTAuMDcyOSAwLjY5MjcxLC0wLjE0MzIyIDEuMjUsLTAuMjEwOTMgMS4xMzU0MSwtMC4xMzU0MiAxLjk3MTM1LC0wLjI5Njg3IDIuNTA3ODEsLTAuNDg0MzggMC4wMDUsLTAuMTkyNyAwLjAwOCwtMC4zMTUxIDAuMDA4LC0wLjM2NzE5IC0xZS01LC0wLjU3MjkxIC0wLjEzMjgyLC0wLjk3NjU1IC0wLjM5ODQ0LC0xLjIxMDkzIC0wLjM1OTM4LC0wLjMxNzcxIC0wLjg5MzI0LC0wLjQ3NjU2IC0xLjYwMTU2LC0wLjQ3NjU3IC0wLjY2MTQ3LDFlLTUgLTEuMTQ5NzUsMC4xMTU5IC0xLjQ2NDg1LDAuMzQ3NjYgLTAuMzE1MTEsMC4yMzE3OCAtMC41NDgxOCwwLjY0MTkzIC0wLjY5OTIyLDEuMjMwNDcgbCAtMS4zNzUsLTAuMTg3NSBjIDAuMTI1LC0wLjU4ODU0IDAuMzMwNzMsLTEuMDYzOCAwLjYxNzE5LC0xLjQyNTc4IDAuMjg2NDYsLTAuMzYxOTcgMC43MDA1MiwtMC42NDA2MiAxLjI0MjE5LC0wLjgzNTk0IDAuNTQxNjYsLTAuMTk1MyAxLjE2OTI2LC0wLjI5Mjk2IDEuODgyODEsLTAuMjkyOTcgMC43MDgzMywxZS01IDEuMjgzODUsMC4wODMzIDEuNzI2NTYsMC4yNSAwLjQ0MjcsMC4xNjY2OCAwLjc2ODIyLDAuMzc2MzEgMC45NzY1NywwLjYyODkxIDAuMjA4MzIsMC4yNTI2MSAwLjM1NDE1LDAuNTcxNjIgMC40Mzc1LDAuOTU3MDMgMC4wNDY5LDAuMjM5NTkgMC4wNzAzLDAuNjcxODggMC4wNzAzLDEuMjk2ODcgbCAwLDEuODc1IGMgLTEwZS02LDEuMzA3MyAwLjAyOTksMi4xMzQxMiAwLjA4OTgsMi40ODA0NyAwLjA1OTksMC4zNDYzNiAwLjE3ODM4LDAuNjc4MzkgMC4zNTU0NywwLjk5NjEgbCAtMS40Njg3NSwwIGMgLTAuMTQ1ODQsLTAuMjkxNjcgLTAuMjM5NTksLTAuNjMyODIgLTAuMjgxMjUsLTEuMDIzNDQgeiBtIC0wLjExNzE5LC0zLjE0MDYzIGMgLTAuNTEwNDIsMC4yMDgzNCAtMS4yNzYwNCwwLjM4NTQyIC0yLjI5Njg3LDAuNTMxMjUgLTAuNTc4MTMsMC4wODMzIC0wLjk4Njk4LDAuMTc3MDkgLTEuMjI2NTYsMC4yODEyNSAtMC4yMzk1OSwwLjEwNDE3IC0wLjQyNDQ5LDAuMjU2NTIgLTAuNTU0NjksMC40NTcwMyAtMC4xMzAyMSwwLjIwMDUzIC0wLjE5NTMyLDAuNDIzMTggLTAuMTk1MzEsMC42Njc5NyAtMWUtNSwwLjM3NSAwLjE0MTkyLDAuNjg3NSAwLjQyNTc4LDAuOTM3NSAwLjI4Mzg1LDAuMjUgMC42OTkyMSwwLjM3NSAxLjI0NjA5LDAuMzc1IDAuNTQxNjYsMCAxLjAyMzQzLC0wLjExODQ5IDEuNDQ1MzEsLTAuMzU1NDcgMC40MjE4NywtMC4yMzY5NyAwLjczMTc3LC0wLjU2MTE5IDAuOTI5NjksLTAuOTcyNjUgMC4xNTEwNCwtMC4zMTc3MSAwLjIyNjU2LC0wLjc4NjQ2IDAuMjI2NTYsLTEuNDA2MjUgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTk3IiAvPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDEyMS43MTA5NCwyODQuODY5MTggMCwtOC4yOTY4OCAxLjI2NTYyLDAgMCwxLjE3OTY5IGMgMC42MDkzNywtMC45MTE0NSAxLjQ4OTU4LC0xLjM2NzE4IDIuNjQwNjMsLTEuMzY3MTkgMC40OTk5OSwxZS01IDAuOTU5NjMsMC4wODk5IDEuMzc4OSwwLjI2OTUzIDAuNDE5MjcsMC4xNzk3IDAuNzMzMDcsMC40MTUzNyAwLjk0MTQxLDAuNzA3MDMgMC4yMDgzMywwLjI5MTY4IDAuMzU0MTYsMC42MzgwMyAwLjQzNzUsMS4wMzkwNyAwLjA1MjEsMC4yNjA0MiAwLjA3ODEsMC43MTYxNSAwLjA3ODEsMS4zNjcxOCBsIDAsNS4xMDE1NyAtMS40MDYyNCwwIDAsLTUuMDQ2ODggYyAtMWUtNSwtMC41NzI5MSAtMC4wNTQ3LC0xLjAwMTMgLTAuMTY0MDcsLTEuMjg1MTYgLTAuMTA5MzgsLTAuMjgzODQgLTAuMzAzMzksLTAuNTEwNDEgLTAuNTgyMDMsLTAuNjc5NjggLTAuMjc4NjUsLTAuMTY5MjcgLTAuNjA1NDcsLTAuMjUzOSAtMC45ODA0NywtMC4yNTM5MSAtMC41OTg5NiwxZS01IC0xLjExNTg5LDAuMTkwMTEgLTEuNTUwNzgsMC41NzAzMSAtMC40MzQ5LDAuMzgwMjIgLTAuNjUyMzQsMS4xMDE1NyAtMC42NTIzNCwyLjE2NDA3IGwgMCw0LjUzMTI1IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU5OSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxMzguNTA3ODEsMjg0Ljg2OTE4IC00LjQzNzUsLTExLjQ1MzEzIDEuNjQwNjMsMCAyLjk3NjU2LDguMzIwMzEgYyAwLjIzOTU4LDAuNjY2NjcgMC40NDAxLDEuMjkxNjcgMC42MDE1NiwxLjg3NSAwLjE3NzA4LC0wLjYyNDk5IDAuMzgyODEsLTEuMjQ5OTkgMC42MTcxOSwtMS44NzUgTCAxNDMsMjczLjQxNjA1IGwgMS41NDY4NywwIC00LjQ4NDM3LDExLjQ1MzEzIHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODYwMSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNDUuNzUsMjc1LjAzMzI0IDAsLTEuNjE3MTkgMS40MDYyNSwwIDAsMS42MTcxOSB6IG0gMCw5LjgzNTk0IDAsLTguMjk2ODggMS40MDYyNSwwIDAsOC4yOTY4OCB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg2MDMiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTU0Ljk4NDM3LDI4Mi4xOTczIDEuNDUzMTMsMC4xNzk2OSBjIC0wLjIyOTE3LDAuODQ4OTYgLTAuNjUzNjUsMS41MDc4MSAtMS4yNzM0NCwxLjk3NjU2IC0wLjYxOTgsMC40Njg3NSAtMS40MTE0NiwwLjcwMzEzIC0yLjM3NSwwLjcwMzEzIC0xLjIxMzU0LDAgLTIuMTc1NzgsLTAuMzczNyAtMi44ODY3MiwtMS4xMjExIC0wLjcxMDkzLC0wLjc0NzM5IC0xLjA2NjQsLTEuNzk1NTcgLTEuMDY2NCwtMy4xNDQ1MyAwLC0xLjM5NTgzIDAuMzU5MzcsLTIuNDc5MTYgMS4wNzgxMiwtMy4yNSAwLjcxODc1LC0wLjc3MDgyIDEuNjUxMDQsLTEuMTU2MjQgMi43OTY4OCwtMS4xNTYyNSAxLjEwOTM3LDFlLTUgMi4wMTU2MiwwLjM3NzYxIDIuNzE4NzUsMS4xMzI4MSAwLjcwMzExLDAuNzU1MjIgMS4wNTQ2OCwxLjgxNzcyIDEuMDU0NjgsMy4xODc1IDAsMC4wODMzIC0wLjAwMywwLjIwODM0IC0wLjAwOCwwLjM3NSBsIC02LjE4NzUsMCBjIDAuMDUyMSwwLjkxMTQ2IDAuMzA5OSwxLjYwOTM4IDAuNzczNDQsMi4wOTM3NSAwLjQ2MzU0LDAuNDg0MzggMS4wNDE2NiwwLjcyNjU3IDEuNzM0MzcsMC43MjY1NyAwLjUxNTYyLDAgMC45NTU3MywtMC4xMzU0MiAxLjMyMDMyLC0wLjQwNjI1IDAuMzY0NTcsLTAuMjcwODQgMC42NTM2NCwtMC43MDMxMyAwLjg2NzE4LC0xLjI5Njg4IHogbSAtNC42MTcxOCwtMi4yNzM0NCA0LjYzMjgxLDAgYyAtMC4wNjI1LC0wLjY5NzkxIC0wLjIzOTU5LC0xLjIyMTM0IC0wLjUzMTI1LC0xLjU3MDMxIC0wLjQ0NzkyLC0wLjU0MTY2IC0xLjAyODY1LC0wLjgxMjQ5IC0xLjc0MjE5LC0wLjgxMjUgLTAuNjQ1ODMsMWUtNSAtMS4xODg4LDAuMjE2MTUgLTEuNjI4OSwwLjY0ODQ0IC0wLjQ0MDExLDAuNDMyMyAtMC42ODM2LDEuMDEwNDIgLTAuNzMwNDcsMS43MzQzNyB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg2MDUiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTU5Ljc0MjE5LDI4NC44NjkxOCAtMi41MzkwNywtOC4yOTY4OCAxLjQ1MzEzLDAgMS4zMjAzMSw0Ljc4OTA2IDAuNDkyMTksMS43ODEyNSBjIDAuMDIwOCwtMC4wODg1IDAuMTY0MDYsLTAuNjU4ODUgMC40Mjk2OSwtMS43MTA5MyBsIDEuMzIwMzEsLTQuODU5MzggMS40NDUzMSwwIDEuMjQyMTksNC44MTI1IDAuNDE0MDYsMS41ODU5NCAwLjQ3NjU2LC0xLjYwMTU2IDEuNDIxODgsLTQuNzk2ODggMS4zNjcxOSwwIC0yLjU5Mzc1LDguMjk2ODggLTEuNDYwOTQsMCAtMS4zMjAzMSwtNC45Njg3NSAtMC4zMjAzMiwtMS40MTQwNyAtMS42Nzk2OCw2LjM4MjgyIHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODYwNyIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjI3NTIzOTksMCwwLDEuMjc1MjM5OSwxNTQuMTM4OTMsNjMxLjI0MTQyKSIKICAgICAgIHN0eWxlPSJmb250LXNpemU6MTZweDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXN0cmV0Y2g6bm9ybWFsO2xpbmUtaGVpZ2h0OjEyNSU7bGV0dGVyLXNwYWNpbmc6MHB4O3dvcmQtc3BhY2luZzowcHg7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWwiCiAgICAgICBpZD0iZmxvd1Jvb3Q0OTc5LTgtNCI+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTAyLjMyMDMxLDI4NC44NjkxOCAwLC0xMS40NTMxMyA1LjA3ODEzLDAgYyAxLjAyMDgyLDFlLTUgMS43OTY4NiwwLjEwMjg4IDIuMzI4MTIsMC4zMDg1OSAwLjUzMTI0LDAuMjA1NzQgMC45NTU3MiwwLjU2OTAzIDEuMjczNDQsMS4wODk4NSAwLjMxNzcsMC41MjA4NCAwLjQ3NjU1LDEuMDk2MzYgMC40NzY1NiwxLjcyNjU2IC0xZS01LDAuODEyNTEgLTAuMjYzMDMsMS40OTc0IC0wLjc4OTA2LDIuMDU0NjkgLTAuNTI2MDUsMC41NTczIC0xLjMzODU1LDAuOTExNDYgLTIuNDM3NSwxLjA2MjUgMC40MDEwMywwLjE5MjcxIDAuNzA1NzIsMC4zODI4MiAwLjkxNDA2LDAuNTcwMzEgMC40NDI3LDAuNDA2MjUgMC44NjE5NywwLjkxNDA3IDEuMjU3ODIsMS41MjM0NCBsIDEuOTkyMTgsMy4xMTcxOSAtMS45MDYyNSwwIC0xLjUxNTYyLC0yLjM4MjgyIGMgLTAuNDQyNzIsLTAuNjg3NDkgLTAuODA3MywtMS4yMTM1MyAtMS4wOTM3NSwtMS41NzgxMiAtMC4yODY0NywtMC4zNjQ1OCAtMC41NDI5OCwtMC42MTk3OSAtMC43Njk1MywtMC43NjU2MyAtMC4yMjY1NywtMC4xNDU4MyAtMC40NTcwNCwtMC4yNDczOSAtMC42OTE0MSwtMC4zMDQ2OCAtMC4xNzE4OCwtMC4wMzY1IC0wLjQ1MzEzLC0wLjA1NDcgLTAuODQzNzUsLTAuMDU0NyBsIC0xLjc1NzgxLDAgMCw1LjA4NTk0IHogbSAxLjUxNTYzLC02LjM5ODQ0IDMuMjU3ODEsMCBjIDAuNjkyNywwIDEuMjM0MzcsLTAuMDcxNiAxLjYyNSwtMC4yMTQ4NSAwLjM5MDYyLC0wLjE0MzIyIDAuNjg3NDksLTAuMzcyMzggMC44OTA2MywtMC42ODc1IDAuMjAzMTEsLTAuMzE1MDkgMC4zMDQ2NywtMC42NTc1NCAwLjMwNDY4LC0xLjAyNzM0IC0xZS01LC0wLjU0MTY2IC0wLjE5NjYyLC0wLjk4Njk3IC0wLjU4OTg0LC0xLjMzNTk0IC0wLjM5MzI0LC0wLjM0ODk1IC0xLjAxNDMzLC0wLjUyMzQyIC0xLjg2MzI4LC0wLjUyMzQzIGwgLTMuNjI1LDAgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTc0IiAvPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDExMy4xNTYyNSwyODAuNzIwNzQgYyAwLC0xLjUzNjQ1IDAuNDI3MDgsLTIuNjc0NDcgMS4yODEyNSwtMy40MTQwNiAwLjcxMzU0LC0wLjYxNDU4IDEuNTgzMzMsLTAuOTIxODcgMi42MDkzOCwtMC45MjE4OCAxLjE0MDYxLDFlLTUgMi4wNzI5MSwwLjM3MzcxIDIuNzk2ODcsMS4xMjEwOSAwLjcyMzk1LDAuNzQ3NDEgMS4wODU5MywxLjc3OTk2IDEuMDg1OTQsMy4wOTc2NiAtMTBlLTYsMS4wNjc3MSAtMC4xNjAxNywxLjkwNzU2IC0wLjQ4MDQ3LDIuNTE5NTMgLTAuMzIwMzIsMC42MTE5OCAtMC43ODY0NywxLjA4NzI0IC0xLjM5ODQ0LDEuNDI1NzggLTAuNjExOTgsMC4zMzg1NCAtMS4yNzk5NSwwLjUwNzgyIC0yLjAwMzksMC41MDc4MiAtMS4xNjE0NywwIC0yLjEwMDI3LC0wLjM3MjQgLTIuODE2NDEsLTEuMTE3MTkgLTAuNzE2MTUsLTAuNzQ0NzkgLTEuMDc0MjIsLTEuODE3NzEgLTEuMDc0MjIsLTMuMjE4NzUgeiBtIDEuNDQ1MzEsMCBjIDAsMS4wNjI1IDAuMjMxNzcsMS44NTgwNyAwLjY5NTMyLDIuMzg2NzIgMC40NjM1MywwLjUyODY0IDEuMDQ2ODcsMC43OTI5NyAxLjc1LDAuNzkyOTcgMC42OTc5MSwwIDEuMjc4NjQsLTAuMjY1NjMgMS43NDIxOCwtMC43OTY4OCAwLjQ2MzU0LC0wLjUzMTI1IDAuNjk1MzEsLTEuMzQxMTQgMC42OTUzMiwtMi40Mjk2OSAtMWUtNSwtMS4wMjYwMyAtMC4yMzMwOCwtMS44MDMzOCAtMC42OTkyMiwtMi4zMzIwMyAtMC40NjYxNiwtMC41Mjg2NCAtMS4wNDU1OCwtMC43OTI5NiAtMS43MzgyOCwtMC43OTI5NyAtMC43MDMxMywxZS01IC0xLjI4NjQ3LDAuMjYzMDMgLTEuNzUsMC43ODkwNyAtMC40NjM1NSwwLjUyNjA0IC0wLjY5NTMyLDEuMzIwMzEgLTAuNjk1MzIsMi4zODI4MSB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1NzYiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTI1LjY1NjI1LDI4My42MTEzNiAwLjIwMzEzLDEuMjQyMTkgYyAtMC4zOTU4NCwwLjA4MzMgLTAuNzUwMDEsMC4xMjUgLTEuMDYyNSwwLjEyNSAtMC41MTA0MiwwIC0wLjkwNjI2LC0wLjA4MDcgLTEuMTg3NSwtMC4yNDIxOSAtMC4yODEyNiwtMC4xNjE0NSAtMC40NzkxNywtMC4zNzM2OSAtMC41OTM3NSwtMC42MzY3MiAtMC4xMTQ1OSwtMC4yNjMwMiAtMC4xNzE4OCwtMC44MTY0IC0wLjE3MTg4LC0xLjY2MDE1IGwgMCwtNC43NzM0NCAtMS4wMzEyNSwwIDAsLTEuMDkzNzUgMS4wMzEyNSwwIDAsLTIuMDU0NjkgMS4zOTg0NCwtMC44NDM3NSAwLDIuODk4NDQgMS40MTQwNiwwIDAsMS4wOTM3NSAtMS40MTQwNiwwIDAsNC44NTE1NiBjIC0xMGUtNiwwLjQwMTA1IDAuMDI0NywwLjY1ODg2IDAuMDc0MiwwLjc3MzQ0IDAuMDQ5NSwwLjExNDU5IDAuMTMwMiwwLjIwNTczIDAuMjQyMTgsMC4yNzM0NCAwLjExMTk4LDAuMDY3NyAwLjI3MjE0LDAuMTAxNTYgMC40ODA0NywwLjEwMTU2IDAuMTU2MjUsMCAwLjM2MTk4LC0wLjAxODIgMC42MTcxOSwtMC4wNTQ3IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU3OCIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxMzIuNDM3NSwyODMuODQ1NzQgYyAtMC41MjA4NCwwLjQ0MjcxIC0xLjAyMjE0LDAuNzU1MjEgLTEuNTAzOTEsMC45Mzc1IC0wLjQ4MTc3LDAuMTgyMjkgLTAuOTk4NywwLjI3MzQ0IC0xLjU1MDc4LDAuMjczNDQgLTAuOTExNDYsMCAtMS42MTE5OCwtMC4yMjI2NiAtMi4xMDE1NiwtMC42Njc5NyAtMC40ODk1OCwtMC40NDUzMSAtMC43MzQzOCwtMS4wMTQzMiAtMC43MzQzNywtMS43MDcwMyAtMWUtNSwtMC40MDYyNSAwLjA5MjQsLTAuNzc3MzUgMC4yNzczNCwtMS4xMTMyOSAwLjE4NDg5LC0wLjMzNTkzIDAuNDI3MDgsLTAuNjA1NDYgMC43MjY1NiwtMC44MDg1OSAwLjI5OTQ4LC0wLjIwMzEyIDAuNjM2NzIsLTAuMzU2NzcgMS4wMTE3MiwtMC40NjA5NCAwLjI3NjA0LC0wLjA3MjkgMC42OTI3MSwtMC4xNDMyMiAxLjI1LC0wLjIxMDkzIDEuMTM1NDEsLTAuMTM1NDIgMS45NzEzNSwtMC4yOTY4NyAyLjUwNzgxLC0wLjQ4NDM4IDAuMDA1LC0wLjE5MjcgMC4wMDgsLTAuMzE1MSAwLjAwOCwtMC4zNjcxOSAwLC0wLjU3MjkxIC0wLjEzMjgxLC0wLjk3NjU1IC0wLjM5ODQzLC0xLjIxMDkzIC0wLjM1OTM4LC0wLjMxNzcxIC0wLjg5MzI0LC0wLjQ3NjU2IC0xLjYwMTU3LC0wLjQ3NjU3IC0wLjY2MTQ2LDFlLTUgLTEuMTQ5NzQsMC4xMTU5IC0xLjQ2NDg0LDAuMzQ3NjYgLTAuMzE1MTEsMC4yMzE3OCAtMC41NDgxOCwwLjY0MTkzIC0wLjY5OTIyLDEuMjMwNDcgbCAtMS4zNzUsLTAuMTg3NSBjIDAuMTI1LC0wLjU4ODU0IDAuMzMwNzMsLTEuMDYzOCAwLjYxNzE5LC0xLjQyNTc4IDAuMjg2NDYsLTAuMzYxOTcgMC43MDA1MiwtMC42NDA2MiAxLjI0MjE5LC0wLjgzNTk0IDAuNTQxNjYsLTAuMTk1MyAxLjE2OTI2LC0wLjI5Mjk2IDEuODgyODEsLTAuMjkyOTcgMC43MDgzMywxZS01IDEuMjgzODUsMC4wODMzIDEuNzI2NTYsMC4yNSAwLjQ0MjcsMC4xNjY2OCAwLjc2ODIyLDAuMzc2MzEgMC45NzY1NiwwLjYyODkxIDAuMjA4MzMsMC4yNTI2MSAwLjM1NDE2LDAuNTcxNjIgMC40Mzc1LDAuOTU3MDMgMC4wNDY5LDAuMjM5NTkgMC4wNzAzLDAuNjcxODggMC4wNzAzLDEuMjk2ODcgbCAwLDEuODc1IGMgLTFlLTUsMS4zMDczIDAuMDI5OSwyLjEzNDEyIDAuMDg5OCwyLjQ4MDQ3IDAuMDU5OSwwLjM0NjM2IDAuMTc4MzgsMC42NzgzOSAwLjM1NTQ3LDAuOTk2MSBsIC0xLjQ2ODc1LDAgYyAtMC4xNDU4NCwtMC4yOTE2NyAtMC4yMzk1OSwtMC42MzI4MiAtMC4yODEyNSwtMS4wMjM0NCB6IG0gLTAuMTE3MTksLTMuMTQwNjMgYyAtMC41MTA0MiwwLjIwODM0IC0xLjI3NjA0LDAuMzg1NDIgLTIuMjk2ODcsMC41MzEyNSAtMC41NzgxMywwLjA4MzMgLTAuOTg2OTgsMC4xNzcwOSAtMS4yMjY1NywwLjI4MTI1IC0wLjIzOTU4LDAuMTA0MTcgLTAuNDI0NDgsMC4yNTY1MiAtMC41NTQ2OCwwLjQ1NzAzIC0wLjEzMDIxLDAuMjAwNTMgLTAuMTk1MzIsMC40MjMxOCAtMC4xOTUzMiwwLjY2Nzk3IDAsMC4zNzUgMC4xNDE5MywwLjY4NzUgMC40MjU3OSwwLjkzNzUgMC4yODM4NSwwLjI1IDAuNjk5MjEsMC4zNzUgMS4yNDYwOSwwLjM3NSAwLjU0MTY2LDAgMS4wMjM0MywtMC4xMTg0OSAxLjQ0NTMxLC0wLjM1NTQ3IDAuNDIxODcsLTAuMjM2OTcgMC43MzE3NywtMC41NjExOSAwLjkyOTY5LC0wLjk3MjY1IDAuMTUxMDQsLTAuMzE3NzEgMC4yMjY1NiwtMC43ODY0NiAwLjIyNjU2LC0xLjQwNjI1IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU4MCIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxMzksMjgzLjYxMTM2IDAuMjAzMTIsMS4yNDIxOSBjIC0wLjM5NTgzLDAuMDgzMyAtMC43NSwwLjEyNSAtMS4wNjI1LDAuMTI1IC0wLjUxMDQxLDAgLTAuOTA2MjUsLTAuMDgwNyAtMS4xODc1LC0wLjI0MjE5IC0wLjI4MTI1LC0wLjE2MTQ1IC0wLjQ3OTE2LC0wLjM3MzY5IC0wLjU5Mzc1LC0wLjYzNjcyIC0wLjExNDU4LC0wLjI2MzAyIC0wLjE3MTg3LC0wLjgxNjQgLTAuMTcxODcsLTEuNjYwMTUgbCAwLC00Ljc3MzQ0IC0xLjAzMTI1LDAgMCwtMS4wOTM3NSAxLjAzMTI1LDAgMCwtMi4wNTQ2OSAxLjM5ODQ0LC0wLjg0Mzc1IDAsMi44OTg0NCAxLjQxNDA2LDAgMCwxLjA5Mzc1IC0xLjQxNDA2LDAgMCw0Ljg1MTU2IGMgLTFlLTUsMC40MDEwNSAwLjAyNDcsMC42NTg4NiAwLjA3NDIsMC43NzM0NCAwLjA0OTUsMC4xMTQ1OSAwLjEzMDIsMC4yMDU3MyAwLjI0MjE4LDAuMjczNDQgMC4xMTE5OCwwLjA2NzcgMC4yNzIxNCwwLjEwMTU2IDAuNDgwNDcsMC4xMDE1NiAwLjE1NjI1LDAgMC4zNjE5OCwtMC4wMTgyIDAuNjE3MTksLTAuMDU0NyB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1ODIiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTQ2LjA0Njg3LDI4Mi4xOTczIDEuNDUzMTMsMC4xNzk2OSBjIC0wLjIyOTE3LDAuODQ4OTYgLTAuNjUzNjUsMS41MDc4MSAtMS4yNzM0NCwxLjk3NjU2IC0wLjYxOTgsMC40Njg3NSAtMS40MTE0NiwwLjcwMzEzIC0yLjM3NSwwLjcwMzEzIC0xLjIxMzU0LDAgLTIuMTc1NzgsLTAuMzczNyAtMi44ODY3MiwtMS4xMjExIC0wLjcxMDkzLC0wLjc0NzM5IC0xLjA2NjQsLTEuNzk1NTcgLTEuMDY2NCwtMy4xNDQ1MyAwLC0xLjM5NTgzIDAuMzU5MzcsLTIuNDc5MTYgMS4wNzgxMiwtMy4yNSAwLjcxODc1LC0wLjc3MDgyIDEuNjUxMDQsLTEuMTU2MjQgMi43OTY4OCwtMS4xNTYyNSAxLjEwOTM3LDFlLTUgMi4wMTU2MiwwLjM3NzYxIDIuNzE4NzUsMS4xMzI4MSAwLjcwMzExLDAuNzU1MjIgMS4wNTQ2OCwxLjgxNzcyIDEuMDU0NjgsMy4xODc1IDAsMC4wODMzIC0wLjAwMywwLjIwODM0IC0wLjAwOCwwLjM3NSBsIC02LjE4NzUsMCBjIDAuMDUyMSwwLjkxMTQ2IDAuMzA5OSwxLjYwOTM4IDAuNzczNDQsMi4wOTM3NSAwLjQ2MzU0LDAuNDg0MzggMS4wNDE2NiwwLjcyNjU3IDEuNzM0MzcsMC43MjY1NyAwLjUxNTYyLDAgMC45NTU3MywtMC4xMzU0MiAxLjMyMDMyLC0wLjQwNjI1IDAuMzY0NTcsLTAuMjcwODQgMC42NTM2NCwtMC43MDMxMyAwLjg2NzE4LC0xLjI5Njg4IHogbSAtNC42MTcxOCwtMi4yNzM0NCA0LjYzMjgxLDAgYyAtMC4wNjI1LC0wLjY5NzkxIC0wLjIzOTU5LC0xLjIyMTM0IC0wLjUzMTI1LC0xLjU3MDMxIC0wLjQ0NzkyLC0wLjU0MTY2IC0xLjAyODY1LC0wLjgxMjQ5IC0xLjc0MjE5LC0wLjgxMjUgLTAuNjQ1ODMsMWUtNSAtMS4xODg4LDAuMjE2MTUgLTEuNjI4OSwwLjY0ODQ0IC0wLjQ0MDExLDAuNDMyMyAtMC42ODM2LDEuMDEwNDIgLTAuNzMwNDcsMS43MzQzNyB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1ODQiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTU3LjE2NDA2LDI4NC44NjkxOCAtNC40Mzc1LC0xMS40NTMxMyAxLjY0MDYzLDAgMi45NzY1Niw4LjMyMDMxIGMgMC4yMzk1OCwwLjY2NjY3IDAuNDQwMSwxLjI5MTY3IDAuNjAxNTYsMS44NzUgMC4xNzcwOCwtMC42MjQ5OSAwLjM4MjgxLC0xLjI0OTk5IDAuNjE3MTksLTEuODc1IGwgMy4wOTM3NSwtOC4zMjAzMSAxLjU0Njg3LDAgLTQuNDg0MzcsMTEuNDUzMTMgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTg2IiAvPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDE2NC40MDYyNSwyNzUuMDMzMjQgMCwtMS42MTcxOSAxLjQwNjI1LDAgMCwxLjYxNzE5IHogbSAwLDkuODM1OTQgMCwtOC4yOTY4OCAxLjQwNjI1LDAgMCw4LjI5Njg4IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU4OCIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNzMuNjQwNjIsMjgyLjE5NzMgMS40NTMxMywwLjE3OTY5IGMgLTAuMjI5MTcsMC44NDg5NiAtMC42NTM2NSwxLjUwNzgxIC0xLjI3MzQ0LDEuOTc2NTYgLTAuNjE5OCwwLjQ2ODc1IC0xLjQxMTQ2LDAuNzAzMTMgLTIuMzc1LDAuNzAzMTMgLTEuMjEzNTQsMCAtMi4xNzU3OCwtMC4zNzM3IC0yLjg4NjcyLC0xLjEyMTEgLTAuNzEwOTMsLTAuNzQ3MzkgLTEuMDY2NCwtMS43OTU1NyAtMS4wNjY0LC0zLjE0NDUzIDAsLTEuMzk1ODMgMC4zNTkzNywtMi40NzkxNiAxLjA3ODEyLC0zLjI1IDAuNzE4NzUsLTAuNzcwODIgMS42NTEwNCwtMS4xNTYyNCAyLjc5Njg4LC0xLjE1NjI1IDEuMTA5MzcsMWUtNSAyLjAxNTYyLDAuMzc3NjEgMi43MTg3NSwxLjEzMjgxIDAuNzAzMTEsMC43NTUyMiAxLjA1NDY4LDEuODE3NzIgMS4wNTQ2OCwzLjE4NzUgMCwwLjA4MzMgLTAuMDAzLDAuMjA4MzQgLTAuMDA4LDAuMzc1IGwgLTYuMTg3NSwwIGMgMC4wNTIxLDAuOTExNDYgMC4zMDk5LDEuNjA5MzggMC43NzM0NCwyLjA5Mzc1IDAuNDYzNTQsMC40ODQzOCAxLjA0MTY2LDAuNzI2NTcgMS43MzQzNywwLjcyNjU3IDAuNTE1NjIsMCAwLjk1NTczLC0wLjEzNTQyIDEuMzIwMzIsLTAuNDA2MjUgMC4zNjQ1NywtMC4yNzA4NCAwLjY1MzY0LC0wLjcwMzEzIDAuODY3MTgsLTEuMjk2ODggeiBtIC00LjYxNzE4LC0yLjI3MzQ0IDQuNjMyODEsMCBjIC0wLjA2MjUsLTAuNjk3OTEgLTAuMjM5NTksLTEuMjIxMzQgLTAuNTMxMjUsLTEuNTcwMzEgLTAuNDQ3OTIsLTAuNTQxNjYgLTEuMDI4NjUsLTAuODEyNDkgLTEuNzQyMTksLTAuODEyNSAtMC42NDU4MywxZS01IC0xLjE4ODgsMC4yMTYxNSAtMS42Mjg5LDAuNjQ4NDQgLTAuNDQwMTEsMC40MzIzIC0wLjY4MzYsMS4wMTA0MiAtMC43MzA0NywxLjczNDM3IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU5MCIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNzguMzk4NDQsMjg0Ljg2OTE4IC0yLjUzOTA3LC04LjI5Njg4IDEuNDUzMTMsMCAxLjMyMDMxLDQuNzg5MDYgMC40OTIxOSwxLjc4MTI1IGMgMC4wMjA4LC0wLjA4ODUgMC4xNjQwNiwtMC42NTg4NSAwLjQyOTY5LC0xLjcxMDkzIGwgMS4zMjAzMSwtNC44NTkzOCAxLjQ0NTMxLDAgMS4yNDIxOSw0LjgxMjUgMC40MTQwNiwxLjU4NTk0IDAuNDc2NTYsLTEuNjAxNTYgMS40MjE4OCwtNC43OTY4OCAxLjM2NzE5LDAgLTIuNTkzNzUsOC4yOTY4OCAtMS40NjA5NCwwIC0xLjMyMDMxLC00Ljk2ODc1IC0wLjMyMDMyLC0xLjQxNDA3IC0xLjY3OTY4LDYuMzgyODIgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTkyIiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjc1MjM5OSwwLDAsMS4yNzUyMzk5LDM3NC45NTE4LDYzMS4yNDE0MikiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjE2cHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDtsaW5lLWhlaWdodDoxMjUlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsIgogICAgICAgaWQ9ImZsb3dSb290NDk3OS04LTQtMCI+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTAxLjM4MjgxLDI4NC44NjkxOCAwLC0xLjQwNjI1IDUuODY3MTksLTcuMzM1OTQgYyAwLjQxNjY2LC0wLjUyMDgzIDAuODEyNDksLTAuOTczOTUgMS4xODc1LC0xLjM1OTM4IGwgLTYuMzkwNjIsMCAwLC0xLjM1MTU2IDguMjAzMTIsMCAwLDEuMzUxNTYgLTYuNDI5NjksNy45NDUzMiAtMC42OTUzMSwwLjgwNDY4IDcuMzEyNSwwIDAsMS4zNTE1NyB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1NTciIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTExLjM3NSwyODAuNzIwNzQgYyAwLC0xLjUzNjQ1IDAuNDI3MDgsLTIuNjc0NDcgMS4yODEyNSwtMy40MTQwNiAwLjcxMzU0LC0wLjYxNDU4IDEuNTgzMzMsLTAuOTIxODcgMi42MDkzOCwtMC45MjE4OCAxLjE0MDYxLDFlLTUgMi4wNzI5MSwwLjM3MzcxIDIuNzk2ODcsMS4xMjEwOSAwLjcyMzk1LDAuNzQ3NDEgMS4wODU5MywxLjc3OTk2IDEuMDg1OTQsMy4wOTc2NiAtMTBlLTYsMS4wNjc3MSAtMC4xNjAxNywxLjkwNzU2IC0wLjQ4MDQ3LDIuNTE5NTMgLTAuMzIwMzIsMC42MTE5OCAtMC43ODY0NywxLjA4NzI0IC0xLjM5ODQ0LDEuNDI1NzggLTAuNjExOTgsMC4zMzg1NCAtMS4yNzk5NSwwLjUwNzgyIC0yLjAwMzksMC41MDc4MiAtMS4xNjE0NywwIC0yLjEwMDI3LC0wLjM3MjQgLTIuODE2NDEsLTEuMTE3MTkgLTAuNzE2MTUsLTAuNzQ0NzkgLTEuMDc0MjIsLTEuODE3NzEgLTEuMDc0MjIsLTMuMjE4NzUgeiBtIDEuNDQ1MzEsMCBjIDAsMS4wNjI1IDAuMjMxNzcsMS44NTgwNyAwLjY5NTMyLDIuMzg2NzIgMC40NjM1MywwLjUyODY0IDEuMDQ2ODcsMC43OTI5NyAxLjc1LDAuNzkyOTcgMC42OTc5MSwwIDEuMjc4NjQsLTAuMjY1NjMgMS43NDIxOCwtMC43OTY4OCAwLjQ2MzU0LC0wLjUzMTI1IDAuNjk1MzEsLTEuMzQxMTQgMC42OTUzMiwtMi40Mjk2OSAtMWUtNSwtMS4wMjYwMyAtMC4yMzMwOCwtMS44MDMzOCAtMC42OTkyMiwtMi4zMzIwMyAtMC40NjYxNiwtMC41Mjg2NCAtMS4wNDU1OCwtMC43OTI5NiAtMS43MzgyOCwtMC43OTI5NyAtMC43MDMxMywxZS01IC0xLjI4NjQ3LDAuMjYzMDMgLTEuNzUsMC43ODkwNyAtMC40NjM1NSwwLjUyNjA0IC0wLjY5NTMyLDEuMzIwMzEgLTAuNjk1MzIsMi4zODI4MSB6IgogICAgICAgICBzdHlsZT0iIgogICAgICAgICBpZD0icGF0aDg1NTkiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMTIwLjI4MTI1LDI4MC43MjA3NCBjIDAsLTEuNTM2NDUgMC40MjcwOCwtMi42NzQ0NyAxLjI4MTI1LC0zLjQxNDA2IDAuNzEzNTQsLTAuNjE0NTggMS41ODMzMywtMC45MjE4NyAyLjYwOTM4LC0wLjkyMTg4IDEuMTQwNjEsMWUtNSAyLjA3MjkxLDAuMzczNzEgMi43OTY4NywxLjEyMTA5IDAuNzIzOTUsMC43NDc0MSAxLjA4NTkzLDEuNzc5OTYgMS4wODU5NCwzLjA5NzY2IC0xZS01LDEuMDY3NzEgLTAuMTYwMTcsMS45MDc1NiAtMC40ODA0NywyLjUxOTUzIC0wLjMyMDMyLDAuNjExOTggLTAuNzg2NDcsMS4wODcyNCAtMS4zOTg0NCwxLjQyNTc4IC0wLjYxMTk4LDAuMzM4NTQgLTEuMjc5OTUsMC41MDc4MiAtMi4wMDM5LDAuNTA3ODIgLTEuMTYxNDcsMCAtMi4xMDAyNywtMC4zNzI0IC0yLjgxNjQxLC0xLjExNzE5IC0wLjcxNjE1LC0wLjc0NDc5IC0xLjA3NDIyLC0xLjgxNzcxIC0xLjA3NDIyLC0zLjIxODc1IHogbSAxLjQ0NTMxLDAgYyAwLDEuMDYyNSAwLjIzMTc3LDEuODU4MDcgMC42OTUzMiwyLjM4NjcyIDAuNDYzNTMsMC41Mjg2NCAxLjA0Njg3LDAuNzkyOTcgMS43NSwwLjc5Mjk3IDAuNjk3OTEsMCAxLjI3ODY0LC0wLjI2NTYzIDEuNzQyMTgsLTAuNzk2ODggMC40NjM1NCwtMC41MzEyNSAwLjY5NTMxLC0xLjM0MTE0IDAuNjk1MzIsLTIuNDI5NjkgLTFlLTUsLTEuMDI2MDMgLTAuMjMzMDgsLTEuODAzMzggLTAuNjk5MjIsLTIuMzMyMDMgLTAuNDY2MTYsLTAuNTI4NjQgLTEuMDQ1NTgsLTAuNzkyOTYgLTEuNzM4MjgsLTAuNzkyOTcgLTAuNzAzMTMsMWUtNSAtMS4yODY0NywwLjI2MzAzIC0xLjc1LDAuNzg5MDcgLTAuNDYzNTUsMC41MjYwNCAtMC42OTUzMiwxLjMyMDMxIC0wLjY5NTMyLDIuMzgyODEgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTYxIiAvPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDEyOS43MTA5NCwyODQuODY5MTggMCwtOC4yOTY4OCAxLjI1NzgxLDAgMCwxLjE2NDA2IGMgMC4yNjA0MSwtMC40MDYyNCAwLjYwNjc3LC0wLjczMzA2IDEuMDM5MDYsLTAuOTgwNDcgMC40MzIyOSwtMC4yNDczOCAwLjkyNDQ4LC0wLjM3MTA4IDEuNDc2NTYsLTAuMzcxMDkgMC42MTQ1OCwxZS01IDEuMTE4NDksMC4xMjc2MSAxLjUxMTcyLDAuMzgyODEgMC4zOTMyMywwLjI1NTIyIDAuNjcwNTcsMC42MTE5OSAwLjgzMjAzLDEuMDcwMzIgMC42NTYyNSwtMC45Njg3NSAxLjUxMDQxLC0xLjQ1MzEyIDIuNTYyNSwtMS40NTMxMyAwLjgyMjkxLDFlLTUgMS40NTU3MiwwLjIyNzg3IDEuODk4NDQsMC42ODM1OSAwLjQ0MjcsMC40NTU3NCAwLjY2NDA1LDEuMTU3NTYgMC42NjQwNiwyLjEwNTQ3IGwgMCw1LjY5NTMyIC0xLjM5ODQzLDAgMCwtNS4yMjY1NyBjIC0xZS01LC0wLjU2MjQ5IC0wLjA0NTYsLTAuOTY3NDQgLTAuMTM2NzIsLTEuMjE0ODQgLTAuMDkxMiwtMC4yNDczOSAtMC4yNTY1MiwtMC40NDY2MSAtMC40OTYxLC0wLjU5NzY2IC0wLjIzOTU5LC0wLjE1MTAzIC0wLjUyMDg0LC0wLjIyNjU1IC0wLjg0Mzc1LC0wLjIyNjU2IC0wLjU4MzM0LDFlLTUgLTEuMDY3NzEsMC4xOTQwMiAtMS40NTMxMiwwLjU4MjAzIC0wLjM4NTQyLDAuMzg4MDMgLTAuNTc4MTMsMS4wMDkxMiAtMC41NzgxMywxLjg2MzI4IGwgMCw0LjgyMDMyIC0xLjQwNjI1LDAgMCwtNS4zOTA2MyBjIDAsLTAuNjI0OTkgLTAuMTE0NTgsLTEuMDkzNzQgLTAuMzQzNzUsLTEuNDA2MjUgLTAuMjI5MTcsLTAuMzEyNDkgLTAuNjA0MTcsLTAuNDY4NzQgLTEuMTI1LC0wLjQ2ODc1IC0wLjM5NTgzLDFlLTUgLTAuNzYxNzIsMC4xMDQxNyAtMS4wOTc2NSwwLjMxMjUgLTAuMzM1OTQsMC4yMDgzNCAtMC41Nzk0MywwLjUxMzAzIC0wLjczMDQ3LDAuOTE0MDYgLTAuMTUxMDQsMC40MDEwNSAtMC4yMjY1NiwwLjk3OTE3IC0wLjIyNjU2LDEuNzM0MzggbCAwLDQuMzA0NjkgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTYzIiAvPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDE1MC45NDUzMSwyODQuODY5MTggLTQuNDM3NSwtMTEuNDUzMTMgMS42NDA2MywwIDIuOTc2NTYsOC4zMjAzMSBjIDAuMjM5NTgsMC42NjY2NyAwLjQ0MDEsMS4yOTE2NyAwLjYwMTU2LDEuODc1IDAuMTc3MDgsLTAuNjI0OTkgMC4zODI4MSwtMS4yNDk5OSAwLjYxNzE5LC0xLjg3NSBsIDMuMDkzNzUsLTguMzIwMzEgMS41NDY4NywwIC00LjQ4NDM3LDExLjQ1MzEzIHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU2NSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNTguMTg3NSwyNzUuMDMzMjQgMCwtMS42MTcxOSAxLjQwNjI1LDAgMCwxLjYxNzE5IHogbSAwLDkuODM1OTQgMCwtOC4yOTY4OCAxLjQwNjI1LDAgMCw4LjI5Njg4IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU2NyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNjcuNDIxODcsMjgyLjE5NzMgMS40NTMxMywwLjE3OTY5IGMgLTAuMjI5MTcsMC44NDg5NiAtMC42NTM2NSwxLjUwNzgxIC0xLjI3MzQ0LDEuOTc2NTYgLTAuNjE5OCwwLjQ2ODc1IC0xLjQxMTQ2LDAuNzAzMTMgLTIuMzc1LDAuNzAzMTMgLTEuMjEzNTQsMCAtMi4xNzU3OCwtMC4zNzM3IC0yLjg4NjcyLC0xLjEyMTEgLTAuNzEwOTMsLTAuNzQ3MzkgLTEuMDY2NCwtMS43OTU1NyAtMS4wNjY0LC0zLjE0NDUzIDAsLTEuMzk1ODMgMC4zNTkzNywtMi40NzkxNiAxLjA3ODEyLC0zLjI1IDAuNzE4NzUsLTAuNzcwODIgMS42NTEwNCwtMS4xNTYyNCAyLjc5Njg4LC0xLjE1NjI1IDEuMTA5MzcsMWUtNSAyLjAxNTYyLDAuMzc3NjEgMi43MTg3NSwxLjEzMjgxIDAuNzAzMTEsMC43NTUyMiAxLjA1NDY4LDEuODE3NzIgMS4wNTQ2OCwzLjE4NzUgMCwwLjA4MzMgLTAuMDAzLDAuMjA4MzQgLTAuMDA4LDAuMzc1IGwgLTYuMTg3NSwwIGMgMC4wNTIxLDAuOTExNDYgMC4zMDk5LDEuNjA5MzggMC43NzM0NCwyLjA5Mzc1IDAuNDYzNTQsMC40ODQzOCAxLjA0MTY2LDAuNzI2NTcgMS43MzQzNywwLjcyNjU3IDAuNTE1NjIsMCAwLjk1NTczLC0wLjEzNTQyIDEuMzIwMzIsLTAuNDA2MjUgMC4zNjQ1NywtMC4yNzA4NCAwLjY1MzY0LC0wLjcwMzEzIDAuODY3MTgsLTEuMjk2ODggeiBtIC00LjYxNzE4LC0yLjI3MzQ0IDQuNjMyODEsMCBjIC0wLjA2MjUsLTAuNjk3OTEgLTAuMjM5NTksLTEuMjIxMzQgLTAuNTMxMjUsLTEuNTcwMzEgLTAuNDQ3OTIsLTAuNTQxNjYgLTEuMDI4NjUsLTAuODEyNDkgLTEuNzQyMTksLTAuODEyNSAtMC42NDU4MywxZS01IC0xLjE4ODgsMC4yMTYxNSAtMS42Mjg5LDAuNjQ4NDQgLTAuNDQwMTEsMC40MzIzIC0wLjY4MzYsMS4wMTA0MiAtMC43MzA0NywxLjczNDM3IHoiCiAgICAgICAgIHN0eWxlPSIiCiAgICAgICAgIGlkPSJwYXRoODU2OSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSAxNzIuMTc5NjksMjg0Ljg2OTE4IC0yLjUzOTA3LC04LjI5Njg4IDEuNDUzMTMsMCAxLjMyMDMxLDQuNzg5MDYgMC40OTIxOSwxLjc4MTI1IGMgMC4wMjA4LC0wLjA4ODUgMC4xNjQwNiwtMC42NTg4NSAwLjQyOTY5LC0xLjcxMDkzIGwgMS4zMjAzMSwtNC44NTkzOCAxLjQ0NTMxLDAgMS4yNDIxOSw0LjgxMjUgMC40MTQwNiwxLjU4NTk0IDAuNDc2NTYsLTEuNjAxNTYgMS40MjE4OCwtNC43OTY4OCAxLjM2NzE5LDAgLTIuNTkzNzUsOC4yOTY4OCAtMS40NjA5NCwwIC0xLjMyMDMxLC00Ljk2ODc1IC0wLjMyMDMyLC0xLjQxNDA3IC0xLjY3OTY4LDYuMzgyODIgeiIKICAgICAgICAgc3R5bGU9IiIKICAgICAgICAgaWQ9InBhdGg4NTcxIiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==);
    width: 28px; height: 28px; background-position: 0 0px;
}

#vadstena-engine-big-presentation {
    font-family: helvetica, arial, sans-serif;
    font-size: 14px;
    font-size: 2vmax;
    position:absolute;
    left:10%;
    top:10%;
    width:76%;
    height:76%;
    cursor: default;
    background-color: rgba(255,255,255,0.95);
    border-radius: 5px;
    border: solid 1px #ccc;
    text-align: center;
    z-index: 4;
    padding:2%;
    display: none;
}

#vadstena-engine-big-presentation-next-button {
    position: absolute;
    bottom: 4%;
    right: 5%;
    background-color: rgba(0,0,0,0.1);
    padding: 0.7% 1.1%;
    border-radius: 3px;
    /*box-shadow: 0 0 3px rgba(0,0,0,0.5);*/
    border: solid 1px rgba(0,0,0,0.5);
    cursor: pointer;
}

#vadstena-engine-big-presentation-next-button i {
    position: relative;
    top: 0.05em;
    margin-left: 0.1em;
}

#vadstena-engine-big-presentation-prev-button {
    position: absolute;
    bottom: 4%;
    left: 5%;
    background-color: rgba(0,0,0,0.1);
    padding: 0.7% 1.1%;
    border-radius: 3px;
    /*box-shadow: 0 0 3px rgba(0,0,0,0.5);*/
    border: solid 1px rgba(0,0,0,0.5);
    cursor: pointer;
}

#vadstena-engine-big-presentation-prev-button i {
    position: relative;
    top: 0.05em;
    margin-right: 0.1em;
}

#vadstena-engine-presentation {
    font-family: helvetica, arial, sans-serif;
    font-size: 14px;
    font-size: 2vmax;
    position:absolute;
    left:10%;
    bottom:5%;
    width:80%;
    cursor: default;
    background-color: rgba(255,255,255,0.95);
    border-radius: 5px;
    border: solid 1px #ccc;
    text-align: center;
    z-index: 4;
    display: none;
}

#vadstena-engine-presentation-next-button {
    position: absolute;
    right: 2%;
    top: 25%;
    font-size: 5vmax;
    /*text-shadow: 1px 1px 6px #777;*/
    cursor: pointer;
}

#vadstena-engine-presentation-texts {
    padding-left: 5%;
    padding-right: 5%;
    margin: 2.2%;
    line-height: 140%;
}

#vadstena-engine-presentation-texts a {
    cursor: pointer;
    color: #002266;
    border-bottom: dotted 2px #003399;
}


#vadstena-engine-presentation-prev-button {
    position: absolute;
    left: 2%;
    top: 25%;
    font-size: 5vmax;
    /*text-shadow: 1px 1px 6px #777;*/
    cursor: pointer;
}

#vadstena-engine-blank-presentation {
  font-family: helvetica, arial, sans-serif;
  font-size: 14px;
  font-size: 2vmax;
  position: absolute;
  bottom: 5%;
  width: 100%;
  cursor: default;
  text-align: center;
  z-index: 4;
  display: none;
}

#vadstena-engine-tools-close {
    display: inline-block;
    position: relative;
    top: -6px;
    right: -4px;
    float: right;
    cursor: pointer;
}

#vadstena-engine-tools-button {
    position: absolute;
    right: 10px;
    top: 10px;
    cursor: pointer;
    border-radius: 3px;
    width: 34px;
    float: right;
    background-color: rgba(255,255,255,0.95);
    padding: 4px;
    z-index: 4;
    display:none;
}

#vadstena-engine-canvas-2d {
    cursor: none;
    position: absolute;
    top:0px;
    left:0px;
    width:100%;
    height:100%;
    z-index:3;
    display:none;
}

#vadstena-engine-canvas2-2d {
    position: absolute;
    top:0px;
    left:0px;
    width:100%;
    height:100%;
    z-index:3;
    display:none;
}

#vadstena-engine-canvas-3d {
    width:100%;
    height:100%;
}

#vadstena-engine-gallery {
    position: absolute;
    top:0px;
    left:0px;
    width:100%;
    height:100%;
}

#vadstena-engine-logo {
    font-family: Verdana, Tahoma, Geneva, Arial, Sans-serif;
    font-size:11px;
    position:fixed;right:5px;bottom:5px;
    color:#fff;
    text-shadow: 0 0 2px #000;
}

#vadstena-engine-credits {
    position:absolute;
    left:3px;
    top:3px;
    z-index: 4;
}

#vadstena-engine-credits ul {
    padding: 7px 0px;
    margin: 0px;
    text-align: left;
}

#vadstena-engine-credits ul li {
    color: #FFFFFF;
    font-family: Verdana, Tahoma, Geneva, Arial, Sans-serif;
    font-size: 11px;
    display: inline;
    list-style-type: none;
    padding-right: 10px;
    padding-left: 10px;
    border-right: 1px solid rgba(255,255,255,0.3);
    padding-top: 2px;
    padding-bottom: 2px;
    text-shadow: 0 0 2px #000;
}

#vadstena-engine-credits a {
    color: #FFFFFF;
    text-decoration: none;
}

#vadstena-engine-stats-graphs {
    position:absolute;
    left:10px;
    top:30px;
    z-index: 4;
    background-color: #FFFFFF;
    padding: 5px;
    border-radius: 4px;
    font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
    color:#000000;
    text-align: left;
    font-size: 12px;
    display:none;
}

.vadstena-engine-stats-canvas {
    border: solid 1px #bbb;
    image-rendering : pixelated;
}

.vadstena-engine-stats-info {
    padding: 5px 2px;
    font-size: 10px;
}

.vadstena-engine-stats-button {
    padding: 2px 5px;
    display:inline-block;
    margin-right: 4px;
    border-radius: 4px;
    cursor:pointer;
}

.vadstena-engine-stats-button:hover {
    box-shadow: 0 0 1px #0066ff;
}

#vadstena-engine-plus {
    position:absolute;
    left:23px;
    bottom:20px;
    cursor: pointer;
    z-index: 4;
}

#vadstena-engine-minus {
    position:absolute;
    left:70px;
    bottom:20px;
    cursor: pointer;
    z-index: 4;
}

#vadstena-engine-compass-main {
    position:absolute;
    left:21px;
    bottom:64px;
    cursor: move;
    overflow: hidden;

    width: 99px;
    height: 99px;
    z-index: 50;
}

#vadstena-engine-compass-frame {
    position:absolute;
    right:0px;
    bottom:2px;
    width: 99px;
    height: 99px;
    z-index: 10;
    -webkit-perspective:200px;
    perspective:200px;
    pointer-events:none;
}

#vadstena-engine-compass {
    z-index: 0;
    max-width:120px;
    max-height:120px;
}

#vadstena-engine-compass-frame2 {
    position:absolute;
    right:0px;
    bottom:1px;
    width: 99px;
    height: 99px;
    z-index: 11;
    -webkit-perspective:200px;
    perspective:200px;
    pointer-events:none;
    opacity: 0.25;
}

#vadstena-engine-compass-frame3 {
    position:absolute;
    right:0px;
    bottom:0px;
    width: 99px;
    height: 99px;
    z-index: 12;
    -webkit-perspective:200px;
    perspective:200px;
    pointer-events:none;
    opacity: 0.25;
}


#vadstena-engine-toolbar {
    position: absolute;
    bottom: 0px;
    left: 50%;
}


#vadstena-engine-toolbar-bottons {
    background-color: rgba(255, 255, 255, 0.95);
    display: inline-block;
    padding: 5px 5px;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    z-index: 4;
    position: relative;
    left: -50%;
}

#vadstena-engine-toolbar-bottons div {
    margin: 5px;
}

#vadstena-engine-toolbar-break {
    width: 1px; height: 28px; background-color: #CCCCCC; display: inline-block;
}

#vadstena-engine-toolbar-break2 {
    width: 1px; height: 28px; background-color: #CCCCCC; display: inline-block;
}

#vadstena-engine-toolbar-view {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAADBklEQVRYw+3XwW8VVRTH8c8UEyWY4EY3SqIuibjwLWQlMbgg0b9BIsSrJdJqN0XWQjdi0sZSPRgU/gMXJiw0wMZQk9lYo+4wqW50RUKUmOK4ePc93rzOq9PXEI15v+W9Z85vzsw9Z+bLRBP911W0CUopPYAX8BKewaN56zd8hy9xPSLu7sgwpbQbJzGDx/EXfspGsvGTmMLPWMRyRPyxbcOU0mF8khN+hQu4EhG3huL24ghex2HcxLGIuNbKMKVUYB7v4XvMRsTVvPcwXsXBHH4DlyPidt5/MVe5H/MRcW5Lw2z2ERI+w3RE3Ml7B/AF9g3lWMfLEbGW4x7CebyGZZyMiKoXvGvwyk6ns4w3sRARM2VZbuQke/B1gxnsxSudTudCWZZ/lmW5UZbl551O50HM4ZGyLK/0gqcGqpvDCaxExOmhpEdHmPW0L8f0lXOsYDal9EbNMKX0HBbwje6JHNZB/6znG9ZmsIrFlNKzgxX+jruoWiTekaZy+T/irXyXSw1xN1rkWm1YW8o5ZyPi28EKRcRF3cc6nVI6O3ThZd3TOErruDS4kFI6g2ksRcTHvfWmPvwA7+BTnBizLZZxTENbNE6alNI8zmhu/KPuHZBVXBrR+Kci4v3h3FuNtkO4iKdtf7Qd791ka8OcbLfuIJjDE7rD+yZ+zSGP4Snds/BLru7DsYb3kPEuHNL9PB1Q/zyt5SdwPSI22uSbaKKJJppoZ2o1vKWqFVuIYmdsIVVjsYUoxvg8paqRLURxayiukS1Eca2dYao2sYUorua9RrYQxe28X2MLUWzNFtmsxhaiuJP3tvyJEsVajtvEFqKoRhku6/7uL4ji9MD6Hvxg9O/+Ovb3K+1ecxbvYlEUb/eWpwYC+mxRM+tq22yRc6xgVqrqbCFV950tpOpfZAtR3He2EEWdLUTRZ4v8wge1bbaQqj5biGI0W0hVjS3GbIsaW4xui3umNbYYavxNbDGi8U+Joj1bSFUjW7Qcbcf7N9nasJtsLLYYb3jXjVuxhSgmbDHR/0B/A4VuaqgKMKNFAAAAAElFTkSuQmCC);
    width: 28px; height: 28px; background-position: 0 0px; display: inline-block; cursor: pointer;
}

#vadstena-engine-toolbar-view.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-length {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAADy0lEQVRYw+2XTWhdRRTHf/c9QfCjaKAlusnCj4WWCj1VsYsKClEiiqBWqlKLi4NIWxNd1C5rBQ2CBXVRDqhpI9Vis1CDH0UQP8CqjCCWSndBUakbKUQxfo2Lmbx37829LzfvTRXEWd533vz4nzlz5vzhv77aVR9VdaOIfCQi3zrnvk4JbFXBgLeAb4BXVPWOM6YwB5sG7gbmgf0iciKV0o7CEmwnsMbM9gG7Uipt1cDWAxMAqaFtVR0CPgNmAY2wzcBu5xwAzrljIpIkvS3gpwgbBe6LsMeAi/OBqZS2nXOIyOvAOmB3TOkocIlz7st8cAql7biRj9DLgSeBE8DzIrJXRI45535PBW3nNlqEXgncA1wKHAS+F5H1zrkfVHVYRDaZ2XS/0MI9zEHXAbcAL8dz+0REzgIeB8w591u/Spe0thL0WWAfcBLYAzxqZvODpLeyl+aglxGKaAQYB9aKyIXOuR/7hbbrfigpvRn4DrgOeFVERpxzp/uBtuixzOxP4H7gKLAfOAw8CFydj1PVVU3vabZczuOGbeAAcBuw18yeVtVxQhWfH0HbzewvVZ0AJoEtZjbTOKU16b0C2Coiq4EvgNOErjRhZn80SW+rCbAivQ/Ez7sIxbS6FFub3sbAEvQd4A3gReBeYFNFbCV0RcAS9BDwHnARcFhVJ1X17FL4C4TJ4aG+gTnoNuBN4GFCBR8EvKpugFC5hDd2gdAqgYZVWrdi9U4BNwFjwFbgOeAU8DZwAXCDmZ0aSGGF0neBT4H3e8EGVlijdA44twqWDJiDvkQYUW6sgv2//sGlfiPq51CfdMyHqmuhvuAtUkOLwC5sGrie2AtTQrvAImwnsAbLOg04FbRVA+t4i9TQFuqHImw2B9tMmMJJDW3sLVJBs5jSxZnlLuAa4Cogw7IDS/6hvjOzYNlMY1JOIVi2+Ki+BnxAmEOnUf8E6s9JqbSV22gROgvsIDyqM8AC6iWqG0b92CDQ4j3sQo8Ct8evzwC/oH6Y4C0+HETp0k5ThH4OfEworD3AI1g2n4tdMbT+PewW0ijh2mwH1gI/Y9lXpdjGhVQ/YhSVjgF3ArcCx1E/UoptrLT3TFOE1noL1K9qCl1+iOpCjxDO8zwsO4L6cdQPRbVPob7VBNp8pime6RThvh4ndKVxLFvIxdaeafMxsZjent6il9KVT21dpVuAawmG9VcsO1QRu0TpygfhrtKCt0D9JOrPjLeI0G1UeAvUb4jq0nuLmN4plvEWWJbGW+SU1nqLPGxwhdVK54jeogxLB+xCO96iCvavrL8B+TYqHX3cmUMAAAAASUVORK5CYII=);
    width: 28px; height: 28px; background-position: 0 0px; display: inline-block; cursor: pointer;
}

#vadstena-engine-toolbar-length.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-distance {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAAB8UlEQVRYw+2XPU8bQRCGnzMtrQmV+whRXR+J9FCGHwCaJoiKLrW7VHw0I/kHUDpJbQt6lxE9FQllRL0UvsDKXt/O7p0RsvyW5xk/N3u7s/PCqmsjJ0lE+mVZDsuy3JxMJqOU3E7mi54Bm8BpamIu8DvwBJynJhbWQBHpAgPgRFXvvee7wCXwRVX/tFJhBRsD+9Wf+7oEPgFjEfnQGOjBdoDfwNFMyCFwB3y0QGuXNADbU9XHQNw2MKqgd1VccHk7NbAtCwxAVR+Az5ZKOzWwkQUWgW5bKxykwGqg11bgV+BXCiwAvQVOZn9/2TQi0mfaOc5V9VsKJEV+hdntKheY3a5SFDyHItIDLoDj1G+YUqGvK+CA6dbuvgXwiOmR2GkburC15Rz+RsBlQaP3YdvQ6PWkqn+Zdo7/33TQpELTBexBfxJoVykyjxi+mrTB1Z/a1nonEtdH3D/E9VNT17v0VeK6iPuBuN7M813E3SAuOubbKxRn8hYWaBz4CjN5ixi0vpfOw/bQ4jEQN+ct0CLNWyBuywQD0GJuzF9UaacGNjLB6qF53iIKWwxN9xZm2Dw06C38ZcxuVylafW8Rlrge4obVOVxahb5evEXbUJO3aBO6uLXlHP5GwCVB44Nwy9D49aTF23sLD9rYW+RpPbW9Jz0D92oLFy0I4qkAAAAASUVORK5CYII=);
    width: 28px; height: 28px; background-position: 0 0px; display: inline-block; cursor: pointer;
}

#vadstena-engine-toolbar-distance.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-position {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAADeklEQVRYw+2XvY9VRRjGf2NQaXRjbdzVSiAkFkLQ0oqNi4loIq0f5KGTAgMJGBuzklVJkNj4yP4BbqEmqKGzk0RjJS50yEeA2IAfhajJWMzcyz3nnnvO7N17iVHe5uaeec/7zDtn5p33B/91C10Oku4HngGeB54G5oAZ4BfgInAG+Bz42vatsQUlbQBeBd4CzgGf5uA/ATeAh4BH8yReALYC7wEf2v5zTYKSHgdWgEvAIdurtfFoO9SebQGWgFlgj+3zRWssabuka5L2tfjEljFJui5pR9P4PTXnTcCXwCu2PyqaYc1sG3gZOJXjNQtKuhf4BDhi+/Q4YgOip4HDwEqO25jhfuCy7Y8LAnbubtsnSbt4/5CgpI3AAeDQejJrsIPAgRy/kuEu4KztHyepZvsc8APwXF1wgXTOpmGfAc/WBZ8EvpmS4BlgW+/Phvw7S/rAnSZpEXgdOGH7SMErF4BH6oIzwA1JFc8Ru/EN4L4sOiTYVhQGBX8F5mzfLJjx+6StfqJpsKHkzZBKZEXwMukW6BTMy1iylD17DLjS+9PbNN+Rqv407Cng27rgV8CLUxLcneNXBE8BWyVtnqRSjvdEjn9b0PYfwDHg3QlntwQcy/ErGQJ8AMxK2lsw81jg8xqpIzg++LwvaPsvYA/wjqT5dS7lTuAo8FKOOyyYRc+T6t7JkkxbMlsGFprajFE9zSyp6F4FDuaqX1nShgO+mbQHHgZ2224slV1d217gTWCV213bBVKLOEM61L2ubQvwNrBs++9RcUv60o2k+3KBdKvMAQ+SyuFF4HtSH/TF4G68a3fMOr8hisVsgcP4bIHi2GyBw9rYAsUKW+CwWhuPOITaswpb4FDGFihuR/EaivtafGLLmFC8juIOOk1xE4o/ozjf4Rc7xudznNFsgWKfLXBYF1vk9w8DKzlug2BmCxw62WLo+zX7jGYLFKfKFjl+JcNdwFkcJsoWOPwP2aInWMwWKC6i+BuKi4WCFbYIOUjzuWrajYq3SGzxOw4PNIy3xqqwBQ43C2bcyhYNJW99bIHDXbao22i2QHGibJHjDbMFDlNlixy/kiFktkCxu+Puup6STztb4NBni877sFuszxY5boNgEu2zRVGmozNbBhaa2oxRPU2FLXLVry7p8AGvsAUOa2OL3LWNxRY4jM8W+fIsYovB3fivsX8AdEF+n/MLnzQAAAAASUVORK5CYII=);
    width: 28px; height: 28px; background-position: 0 0px; display: inline-block; cursor: pointer;
}

#vadstena-engine-toolbar-position.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-stats {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAAAeElEQVRYw+2XMQ7AIAhFv03PyqG4rB26tOlCDTFK3tsc5MkPA0rVaZnFzKw/z+7+qX/M7nC68By9GIlvzQ5HXx6FoZGUG3P9SBEiRIgQ4YZC2J/UFVDWX7uPvPG3+EEgvkU7HHx5FIbmJjHm+pEiRIgQIcINhfW5ADlzHGsx8ngzAAAAAElFTkSuQmCC);
    width: 28px; height: 28px; background-position: 0 0px; display: none; cursor: pointer;
}

#vadstena-engine-toolbar-stats.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-streets {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4NzBBQzdEQTQzQjFFNDExQkEwMzhCNTMxQjVFNDdDQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTQxRjFDNkI4RTUxMUU0OTFDMTg1RDlGNTYzMkQ2OCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTQxRjFDNUI4RTUxMUU0OTFDMTg1RDlGNTYzMkQ2OCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0MkFFRjFFNEJCOEU0MTE4NkU5QkI2ODUwREZFNzY0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg3MEFDN0RBNDNCMUU0MTFCQTAzOEI1MzFCNUU0N0NDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yq2x0wAAAdhJREFUeNrsVyFMw0AU/SU1JAsGgSAVRSBGakcQcwiWgKzCY5A4xMQ8EoPCoCapQOCW0LBU0bA0iFZsEwhSgx/5K38lzbjdb5ceG/ui+c1d/rt799/d/9poNIIybQ1KNh0/zWazlG22Wi1Npx/btqFSqYz9brcL1WqVHbDX60GtVhv7vu+DaZqTsXa7ne4QDcFoQhAEYBgGG3AwGExioE8x+v2+ujNcfkD9twHXdQsHx8RBi+NYDNhoNAqD1ev1iR9FEXiep5hS3D6mssyqO50OC2QqpagfkfboPMgsy5IGRB0qo3QFWJ7wZUWdO0vzilrGlAp/Mc5wLjcN1xbmptGzKxHRgtlGvmiuFCBVVSIjWrI+xzSqvEnInLPhXhIYW1v6Ul9Nlp5cQym83p9D2ltcHAJsJq0F3D0DHO3xAz68ApzuJ77zAnCwk45dPWZkgWDWduJvrAPsbvEBn8I0hhumMd7eVyWGiufptnhrAc53FfLxOQPwsnhrAWc/qhB/mCSUWkpRN24ot+ob3oM/nVIUqUh7TqYqPGY8KqhDZZSuAP9Ob+H4BbM0r6ilaprhf8rSXJTO5abh2sLcNHp2JSJaMNvIF82VAqSqalaRNM3P1VssrSy+BBgA5ti+lZf7xt8AAAAASUVORK5CYII=);
    width: 28px; height: 28px; background-position: 0 0px; display: none; cursor: pointer;
}

#vadstena-engine-toolbar-streets.selected {
    background-position: 0 -28px;
}

#vadstena-engine-toolbar-link {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAA4CAYAAADuMJi0AAADDklEQVRYw+3XO4hdVRTG8d/OKD4KU6UaFBXURo04nSIGxkfEwiCksZABcVU+QhTsJMHOF4MW6vIBilU6BUXIGNAmTjEk+CDNIGghomJIUMcEx2Nx9lxn7tyZuZl7r1jcr9mcvfY+31n7rLXhz1hjXaDKIJsjouAZBHbiIxzIzF+HbhgRO/A6Hu0KncTdmflLr307tmk2gXdWmX2I1/AnbsFcROwaSobV7D08VKcOZ+ahGrsLH+ByfIU7MvPMoBnGKrNnV8wgM+ewD8u4Sft/Bz7Se+t4KjOf6w5m5lF8Wx9vHobhz3V8NyKmI+LWNelH7MG19fHr7s0XbcPwxfqiZRzF97i6mk1rC2gCp/B89+ZNi6YWyG5cgpOZuVTnn8Bs3f+ktv/24gVcVj9oOjN/6tswIq6qX7u7Tn2n/Sczq8yewg94v2YFJ3DPRn1YNjC7BsdWjgrntZV5JV6ucwfxtrbRV/7Zp9ifmac3SqT0MLsec/XlZ+uRfY778QoaHMzM2br+YtyI85n5jS1UuswmMY9JnMF9mXm8xk7U4z2AJcxn5pdbGXSruy2ermbL2LtiVrUfd+IvvKFHU/ej7ra4ro4/ZuYXqwOZuYjFiHi1nszkdgy7M5yv42REzHQvjojH/Fu1x4Zh+BJWMnsrIh5eZfa4tmjgMz2auh/1qtKd+Bi34W8cwaXaS5n2dtmXmX8MxbCaXlFNb+8KfYIHV26c7Wii1+TCwsK5qampI9iFG/C7tjIfycxz2zUba6yx/h8aiC1E05MtZBk+W4hmU7aQZXhsIZot2UI0w2GLaraGLWQ5VGPr2EKW4bJFxwyyjJYtZFnHFrKMji1EMy2aNWwhmj3+K7YQzWBsUQukwxayLNX5vthClv7ZQjQDscVGfVg2MBuILWTpny1E0xdbyDJb13fYQpYLYwvRrGMLWY7X2Dq2kGW4bNExazVatpBlDVvIsohF0YyGLUQzs251NKNlC9F02EI0o2EL0fTFFrIMjy1EsylbdG6cIRxpqyxntVfVm/gNp7W3ywODmI01Ev0Dp8k+8M7R85AAAAAASUVORK5CYII=);
    width: 28px; height: 28px; background-position: 0 0px; display: inline-block; cursor: pointer;
}

#vadstena-engine-toolbar-link.selected {
    background-position: 0 -28px;
}

#vadstena-engine-place-hover {
    position:absolute;
    left:0px;
    top:0px;
    width:20px;
    height:20px;
    display:none;
    cursor:pointer;
    /*background-color: #FF0000;*/
    z-index:3;
}

#vadstena-engine-place-panel {
    font-family: helvetica, arial, sans-serif;
    font-size: 12px;
    max-width: 250px;
    line-height: 170%;
    position:absolute;
    left:0px;
    top:0px;
    min-width:30px;
    min-height:15px;
    display:none;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 3px;
    padding: 10px;
    z-index:3;
    text-align: left;
}

#vadstena-engine-place-panel .infoTile {
    font-size: 14px;
    margin-bottom: 10px;
}

#vadstena-engine-place-panel .infoTile2 {
    font-size: 13px;
}

#vadstena-engine-place-panel .infoKey {
    float: left;
    font-weight:bold;
}

#vadstena-engine-place-panel .infoValue {
    float: left;
    width:100%;
    margin-left: 10px;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
}

#vadstena-engine-locations-panel {
    font-family: helvetica, arial, sans-serif;
    font-size: 12px;
    max-width: 250px;
    line-height: 170%;
    position:absolute;
    left:5px;
    top:27px;
    min-width:30px;
    min-height:15px;
    display:none;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 3px;
    padding: 10px;
    z-index:3;
    text-align: left;
}


#vadstena-engine-locations-panel ul {
    margin: 0px;
    padding: 0px;
    list-style-type: none;
}

#vadstena-engine-locations-panel li {
    cursor: pointer;
}

#vadstena-engine-locations-panel li:hover {
    text-decoration:underline;
}


#vadstena-engine-link-panel {
    /*position:fixed;*/
    right:20px;
    top:20px;
    /*background-color: rgba(250,250,250,0.95);*/
    z-index: 3;
    border-radius: 5px;
    padding: 15px;
    color: #000;
    display: none;
    width: 305px;
}

/*
#vadstena-engine-link-panel h3 {
    margin-top: 5px;
    margin-bottom: 10px;
}
*/

#vadstena-engine-link-panel-text {
    resize:none;
    font-size: 12px;
    margin-top: 5px;
    padding: 5px;
}

#vadstena-engine-link-panel-close {
    width: 20px;
    height: 20px;
    float: right;
    cursor: pointer;
    margin-top: -23px;
    margin-right: -22px;
}

#vadstena-engine-stats-panel {
    display: none;
    padding:15px;
    width: 305px;
}


#vadstena-engine-render-stats {
    margin-top: 5px;
}

#vadstena-engine-render-stats table {
    font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
    color:#000000;
    text-align: left;
    font-size: 12px;
}

#vadstena-engine-render-stats table td {
    vertical-align: top;
}

#vadstena-engine-gis-panel {
    font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
    /*position: absolute;*/
    left: 10px;
    top: 10px;
    width: 305px;
    /*background-color: rgba(250,250,250,0.95);*/
    z-index: 3;
    border-radius: 5px;
    padding: 15px;
    padding-bottom: 20px;
    color: #000;
    font-size: 12px;
    display: none;
}

/*
#vadstena-engine-gis-panel h3 {
    margin-top: 5px;
    margin-bottom: 20px;
}
*/

#vadstena-engine-gis-panel-texts {
    margin-bottom: 15px;
    margin-top: 7px;
    resize: none;
    font-size: 12px;
    padding: 5px;
}

/*
        #gisPanel img {
            box-shadow: 0 0 1px #777;
        }
*/


#vadstena-engine-gis-panel-coords-buttons {
}

#vadstena-engine-gis-panel h4 {
    font-size: 18px;
    text-align: left;
    margin-bottom: 13px;
}

#vadstena-engine-gis-panel p {
    font-size: 12px;
    text-align: left;
    margin-bottom: 5px;
    line-height: 150%;
}

#vadstena-engine-gis-panel .vadstena-engine-button {
    text-align: left;
    margin-right: 3px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #555555;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button:hover {
    box-shadow: 0 0 1px #0066FF;
}

#vadstena-engine-gis-panel .vadstena-engine-button-disabled {
    text-align: left;
    margin-right: 3px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: default;
    opacity: 0.3;
}

#vadstena-engine-gis-panel-coord-system {
    margin-top: 9px;
}

#vadstena-engine-gis-panel .vadstena-engine-button-pressed {
    text-align: left;
    margin-right: 3px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-radius: 4px;
    padding: 5px 10px;
    box-shadow: inset 0 1px 7px #707070;
}

#vadstena-engine-gis-panel .vadstena-engine-button-pressed:hover {
    box-shadow: inset 0 1px 7px #777, 0 0 1px #0066FF;
}

#vadstena-engine-gis-panel .vadstena-engine-button-pressed {
    text-align: left;
    margin-right: 3px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-radius: 4px;
    padding: 5px 10px;
    box-shadow: inset 0 1px 7px #707070;
}

#vadstena-engine-gis-panel .vadstena-engine-button-pressed:hover {
    box-shadow: inset 0 1px 7px #777, 0 0 1px #0066FF;
}


#vadstena-engine-gis-panel .vadstena-engine-button-left {
    text-align: left;
    margin-right: -1px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-left:hover {
    box-shadow: 0 0 1px #0066FF;
}

#vadstena-engine-gis-panel .vadstena-engine-button-midle {
    text-align: left;
    margin-right: -1px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    padding: 5px 10px;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-midle:hover {
}

#vadstena-engine-gis-panel .vadstena-engine-button-right {
    text-align: left;
    margin-right: 0px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-right:hover {
    box-shadow: 0 0 1px #0066FF;
}



#vadstena-engine-gis-panel .vadstena-engine-button-left-pressed {
    text-align: left;
    margin-right: -1px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
    padding: 5px 10px;
    color: #ffffff;
    background-color: #888;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-left-pressed:hover {
    box-shadow: 0 0 1px #0066FF;
}

#vadstena-engine-gis-panel .vadstena-engine-button-midle-pressed {
    text-align: left;
    margin-right: -1px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    padding: 5px 10px;
    color: #ffffff;
    background-color: #888;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-midle-pressed:hover {
    box-shadow: 0 0 1px #0066FF;
}

#vadstena-engine-gis-panel .vadstena-engine-button-right-pressed {
    text-align: left;
    margin-right: 0px;
    margin-bottom: 5px;
    line-height: 150%;
    border: solid 1px #333333;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    padding: 5px 10px;
    color: #ffffff;
    background-color: #888;
    cursor: pointer;
}

#vadstena-engine-gis-panel .vadstena-engine-button-right-pressed:hover {
    box-shadow: 0 0 1px #0066FF;
}



#vadstena-engine-info-panel {
    width: 305px;
    padding: 15px;
}

#vadstena-engine-info-panel-texts a {
    color: 0066ff;
    cursor: pointer;
}

#vadstena-engine-info-panel-texts a:hover {
    text-decoration:underline;
}

#vadstena-engine-info-panel-texts {
    font-size:13px;
}

#vadstena-engine-info-panel-up-button {
    text-align: center;
    padding-bottom: 15px;
    display: none;
}

#vadstena-engine-info-panel-up-button img {
    cursor: pointer;
}

#vadstena-engine-info-panel-down-button {
    text-align: center;
    display: none;
}

#vadstena-engine-info-panel-down-button img {
    cursor: pointer;
}

#vadstena-engine-info-panel h3, #vadstena-engine-gis-panel h3, #vadstena-engine-stats-panel h3, #vadstena-engine-link-panel h3 {
    margin-top: 0px;
    font-size: 18px;
    margin-bottom: 15px;
}

#vadstena-engine-info-panel h3 span, #vadstena-engine-gis-panel h3 span, #vadstena-engine-stats-panel h3 span, #vadstena-engine-link-panel h3 span {
    /*
    position: relative;
    top: -13px;
    left: 6px;
    */
}

#vadstena-engine-info-panel-texts {
    margin-top: 10px;
    margin-bottom: 30px;
}

.vadstena-engine-small-break {
    height : 12px;
}

/*
#vadstena-engine-info-panel-like:before {
    margin-top: 10px;
}*/

#vadstena-engine-info-panel-like {
    position: absolute;
    bottom: 19px;
}

.vadstena-engine-info-panel-buttons {
    text-align: right;
    top: 0px;
    margin-bottom: 15px;
    position: relative;
    width: 200px;
    float: right;
}

.vadstena-engine-info-panel-button {
    padding: 2px 10px;
    margin-left: 5px;
    cursor: pointer;
    border-radius: 5px;
    display: inline-block;
}

.vadstena-engine-info-panel-button:hover {
    box-shadow: 0 0 1px #0066ff;
}

.vadstena-engine-info-panel-button img {
    position: relative;
    top: 5px;
    margin-top: -10px;
}

#vadstena-engine-gallery {
    /*display: none;*/
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    user-select: none;
}

#vadstena-engine-gallery table {
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0px;
    left: 0px;
}

#vadstena-engine-gallery table img {
    left: 0px;
    top: 0px;
    width: 100%;
    height: inherit;
}

#vadstena-engine-link-panel-autorotate {
    margin-top: 5px;
}

.vadstena-engine-checkbox {
    background: no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAeCAYAAAAhDE4sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4RDFBRTI3OTM1MzRFNDExQTlBNUU4MDJCQjhEQjZEQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFQjRFRTZCRDM0MzcxMUU0QkJCRDkwNDI5RkQyRjFFMiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFQjRFRTZCQzM0MzcxMUU0QkJCRDkwNDI5RkQyRjFFMiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjhEMUFFMjc5MzUzNEU0MTFBOUE1RTgwMkJCOERCNkRDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjhEMUFFMjc5MzUzNEU0MTFBOUE1RTgwMkJCOERCNkRDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+XgsKsQAAAadJREFUeNrMlTsvRFEQx+/ZXbtoPLbbhhVqEiUaKl9A7VEIhaASjW8gIUKioZFVeXQqOjqh0foCHiEW3fGfZM5mdvaes8vewiS/vZv7+N85M/8511hroyQiFSUUGfoxxtAhD6bAJGih08Dy0UUZHIEL8OlO0qoy/L8VLHGGy+Db8+IOsApyoFR1hWtUAIegv4FVjIEd0CU1ZI2+ZLqBMHG1TazYUqhRH9iQ0G/NZFQ3K0I1F+qI2KQyqnkmpTphmi12mZkA7YH7u8EIeACvcYaM2IwlTtnHE9jgcarWSGL6tbObn34OOf1Z1RXXchqjTXAL2sBz5QZKC9sITfM6F/8gMP05nscZMA9mwZWsUYEF6k0/bSNrovj7tBIttMtHX3QqkVPQq7smhQbAOZgTntIiJ6AY134S2AN9vGnRyTcWy8dkUvT5SGY0BG74oXdwqTKhl/WAdCgjV6NBcK1c7TIZBls8LrGGlL65B4ucGcUZb/qPXLdsyJBptWPegQUwDbZZxLtLugfJZB9gnB0rM1sRIrScUZ7+F9/0U9uP/zr95t99+38EGAC9/LBoH3Dt5QAAAABJRU5ErkJggg==);
    width: 18px; height: 15px; background-position: 0 0px; display: inline-block; cursor: pointer;
    position: relative;
    top: 1px;
    margin-right: 3px;
}

.vadstena-engine-checkbox.selected {
    background-position: 0 -14px;
}



    </style>
    <script type="text/javascript">var VadstenaEngineType_ = "webexport";</script>
    <script type="text/javascript">





!function(a){if("object"==typeof exports)module.exports=a();else if("function"==typeof define&&define.amd)define(a);else{var b;"undefined"!=typeof window?b=window:"undefined"!=typeof global?b=global:"undefined"!=typeof self&&(b=self),b.proj4=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b){function Point(a,b,c){if(!(this instanceof Point))return new Point(a,b,c);if(Array.isArray(a))this.x=a[0],this.y=a[1],this.z=a[2]||0;else if("object"==typeof a)this.x=a.x,this.y=a.y,this.z=a.z||0;else if("string"==typeof a&&"undefined"==typeof b){var d=a.split(",");this.x=parseFloat(d[0],10),this.y=parseFloat(d[1],10),this.z=parseFloat(d[2],10)||0}else this.x=a,this.y=b,this.z=c||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}var c=a("mgrs");Point.fromMGRS=function(a){return new Point(c.toPoint(a))},Point.prototype.toMGRS=function(a){return c.forward([this.x,this.y],a)},b.exports=Point},{mgrs:66}],2:[function(a,b){function Projection(a,b){if(!(this instanceof Projection))return new Projection(a);b=b||function(a){if(a)throw a};var e=c(a);if("object"!=typeof e)return void b(a);var g=f(e),h=Projection.projections.get(g.projName);h?(d(this,g),d(this,h),this.init(),b(null,this)):b(a)}var c=a("./parseCode"),d=a("./extend"),e=a("./projections"),f=a("./deriveConstants");Projection.projections=e,Projection.projections.start(),b.exports=Projection},{"./deriveConstants":32,"./extend":33,"./parseCode":36,"./projections":38}],3:[function(a,b){b.exports=function(a,b,c){var d,e,f,g=c.x,h=c.y,i=c.z||0;for(f=0;3>f;f++)if(!b||2!==f||void 0!==c.z)switch(0===f?(d=g,e="x"):1===f?(d=h,e="y"):(d=i,e="z"),a.axis[f]){case"e":c[e]=d;break;case"w":c[e]=-d;break;case"n":c[e]=d;break;case"s":c[e]=-d;break;case"u":void 0!==c[e]&&(c.z=d);break;case"d":void 0!==c[e]&&(c.z=-d);break;default:return null}return c}},{}],4:[function(a,b){var c=Math.PI/2,d=a("./sign");b.exports=function(a){return Math.abs(a)<c?a:a-d(a)*Math.PI}},{"./sign":21}],5:[function(a,b){var c=2*Math.PI,d=3.14159265359,e=a("./sign");b.exports=function(a){return Math.abs(a)<=d?a:a-e(a)*c}},{"./sign":21}],6:[function(a,b){b.exports=function(a){return Math.abs(a)>1&&(a=a>1?1:-1),Math.asin(a)}},{}],7:[function(a,b){b.exports=function(a){return 1-.25*a*(1+a/16*(3+1.25*a))}},{}],8:[function(a,b){b.exports=function(a){return.375*a*(1+.25*a*(1+.46875*a))}},{}],9:[function(a,b){b.exports=function(a){return.05859375*a*a*(1+.75*a)}},{}],10:[function(a,b){b.exports=function(a){return a*a*a*(35/3072)}},{}],11:[function(a,b){b.exports=function(a,b,c){var d=b*c;return a/Math.sqrt(1-d*d)}},{}],12:[function(a,b){b.exports=function(a,b,c,d,e){var f,g;f=a/b;for(var h=0;15>h;h++)if(g=(a-(b*f-c*Math.sin(2*f)+d*Math.sin(4*f)-e*Math.sin(6*f)))/(b-2*c*Math.cos(2*f)+4*d*Math.cos(4*f)-6*e*Math.cos(6*f)),f+=g,Math.abs(g)<=1e-10)return f;return 0/0}},{}],13:[function(a,b){var c=Math.PI/2;b.exports=function(a,b){var d=1-(1-a*a)/(2*a)*Math.log((1-a)/(1+a));if(Math.abs(Math.abs(b)-d)<1e-6)return 0>b?-1*c:c;for(var e,f,g,h,i=Math.asin(.5*b),j=0;30>j;j++)if(f=Math.sin(i),g=Math.cos(i),h=a*f,e=Math.pow(1-h*h,2)/(2*g)*(b/(1-a*a)-f/(1-h*h)+.5/a*Math.log((1-h)/(1+h))),i+=e,Math.abs(e)<=1e-10)return i;return 0/0}},{}],14:[function(a,b){b.exports=function(a,b,c,d,e){return a*e-b*Math.sin(2*e)+c*Math.sin(4*e)-d*Math.sin(6*e)}},{}],15:[function(a,b){b.exports=function(a,b,c){var d=a*b;return c/Math.sqrt(1-d*d)}},{}],16:[function(a,b){var c=Math.PI/2;b.exports=function(a,b){for(var d,e,f=.5*a,g=c-2*Math.atan(b),h=0;15>=h;h++)if(d=a*Math.sin(g),e=c-2*Math.atan(b*Math.pow((1-d)/(1+d),f))-g,g+=e,Math.abs(e)<=1e-10)return g;return-9999}},{}],17:[function(a,b){var c=1,d=.25,e=.046875,f=.01953125,g=.01068115234375,h=.75,i=.46875,j=.013020833333333334,k=.007120768229166667,l=.3645833333333333,m=.005696614583333333,n=.3076171875;b.exports=function(a){var b=[];b[0]=c-a*(d+a*(e+a*(f+a*g))),b[1]=a*(h-a*(e+a*(f+a*g)));var o=a*a;return b[2]=o*(i-a*(j+a*k)),o*=a,b[3]=o*(l-a*m),b[4]=o*a*n,b}},{}],18:[function(a,b){var c=a("./pj_mlfn"),d=1e-10,e=20;b.exports=function(a,b,f){for(var g=1/(1-b),h=a,i=e;i;--i){var j=Math.sin(h),k=1-b*j*j;if(k=(c(h,j,Math.cos(h),f)-a)*k*Math.sqrt(k)*g,h-=k,Math.abs(k)<d)return h}return h}},{"./pj_mlfn":19}],19:[function(a,b){b.exports=function(a,b,c,d){return c*=b,b*=b,d[0]*a-c*(d[1]+b*(d[2]+b*(d[3]+b*d[4])))}},{}],20:[function(a,b){b.exports=function(a,b){var c;return a>1e-7?(c=a*b,(1-a*a)*(b/(1-c*c)-.5/a*Math.log((1-c)/(1+c)))):2*b}},{}],21:[function(a,b){b.exports=function(a){return 0>a?-1:1}},{}],22:[function(a,b){b.exports=function(a,b){return Math.pow((1-a)/(1+a),b)}},{}],23:[function(a,b){b.exports=function(a){var b={x:a[0],y:a[1]};return a.length>2&&(b.z=a[2]),a.length>3&&(b.m=a[3]),b}},{}],24:[function(a,b){var c=Math.PI/2;b.exports=function(a,b,d){var e=a*d,f=.5*a;return e=Math.pow((1-e)/(1+e),f),Math.tan(.5*(c-b))/e}},{}],25:[function(a,b,c){c.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},c.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},c.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},c.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},c.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},c.potsdam={towgs84:"606.0,23.0,413.0",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},c.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},c.hermannskogel={towgs84:"653.0,-212.0,449.0",ellipse:"bessel",datumName:"Hermannskogel"},c.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},c.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},c.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},c.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},c.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},c.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},c.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},c.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"}},{}],26:[function(a,b,c){c.MERIT={a:6378137,rf:298.257,ellipseName:"MERIT 1983"},c.SGS85={a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},c.GRS80={a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},c.IAU76={a:6378140,rf:298.257,ellipseName:"IAU 1976"},c.airy={a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},c.APL4={a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},c.NWL9D={a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},c.mod_airy={a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},c.andrae={a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},c.aust_SA={a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},c.GRS67={a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},c.bessel={a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},c.bess_nam={a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},c.clrk66={a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},c.clrk80={a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},c.clrk58={a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},c.CPM={a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},c.delmbr={a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},c.engelis={a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},c.evrst30={a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},c.evrst48={a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},c.evrst56={a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},c.evrst69={a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},c.evrstSS={a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},c.fschr60={a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},c.fschr60m={a:6378155,rf:298.3,ellipseName:"Fischer 1960"},c.fschr68={a:6378150,rf:298.3,ellipseName:"Fischer 1968"},c.helmert={a:6378200,rf:298.3,ellipseName:"Helmert 1906"},c.hough={a:6378270,rf:297,ellipseName:"Hough"},c.intl={a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},c.kaula={a:6378163,rf:298.24,ellipseName:"Kaula 1961"},c.lerch={a:6378139,rf:298.257,ellipseName:"Lerch 1979"},c.mprts={a:6397300,rf:191,ellipseName:"Maupertius 1738"},c.new_intl={a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},c.plessis={a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},c.krass={a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},c.SEasia={a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},c.walbeck={a:6376896,b:6355834.8467,ellipseName:"Walbeck"},c.WGS60={a:6378165,rf:298.3,ellipseName:"WGS 60"},c.WGS66={a:6378145,rf:298.25,ellipseName:"WGS 66"},c.WGS7={a:6378135,rf:298.26,ellipseName:"WGS 72"},c.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"},c.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"}},{}],27:[function(a,b,c){c.greenwich=0,c.lisbon=-9.131906111111,c.paris=2.337229166667,c.bogota=-74.080916666667,c.madrid=-3.687938888889,c.rome=12.452333333333,c.bern=7.439583333333,c.jakarta=106.807719444444,c.ferro=-17.666666666667,c.brussels=4.367975,c.stockholm=18.058277777778,c.athens=23.7163375,c.oslo=10.722916666667},{}],28:[function(a,b){function c(a,b,c){var d;return Array.isArray(c)?(d=f(a,b,c),3===c.length?[d.x,d.y,d.z]:[d.x,d.y]):f(a,b,c)}function d(a){return a instanceof e?a:a.oProj?a.oProj:e(a)}function proj4(a,b,e){a=d(a);var f,h=!1;return"undefined"==typeof b?(b=a,a=g,h=!0):("undefined"!=typeof b.x||Array.isArray(b))&&(e=b,b=a,a=g,h=!0),b=d(b),e?c(a,b,e):(f={forward:function(d){return c(a,b,d)},inverse:function(d){return c(b,a,d)}},h&&(f.oProj=b),f)}var e=a("./Proj"),f=a("./transform"),g=e("WGS84");b.exports=proj4},{"./Proj":2,"./transform":64}],29:[function(a,b){var c=Math.PI/2,d=1,e=2,f=3,g=4,h=5,i=484813681109536e-20,j=1.0026,k=.3826834323650898,l=function(a){if(!(this instanceof l))return new l(a);if(this.datum_type=g,a){if(a.datumCode&&"none"===a.datumCode&&(this.datum_type=h),a.datum_params){for(var b=0;b<a.datum_params.length;b++)a.datum_params[b]=parseFloat(a.datum_params[b]);(0!==a.datum_params[0]||0!==a.datum_params[1]||0!==a.datum_params[2])&&(this.datum_type=d),a.datum_params.length>3&&(0!==a.datum_params[3]||0!==a.datum_params[4]||0!==a.datum_params[5]||0!==a.datum_params[6])&&(this.datum_type=e,a.datum_params[3]*=i,a.datum_params[4]*=i,a.datum_params[5]*=i,a.datum_params[6]=a.datum_params[6]/1e6+1)}this.datum_type=a.grids?f:this.datum_type,this.a=a.a,this.b=a.b,this.es=a.es,this.ep2=a.ep2,this.datum_params=a.datum_params,this.datum_type===f&&(this.grids=a.grids)}};l.prototype={compare_datums:function(a){return this.datum_type!==a.datum_type?!1:this.a!==a.a||Math.abs(this.es-a.es)>5e-11?!1:this.datum_type===d?this.datum_params[0]===a.datum_params[0]&&this.datum_params[1]===a.datum_params[1]&&this.datum_params[2]===a.datum_params[2]:this.datum_type===e?this.datum_params[0]===a.datum_params[0]&&this.datum_params[1]===a.datum_params[1]&&this.datum_params[2]===a.datum_params[2]&&this.datum_params[3]===a.datum_params[3]&&this.datum_params[4]===a.datum_params[4]&&this.datum_params[5]===a.datum_params[5]&&this.datum_params[6]===a.datum_params[6]:this.datum_type===f||a.datum_type===f?this.nadgrids===a.nadgrids:!0},geodetic_to_geocentric:function(a){var b,d,e,f,g,h,i,j=a.x,k=a.y,l=a.z?a.z:0,m=0;if(-c>k&&k>-1.001*c)k=-c;else if(k>c&&1.001*c>k)k=c;else if(-c>k||k>c)return null;return j>Math.PI&&(j-=2*Math.PI),g=Math.sin(k),i=Math.cos(k),h=g*g,f=this.a/Math.sqrt(1-this.es*h),b=(f+l)*i*Math.cos(j),d=(f+l)*i*Math.sin(j),e=(f*(1-this.es)+l)*g,a.x=b,a.y=d,a.z=e,m},geocentric_to_geodetic:function(a){var b,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t=1e-12,u=t*t,v=30,w=a.x,x=a.y,y=a.z?a.z:0;if(o=!1,b=Math.sqrt(w*w+x*x),d=Math.sqrt(w*w+x*x+y*y),b/this.a<t){if(o=!0,q=0,d/this.a<t)return r=c,void(s=-this.b)}else q=Math.atan2(x,w);e=y/d,f=b/d,g=1/Math.sqrt(1-this.es*(2-this.es)*f*f),j=f*(1-this.es)*g,k=e*g,p=0;do p++,i=this.a/Math.sqrt(1-this.es*k*k),s=b*j+y*k-i*(1-this.es*k*k),h=this.es*i/(i+s),g=1/Math.sqrt(1-h*(2-h)*f*f),l=f*(1-h)*g,m=e*g,n=m*j-l*k,j=l,k=m;while(n*n>u&&v>p);return r=Math.atan(m/Math.abs(l)),a.x=q,a.y=r,a.z=s,a},geocentric_to_geodetic_noniter:function(a){var b,d,e,f,g,h,i,l,m,n,o,p,q,r,s,t,u,v=a.x,w=a.y,x=a.z?a.z:0;if(v=parseFloat(v),w=parseFloat(w),x=parseFloat(x),u=!1,0!==v)b=Math.atan2(w,v);else if(w>0)b=c;else if(0>w)b=-c;else if(u=!0,b=0,x>0)d=c;else{if(!(0>x))return d=c,void(e=-this.b);d=-c}return g=v*v+w*w,f=Math.sqrt(g),h=x*j,l=Math.sqrt(h*h+g),n=h/l,p=f/l,o=n*n*n,i=x+this.b*this.ep2*o,t=f-this.a*this.es*p*p*p,m=Math.sqrt(i*i+t*t),q=i/m,r=t/m,s=this.a/Math.sqrt(1-this.es*q*q),e=r>=k?f/r-s:-k>=r?f/-r-s:x/q+s*(this.es-1),u===!1&&(d=Math.atan(q/r)),a.x=b,a.y=d,a.z=e,a},geocentric_to_wgs84:function(a){if(this.datum_type===d)a.x+=this.datum_params[0],a.y+=this.datum_params[1],a.z+=this.datum_params[2];else if(this.datum_type===e){var b=this.datum_params[0],c=this.datum_params[1],f=this.datum_params[2],g=this.datum_params[3],h=this.datum_params[4],i=this.datum_params[5],j=this.datum_params[6],k=j*(a.x-i*a.y+h*a.z)+b,l=j*(i*a.x+a.y-g*a.z)+c,m=j*(-h*a.x+g*a.y+a.z)+f;a.x=k,a.y=l,a.z=m}},geocentric_from_wgs84:function(a){if(this.datum_type===d)a.x-=this.datum_params[0],a.y-=this.datum_params[1],a.z-=this.datum_params[2];else if(this.datum_type===e){var b=this.datum_params[0],c=this.datum_params[1],f=this.datum_params[2],g=this.datum_params[3],h=this.datum_params[4],i=this.datum_params[5],j=this.datum_params[6],k=(a.x-b)/j,l=(a.y-c)/j,m=(a.z-f)/j;a.x=k+i*l-h*m,a.y=-i*k+l+g*m,a.z=h*k-g*l+m}}},b.exports=l},{}],30:[function(a,b){var c=1,d=2,e=3,f=5,g=6378137,h=.006694379990141316;b.exports=function(a,b,i){function j(a){return a===c||a===d}var k,l,m;if(a.compare_datums(b))return i;if(a.datum_type===f||b.datum_type===f)return i;var n=a.a,o=a.es,p=b.a,q=b.es,r=a.datum_type;if(r===e)if(0===this.apply_gridshift(a,0,i))a.a=g,a.es=h;else{if(!a.datum_params)return a.a=n,a.es=a.es,i;for(k=1,l=0,m=a.datum_params.length;m>l;l++)k*=a.datum_params[l];if(0===k)return a.a=n,a.es=a.es,i;r=a.datum_params.length>3?d:c}return b.datum_type===e&&(b.a=g,b.es=h),(a.es!==b.es||a.a!==b.a||j(r)||j(b.datum_type))&&(a.geodetic_to_geocentric(i),j(a.datum_type)&&a.geocentric_to_wgs84(i),j(b.datum_type)&&b.geocentric_from_wgs84(i),b.geocentric_to_geodetic(i)),b.datum_type===e&&this.apply_gridshift(b,1,i),a.a=n,a.es=o,b.a=p,b.es=q,i}},{}],31:[function(a,b){function c(a){var b=this;if(2===arguments.length){var d=arguments[1];c[a]="string"==typeof d?"+"===d.charAt(0)?e(arguments[1]):f(arguments[1]):d}else if(1===arguments.length){if(Array.isArray(a))return a.map(function(a){Array.isArray(a)?c.apply(b,a):c(a)});if("string"==typeof a){if(a in c)return c[a]}else"EPSG"in a?c["EPSG:"+a.EPSG]=a:"ESRI"in a?c["ESRI:"+a.ESRI]=a:"IAU2000"in a?c["IAU2000:"+a.IAU2000]=a:console.log(a);return}}var d=a("./global"),e=a("./projString"),f=a("./wkt");d(c),b.exports=c},{"./global":34,"./projString":37,"./wkt":65}],32:[function(a,b){var c=a("./constants/Datum"),d=a("./constants/Ellipsoid"),e=a("./extend"),f=a("./datum"),g=1e-10,h=.16666666666666666,i=.04722222222222222,j=.022156084656084655;b.exports=function(a){if(a.datumCode&&"none"!==a.datumCode){var b=c[a.datumCode];b&&(a.datum_params=b.towgs84?b.towgs84.split(","):null,a.ellps=b.ellipse,a.datumName=b.datumName?b.datumName:a.datumCode)}if(!a.a){var k=d[a.ellps]?d[a.ellps]:d.WGS84;e(a,k)}return a.rf&&!a.b&&(a.b=(1-1/a.rf)*a.a),(0===a.rf||Math.abs(a.a-a.b)<g)&&(a.sphere=!0,a.b=a.a),a.a2=a.a*a.a,a.b2=a.b*a.b,a.es=(a.a2-a.b2)/a.a2,a.e=Math.sqrt(a.es),a.R_A&&(a.a*=1-a.es*(h+a.es*(i+a.es*j)),a.a2=a.a*a.a,a.b2=a.b*a.b,a.es=0),a.ep2=(a.a2-a.b2)/a.b2,a.k0||(a.k0=1),a.axis||(a.axis="enu"),a.datum||(a.datum=f(a)),a}},{"./constants/Datum":25,"./constants/Ellipsoid":26,"./datum":29,"./extend":33}],33:[function(a,b){b.exports=function(a,b){a=a||{};var c,d;if(!b)return a;for(d in b)c=b[d],void 0!==c&&(a[d]=c);return a}},{}],34:[function(a,b){b.exports=function(a){a("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),a("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),a("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),a.WGS84=a["EPSG:4326"],a["EPSG:3785"]=a["EPSG:3857"],a.GOOGLE=a["EPSG:3857"],a["EPSG:900913"]=a["EPSG:3857"],a["EPSG:102113"]=a["EPSG:3857"]}},{}],35:[function(a,b){var proj4=a("./core");proj4.defaultDatum="WGS84",proj4.Proj=a("./Proj"),proj4.WGS84=new proj4.Proj("WGS84"),proj4.Point=a("./Point"),proj4.toPoint=a("./common/toPoint"),proj4.defs=a("./defs"),proj4.transform=a("./transform"),proj4.mgrs=a("mgrs"),proj4.version=a("../package.json").version,a("./includedProjections")(proj4),b.exports=proj4},{"../package.json":67,"./Point":1,"./Proj":2,"./common/toPoint":23,"./core":28,"./defs":31,"./includedProjections":"gWUPNW","./transform":64,mgrs:66}],36:[function(a,b){function c(a){return"string"==typeof a}function d(a){return a in h}function e(a){var b=["GEOGCS","GEOCCS","PROJCS","LOCAL_CS"];return b.reduce(function(b,c){return b+1+a.indexOf(c)},0)}function f(a){return"+"===a[0]}function g(a){return c(a)?d(a)?h[a]:e(a)?i(a):f(a)?j(a):void 0:a}var h=a("./defs"),i=a("./wkt"),j=a("./projString");b.exports=g},{"./defs":31,"./projString":37,"./wkt":65}],37:[function(a,b){var c=.017453292519943295,d=a("./constants/PrimeMeridian");b.exports=function(a){var b={},e={};a.split("+").map(function(a){return a.trim()}).filter(function(a){return a}).forEach(function(a){var b=a.split("=");b.push(!0),e[b[0].toLowerCase()]=b[1]});var f,g,h,i={proj:"projName",datum:"datumCode",rf:function(a){b.rf=parseFloat(a)},lat_0:function(a){b.lat0=a*c},lat_1:function(a){b.lat1=a*c},lat_2:function(a){b.lat2=a*c},lat_ts:function(a){b.lat_ts=a*c},lon_0:function(a){b.long0=a*c},lon_1:function(a){b.long1=a*c},lon_2:function(a){b.long2=a*c},alpha:function(a){b.alpha=parseFloat(a)*c},lonc:function(a){b.longc=a*c},x_0:function(a){b.x0=parseFloat(a)},y_0:function(a){b.y0=parseFloat(a)},k_0:function(a){b.k0=parseFloat(a)},k:function(a){b.k0=parseFloat(a)},a:function(a){b.a=parseFloat(a)},b:function(a){b.b=parseFloat(a)},r_a:function(){b.R_A=!0},zone:function(a){b.zone=parseInt(a,10)},south:function(){b.utmSouth=!0},towgs84:function(a){b.datum_params=a.split(",").map(function(a){return parseFloat(a)})},to_meter:function(a){b.to_meter=parseFloat(a)},from_greenwich:function(a){b.from_greenwich=a*c},pm:function(a){b.from_greenwich=(d[a]?d[a]:parseFloat(a))*c},nadgrids:function(a){"@null"===a?b.datumCode="none":b.nadgrids=a},axis:function(a){var c="ewnsud";3===a.length&&-1!==c.indexOf(a.substr(0,1))&&-1!==c.indexOf(a.substr(1,1))&&-1!==c.indexOf(a.substr(2,1))&&(b.axis=a)}};for(f in e)g=e[f],f in i?(h=i[f],"function"==typeof h?h(g):b[h]=g):b[f]=g;return"string"==typeof b.datumCode&&"WGS84"!==b.datumCode&&(b.datumCode=b.datumCode.toLowerCase()),b}},{"./constants/PrimeMeridian":27}],38:[function(a,b,c){function d(a,b){var c=g.length;return a.names?(g[c]=a,a.names.forEach(function(a){f[a.toLowerCase()]=c}),this):(console.log(b),!0)}var e=[a("./projections/merc"),a("./projections/longlat")],f={},g=[];c.add=d,c.get=function(a){if(!a)return!1;var b=a.toLowerCase();return"undefined"!=typeof f[b]&&g[f[b]]?g[f[b]]:void 0},c.start=function(){e.forEach(d)}},{"./projections/longlat":50,"./projections/merc":51}],39:[function(a,b,c){var d=1e-10,e=a("../common/msfnz"),f=a("../common/qsfnz"),g=a("../common/adjust_lon"),h=a("../common/asinz");c.init=function(){Math.abs(this.lat1+this.lat2)<d||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=e(this.e3,this.sin_po,this.cos_po),this.qs1=f(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=e(this.e3,this.sin_po,this.cos_po),this.qs2=f(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=f(this.e3,this.sin_po,this.cos_po),this.ns0=Math.abs(this.lat1-this.lat2)>d?(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)},c.forward=function(a){var b=a.x,c=a.y;this.sin_phi=Math.sin(c),this.cos_phi=Math.cos(c);var d=f(this.e3,this.sin_phi,this.cos_phi),e=this.a*Math.sqrt(this.c-this.ns0*d)/this.ns0,h=this.ns0*g(b-this.long0),i=e*Math.sin(h)+this.x0,j=this.rh-e*Math.cos(h)+this.y0;return a.x=i,a.y=j,a},c.inverse=function(a){var b,c,d,e,f,h;return a.x-=this.x0,a.y=this.rh-a.y+this.y0,this.ns0>=0?(b=Math.sqrt(a.x*a.x+a.y*a.y),d=1):(b=-Math.sqrt(a.x*a.x+a.y*a.y),d=-1),e=0,0!==b&&(e=Math.atan2(d*a.x,d*a.y)),d=b*this.ns0/this.a,this.sphere?h=Math.asin((this.c-d*d)/(2*this.ns0)):(c=(this.c-d*d)/this.ns0,h=this.phi1z(this.e3,c)),f=g(e/this.ns0+this.long0),a.x=f,a.y=h,a},c.phi1z=function(a,b){var c,e,f,g,i,j=h(.5*b);if(d>a)return j;for(var k=a*a,l=1;25>=l;l++)if(c=Math.sin(j),e=Math.cos(j),f=a*c,g=1-f*f,i=.5*g*g/e*(b/(1-k)-c/g+.5/a*Math.log((1-f)/(1+f))),j+=i,Math.abs(i)<=1e-7)return j;return null},c.names=["Albers_Conic_Equal_Area","Albers","aea"]},{"../common/adjust_lon":5,"../common/asinz":6,"../common/msfnz":15,"../common/qsfnz":20}],40:[function(a,b,c){var d=a("../common/adjust_lon"),e=Math.PI/2,f=1e-10,g=a("../common/mlfn"),h=a("../common/e0fn"),i=a("../common/e1fn"),j=a("../common/e2fn"),k=a("../common/e3fn"),l=a("../common/gN"),m=a("../common/asinz"),n=a("../common/imlfn");c.init=function(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0)},c.forward=function(a){var b,c,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H=a.x,I=a.y,J=Math.sin(a.y),K=Math.cos(a.y),L=d(H-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=f?(a.x=this.x0+this.a*(e-I)*Math.sin(L),a.y=this.y0-this.a*(e-I)*Math.cos(L),a):Math.abs(this.sin_p12+1)<=f?(a.x=this.x0+this.a*(e+I)*Math.sin(L),a.y=this.y0+this.a*(e+I)*Math.cos(L),a):(B=this.sin_p12*J+this.cos_p12*K*Math.cos(L),z=Math.acos(B),A=z/Math.sin(z),a.x=this.x0+this.a*A*K*Math.sin(L),a.y=this.y0+this.a*A*(this.cos_p12*J-this.sin_p12*K*Math.cos(L)),a):(b=h(this.es),c=i(this.es),m=j(this.es),n=k(this.es),Math.abs(this.sin_p12-1)<=f?(o=this.a*g(b,c,m,n,e),p=this.a*g(b,c,m,n,I),a.x=this.x0+(o-p)*Math.sin(L),a.y=this.y0-(o-p)*Math.cos(L),a):Math.abs(this.sin_p12+1)<=f?(o=this.a*g(b,c,m,n,e),p=this.a*g(b,c,m,n,I),a.x=this.x0+(o+p)*Math.sin(L),a.y=this.y0+(o+p)*Math.cos(L),a):(q=J/K,r=l(this.a,this.e,this.sin_p12),s=l(this.a,this.e,J),t=Math.atan((1-this.es)*q+this.es*r*this.sin_p12/(s*K)),u=Math.atan2(Math.sin(L),this.cos_p12*Math.tan(t)-this.sin_p12*Math.cos(L)),C=0===u?Math.asin(this.cos_p12*Math.sin(t)-this.sin_p12*Math.cos(t)):Math.abs(Math.abs(u)-Math.PI)<=f?-Math.asin(this.cos_p12*Math.sin(t)-this.sin_p12*Math.cos(t)):Math.asin(Math.sin(L)*Math.cos(t)/Math.sin(u)),v=this.e*this.sin_p12/Math.sqrt(1-this.es),w=this.e*this.cos_p12*Math.cos(u)/Math.sqrt(1-this.es),x=v*w,y=w*w,D=C*C,E=D*C,F=E*C,G=F*C,z=r*C*(1-D*y*(1-y)/6+E/8*x*(1-2*y)+F/120*(y*(4-7*y)-3*v*v*(1-7*y))-G/48*x),a.x=this.x0+z*Math.sin(u),a.y=this.y0+z*Math.cos(u),a))},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b,c,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I;if(this.sphere){if(b=Math.sqrt(a.x*a.x+a.y*a.y),b>2*e*this.a)return;return c=b/this.a,o=Math.sin(c),p=Math.cos(c),q=this.long0,Math.abs(b)<=f?r=this.lat0:(r=m(p*this.sin_p12+a.y*o*this.cos_p12/b),s=Math.abs(this.lat0)-e,q=d(Math.abs(s)<=f?this.lat0>=0?this.long0+Math.atan2(a.x,-a.y):this.long0-Math.atan2(-a.x,a.y):this.long0+Math.atan2(a.x*o,b*this.cos_p12*p-a.y*this.sin_p12*o))),a.x=q,a.y=r,a}return t=h(this.es),u=i(this.es),v=j(this.es),w=k(this.es),Math.abs(this.sin_p12-1)<=f?(x=this.a*g(t,u,v,w,e),b=Math.sqrt(a.x*a.x+a.y*a.y),y=x-b,r=n(y/this.a,t,u,v,w),q=d(this.long0+Math.atan2(a.x,-1*a.y)),a.x=q,a.y=r,a):Math.abs(this.sin_p12+1)<=f?(x=this.a*g(t,u,v,w,e),b=Math.sqrt(a.x*a.x+a.y*a.y),y=b-x,r=n(y/this.a,t,u,v,w),q=d(this.long0+Math.atan2(a.x,a.y)),a.x=q,a.y=r,a):(b=Math.sqrt(a.x*a.x+a.y*a.y),B=Math.atan2(a.x,a.y),z=l(this.a,this.e,this.sin_p12),C=Math.cos(B),D=this.e*this.cos_p12*C,E=-D*D/(1-this.es),F=3*this.es*(1-E)*this.sin_p12*this.cos_p12*C/(1-this.es),G=b/z,H=G-E*(1+E)*Math.pow(G,3)/6-F*(1+3*E)*Math.pow(G,4)/24,I=1-E*H*H/2-G*H*H*H/6,A=Math.asin(this.sin_p12*Math.cos(H)+this.cos_p12*Math.sin(H)*C),q=d(this.long0+Math.asin(Math.sin(B)*Math.sin(H)/Math.cos(A))),r=Math.atan((1-this.es*I*this.sin_p12/Math.sin(A))*Math.tan(A)/(1-this.es)),a.x=q,a.y=r,a)},c.names=["Azimuthal_Equidistant","aeqd"]},{"../common/adjust_lon":5,"../common/asinz":6,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/imlfn":12,"../common/mlfn":14}],41:[function(a,b,c){var d=a("../common/mlfn"),e=a("../common/e0fn"),f=a("../common/e1fn"),g=a("../common/e2fn"),h=a("../common/e3fn"),i=a("../common/gN"),j=a("../common/adjust_lon"),k=a("../common/adjust_lat"),l=a("../common/imlfn"),m=Math.PI/2,n=1e-10;c.init=function(){this.sphere||(this.e0=e(this.es),this.e1=f(this.es),this.e2=g(this.es),this.e3=h(this.es),this.ml0=this.a*d(this.e0,this.e1,this.e2,this.e3,this.lat0))},c.forward=function(a){var b,c,e=a.x,f=a.y;if(e=j(e-this.long0),this.sphere)b=this.a*Math.asin(Math.cos(f)*Math.sin(e)),c=this.a*(Math.atan2(Math.tan(f),Math.cos(e))-this.lat0);else{var g=Math.sin(f),h=Math.cos(f),k=i(this.a,this.e,g),l=Math.tan(f)*Math.tan(f),m=e*Math.cos(f),n=m*m,o=this.es*h*h/(1-this.es),p=this.a*d(this.e0,this.e1,this.e2,this.e3,f);b=k*m*(1-n*l*(1/6-(8-l+8*o)*n/120)),c=p-this.ml0+k*g/h*n*(.5+(5-l+6*o)*n/24)}return a.x=b+this.x0,a.y=c+this.y0,a},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b,c,d=a.x/this.a,e=a.y/this.a;if(this.sphere){var f=e+this.lat0;b=Math.asin(Math.sin(f)*Math.cos(d)),c=Math.atan2(Math.tan(d),Math.cos(f))}else{var g=this.ml0/this.a+e,h=l(g,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(h)-m)<=n)return a.x=this.long0,a.y=m,0>e&&(a.y*=-1),a;var o=i(this.a,this.e,Math.sin(h)),p=o*o*o/this.a/this.a*(1-this.es),q=Math.pow(Math.tan(h),2),r=d*this.a/o,s=r*r;b=h-o*Math.tan(h)/p*r*r*(.5-(1+3*q)*r*r/24),c=r*(1-s*(q/3+(1+3*q)*q*s/15))/Math.cos(h)}return a.x=j(c+this.long0),a.y=k(b),a},c.names=["Cassini","Cassini_Soldner","cass"]},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/imlfn":12,"../common/mlfn":14}],42:[function(a,b,c){var d=a("../common/adjust_lon"),e=a("../common/qsfnz"),f=a("../common/msfnz"),g=a("../common/iqsfnz");c.init=function(){this.sphere||(this.k0=f(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))},c.forward=function(a){var b,c,f=a.x,g=a.y,h=d(f-this.long0);if(this.sphere)b=this.x0+this.a*h*Math.cos(this.lat_ts),c=this.y0+this.a*Math.sin(g)/Math.cos(this.lat_ts);else{var i=e(this.e,Math.sin(g));b=this.x0+this.a*this.k0*h,c=this.y0+this.a*i*.5/this.k0}return a.x=b,a.y=c,a},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b,c;return this.sphere?(b=d(this.long0+a.x/this.a/Math.cos(this.lat_ts)),c=Math.asin(a.y/this.a*Math.cos(this.lat_ts))):(c=g(this.e,2*a.y*this.k0/this.a),b=d(this.long0+a.x/(this.a*this.k0))),a.x=b,a.y=c,a},c.names=["cea"]},{"../common/adjust_lon":5,"../common/iqsfnz":13,"../common/msfnz":15,"../common/qsfnz":20}],43:[function(a,b,c){var d=a("../common/adjust_lon"),e=a("../common/adjust_lat");c.init=function(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)},c.forward=function(a){var b=a.x,c=a.y,f=d(b-this.long0),g=e(c-this.lat0);return a.x=this.x0+this.a*f*this.rc,a.y=this.y0+this.a*g,a},c.inverse=function(a){var b=a.x,c=a.y;return a.x=d(this.long0+(b-this.x0)/(this.a*this.rc)),a.y=e(this.lat0+(c-this.y0)/this.a),a},c.names=["Equirectangular","Equidistant_Cylindrical","eqc"]},{"../common/adjust_lat":4,"../common/adjust_lon":5}],44:[function(a,b,c){var d=a("../common/e0fn"),e=a("../common/e1fn"),f=a("../common/e2fn"),g=a("../common/e3fn"),h=a("../common/msfnz"),i=a("../common/mlfn"),j=a("../common/adjust_lon"),k=a("../common/adjust_lat"),l=a("../common/imlfn"),m=1e-10;c.init=function(){Math.abs(this.lat1+this.lat2)<m||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=d(this.es),this.e1=e(this.es),this.e2=f(this.es),this.e3=g(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=h(this.e,this.sinphi,this.cosphi),this.ml1=i(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<m?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=h(this.e,this.sinphi,this.cosphi),this.ml2=i(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=i(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))},c.forward=function(a){var b,c=a.x,d=a.y;if(this.sphere)b=this.a*(this.g-d);else{var e=i(this.e0,this.e1,this.e2,this.e3,d);b=this.a*(this.g-e)}var f=this.ns*j(c-this.long0),g=this.x0+b*Math.sin(f),h=this.y0+this.rh-b*Math.cos(f);return a.x=g,a.y=h,a},c.inverse=function(a){a.x-=this.x0,a.y=this.rh-a.y+this.y0;var b,c,d,e;this.ns>=0?(c=Math.sqrt(a.x*a.x+a.y*a.y),b=1):(c=-Math.sqrt(a.x*a.x+a.y*a.y),b=-1);var f=0;if(0!==c&&(f=Math.atan2(b*a.x,b*a.y)),this.sphere)return e=j(this.long0+f/this.ns),d=k(this.g-c/this.a),a.x=e,a.y=d,a;var g=this.g-c/this.a;return d=l(g,this.e0,this.e1,this.e2,this.e3),e=j(this.long0+f/this.ns),a.x=e,a.y=d,a},c.names=["Equidistant_Conic","eqdc"]},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/imlfn":12,"../common/mlfn":14,"../common/msfnz":15}],45:[function(a,b,c){var d=Math.PI/4,e=a("../common/srat"),f=Math.PI/2,g=20;c.init=function(){var a=Math.sin(this.lat0),b=Math.cos(this.lat0);b*=b,this.rc=Math.sqrt(1-this.es)/(1-this.es*a*a),this.C=Math.sqrt(1+this.es*b*b/(1-this.es)),this.phic0=Math.asin(a/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+d)/(Math.pow(Math.tan(.5*this.lat0+d),this.C)*e(this.e*a,this.ratexp))},c.forward=function(a){var b=a.x,c=a.y;return a.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*c+d),this.C)*e(this.e*Math.sin(c),this.ratexp))-f,a.x=this.C*b,a},c.inverse=function(a){for(var b=1e-14,c=a.x/this.C,h=a.y,i=Math.pow(Math.tan(.5*h+d)/this.K,1/this.C),j=g;j>0&&(h=2*Math.atan(i*e(this.e*Math.sin(a.y),-.5*this.e))-f,!(Math.abs(h-a.y)<b));--j)a.y=h;return j?(a.x=c,a.y=h,a):null},c.names=["gauss"]},{"../common/srat":22}],46:[function(a,b,c){var d=a("../common/adjust_lon"),e=1e-10,f=a("../common/asinz");c.init=function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1},c.forward=function(a){var b,c,f,g,h,i,j,k,l=a.x,m=a.y;return f=d(l-this.long0),b=Math.sin(m),c=Math.cos(m),g=Math.cos(f),i=this.sin_p14*b+this.cos_p14*c*g,h=1,i>0||Math.abs(i)<=e?(j=this.x0+this.a*h*c*Math.sin(f)/i,k=this.y0+this.a*h*(this.cos_p14*b-this.sin_p14*c*g)/i):(j=this.x0+this.infinity_dist*c*Math.sin(f),k=this.y0+this.infinity_dist*(this.cos_p14*b-this.sin_p14*c*g)),a.x=j,a.y=k,a
},c.inverse=function(a){var b,c,e,g,h,i;return a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,(b=Math.sqrt(a.x*a.x+a.y*a.y))?(g=Math.atan2(b,this.rc),c=Math.sin(g),e=Math.cos(g),i=f(e*this.sin_p14+a.y*c*this.cos_p14/b),h=Math.atan2(a.x*c,b*this.cos_p14*e-a.y*this.sin_p14*c),h=d(this.long0+h)):(i=this.phic0,h=0),a.x=h,a.y=i,a},c.names=["gnom"]},{"../common/adjust_lon":5,"../common/asinz":6}],47:[function(a,b,c){var d=a("../common/adjust_lon");c.init=function(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq},c.forward=function(a){var b,c,e,f,g,h,i,j=a.x,k=a.y,l=d(j-this.long0);return b=Math.pow((1+this.e*Math.sin(k))/(1-this.e*Math.sin(k)),this.alfa*this.e/2),c=2*(Math.atan(this.k*Math.pow(Math.tan(k/2+this.s45),this.alfa)/b)-this.s45),e=-l*this.alfa,f=Math.asin(Math.cos(this.ad)*Math.sin(c)+Math.sin(this.ad)*Math.cos(c)*Math.cos(e)),g=Math.asin(Math.cos(c)*Math.sin(e)/Math.cos(f)),h=this.n*g,i=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(f/2+this.s45),this.n),a.y=i*Math.cos(h)/1,a.x=i*Math.sin(h)/1,this.czech||(a.y*=-1,a.x*=-1),a},c.inverse=function(a){var b,c,d,e,f,g,h,i,j=a.x;a.x=a.y,a.y=j,this.czech||(a.y*=-1,a.x*=-1),g=Math.sqrt(a.x*a.x+a.y*a.y),f=Math.atan2(a.y,a.x),e=f/Math.sin(this.s0),d=2*(Math.atan(Math.pow(this.ro0/g,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),b=Math.asin(Math.cos(this.ad)*Math.sin(d)-Math.sin(this.ad)*Math.cos(d)*Math.cos(e)),c=Math.asin(Math.cos(d)*Math.sin(e)/Math.cos(b)),a.x=this.long0-c/this.alfa,h=b,i=0;var k=0;do a.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(b/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(h))/(1-this.e*Math.sin(h)),this.e/2))-this.s45),Math.abs(h-a.y)<1e-10&&(i=1),h=a.y,k+=1;while(0===i&&15>k);return k>=15?null:a},c.names=["Krovak","krovak"]},{"../common/adjust_lon":5}],48:[function(a,b,c){var d=Math.PI/2,e=Math.PI/4,f=1e-10,g=a("../common/qsfnz"),h=a("../common/adjust_lon");c.S_POLE=1,c.N_POLE=2,c.EQUIT=3,c.OBLIQ=4,c.init=function(){var a=Math.abs(this.lat0);if(this.mode=Math.abs(a-d)<f?this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(a)<f?this.EQUIT:this.OBLIQ,this.es>0){var b;switch(this.qp=g(this.e,1),this.mmf=.5/(1-this.es),this.apa=this.authset(this.es),this.mode){case this.N_POLE:this.dd=1;break;case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),b=Math.sin(this.lat0),this.sinb1=g(this.e,b)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*b*b)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))},c.forward=function(a){var b,c,i,j,k,l,m,n,o,p,q=a.x,r=a.y;if(q=h(q-this.long0),this.sphere){if(k=Math.sin(r),p=Math.cos(r),i=Math.cos(q),this.mode===this.OBLIQ||this.mode===this.EQUIT){if(c=this.mode===this.EQUIT?1+p*i:1+this.sinph0*k+this.cosph0*p*i,f>=c)return null;c=Math.sqrt(2/c),b=c*p*Math.sin(q),c*=this.mode===this.EQUIT?k:this.cosph0*k-this.sinph0*p*i}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(i=-i),Math.abs(r+this.phi0)<f)return null;c=e-.5*r,c=2*(this.mode===this.S_POLE?Math.cos(c):Math.sin(c)),b=c*Math.sin(q),c*=i}}else{switch(m=0,n=0,o=0,i=Math.cos(q),j=Math.sin(q),k=Math.sin(r),l=g(this.e,k),(this.mode===this.OBLIQ||this.mode===this.EQUIT)&&(m=l/this.qp,n=Math.sqrt(1-m*m)),this.mode){case this.OBLIQ:o=1+this.sinb1*m+this.cosb1*n*i;break;case this.EQUIT:o=1+n*i;break;case this.N_POLE:o=d+r,l=this.qp-l;break;case this.S_POLE:o=r-d,l=this.qp+l}if(Math.abs(o)<f)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:o=Math.sqrt(2/o),c=this.mode===this.OBLIQ?this.ymf*o*(this.cosb1*m-this.sinb1*n*i):(o=Math.sqrt(2/(1+n*i)))*m*this.ymf,b=this.xmf*o*n*j;break;case this.N_POLE:case this.S_POLE:l>=0?(b=(o=Math.sqrt(l))*j,c=i*(this.mode===this.S_POLE?o:-o)):b=c=0}}return a.x=this.a*b+this.x0,a.y=this.a*c+this.y0,a},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b,c,e,g,i,j,k,l=a.x/this.a,m=a.y/this.a;if(this.sphere){var n,o=0,p=0;if(n=Math.sqrt(l*l+m*m),c=.5*n,c>1)return null;switch(c=2*Math.asin(c),(this.mode===this.OBLIQ||this.mode===this.EQUIT)&&(p=Math.sin(c),o=Math.cos(c)),this.mode){case this.EQUIT:c=Math.abs(n)<=f?0:Math.asin(m*p/n),l*=p,m=o*n;break;case this.OBLIQ:c=Math.abs(n)<=f?this.phi0:Math.asin(o*this.sinph0+m*p*this.cosph0/n),l*=p*this.cosph0,m=(o-Math.sin(c)*this.sinph0)*n;break;case this.N_POLE:m=-m,c=d-c;break;case this.S_POLE:c-=d}b=0!==m||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(l,m):0}else{if(k=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(l/=this.dd,m*=this.dd,j=Math.sqrt(l*l+m*m),f>j)return a.x=0,a.y=this.phi0,a;g=2*Math.asin(.5*j/this.rq),e=Math.cos(g),l*=g=Math.sin(g),this.mode===this.OBLIQ?(k=e*this.sinb1+m*g*this.cosb1/j,i=this.qp*k,m=j*this.cosb1*e-m*this.sinb1*g):(k=m*g/j,i=this.qp*k,m=j*e)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(m=-m),i=l*l+m*m,!i)return a.x=0,a.y=this.phi0,a;k=1-i/this.qp,this.mode===this.S_POLE&&(k=-k)}b=Math.atan2(l,m),c=this.authlat(Math.asin(k),this.apa)}return a.x=h(this.long0+b),a.y=c,a},c.P00=.3333333333333333,c.P01=.17222222222222222,c.P02=.10257936507936508,c.P10=.06388888888888888,c.P11=.0664021164021164,c.P20=.016415012942191543,c.authset=function(a){var b,c=[];return c[0]=a*this.P00,b=a*a,c[0]+=b*this.P01,c[1]=b*this.P10,b*=a,c[0]+=b*this.P02,c[1]+=b*this.P11,c[2]=b*this.P20,c},c.authlat=function(a,b){var c=a+a;return a+b[0]*Math.sin(c)+b[1]*Math.sin(c+c)+b[2]*Math.sin(c+c+c)},c.names=["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"]},{"../common/adjust_lon":5,"../common/qsfnz":20}],49:[function(a,b,c){var d=1e-10,e=a("../common/msfnz"),f=a("../common/tsfnz"),g=Math.PI/2,h=a("../common/sign"),i=a("../common/adjust_lon"),j=a("../common/phi2z");c.init=function(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<d)){var a=this.b/this.a;this.e=Math.sqrt(1-a*a);var b=Math.sin(this.lat1),c=Math.cos(this.lat1),g=e(this.e,b,c),h=f(this.e,this.lat1,b),i=Math.sin(this.lat2),j=Math.cos(this.lat2),k=e(this.e,i,j),l=f(this.e,this.lat2,i),m=f(this.e,this.lat0,Math.sin(this.lat0));this.ns=Math.abs(this.lat1-this.lat2)>d?Math.log(g/k)/Math.log(h/l):b,isNaN(this.ns)&&(this.ns=b),this.f0=g/(this.ns*Math.pow(h,this.ns)),this.rh=this.a*this.f0*Math.pow(m,this.ns),this.title||(this.title="Lambert Conformal Conic")}},c.forward=function(a){var b=a.x,c=a.y;Math.abs(2*Math.abs(c)-Math.PI)<=d&&(c=h(c)*(g-2*d));var e,j,k=Math.abs(Math.abs(c)-g);if(k>d)e=f(this.e,c,Math.sin(c)),j=this.a*this.f0*Math.pow(e,this.ns);else{if(k=c*this.ns,0>=k)return null;j=0}var l=this.ns*i(b-this.long0);return a.x=this.k0*j*Math.sin(l)+this.x0,a.y=this.k0*(this.rh-j*Math.cos(l))+this.y0,a},c.inverse=function(a){var b,c,d,e,f,h=(a.x-this.x0)/this.k0,k=this.rh-(a.y-this.y0)/this.k0;this.ns>0?(b=Math.sqrt(h*h+k*k),c=1):(b=-Math.sqrt(h*h+k*k),c=-1);var l=0;if(0!==b&&(l=Math.atan2(c*h,c*k)),0!==b||this.ns>0){if(c=1/this.ns,d=Math.pow(b/(this.a*this.f0),c),e=j(this.e,d),-9999===e)return null}else e=-g;return f=i(l/this.ns+this.long0),a.x=f,a.y=e,a},c.names=["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_2SP","lcc"]},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/sign":21,"../common/tsfnz":24}],50:[function(a,b,c){function d(a){return a}c.init=function(){},c.forward=d,c.inverse=d,c.names=["longlat","identity"]},{}],51:[function(a,b,c){var d=a("../common/msfnz"),e=Math.PI/2,f=1e-10,g=57.29577951308232,h=a("../common/adjust_lon"),i=Math.PI/4,j=a("../common/tsfnz"),k=a("../common/phi2z");c.init=function(){var a=this.b/this.a;this.es=1-a*a,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.k0=this.sphere?Math.cos(this.lat_ts):d(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k0=this.k?this.k:1)},c.forward=function(a){var b=a.x,c=a.y;if(c*g>90&&-90>c*g&&b*g>180&&-180>b*g)return null;var d,k;if(Math.abs(Math.abs(c)-e)<=f)return null;if(this.sphere)d=this.x0+this.a*this.k0*h(b-this.long0),k=this.y0+this.a*this.k0*Math.log(Math.tan(i+.5*c));else{var l=Math.sin(c),m=j(this.e,c,l);d=this.x0+this.a*this.k0*h(b-this.long0),k=this.y0-this.a*this.k0*Math.log(m)}return a.x=d,a.y=k,a},c.inverse=function(a){var b,c,d=a.x-this.x0,f=a.y-this.y0;if(this.sphere)c=e-2*Math.atan(Math.exp(-f/(this.a*this.k0)));else{var g=Math.exp(-f/(this.a*this.k0));if(c=k(this.e,g),-9999===c)return null}return b=h(this.long0+d/(this.a*this.k0)),a.x=b,a.y=c,a},c.names=["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"]},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/tsfnz":24}],52:[function(a,b,c){var d=a("../common/adjust_lon");c.init=function(){},c.forward=function(a){var b=a.x,c=a.y,e=d(b-this.long0),f=this.x0+this.a*e,g=this.y0+this.a*Math.log(Math.tan(Math.PI/4+c/2.5))*1.25;return a.x=f,a.y=g,a},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b=d(this.long0+a.x/this.a),c=2.5*(Math.atan(Math.exp(.8*a.y/this.a))-Math.PI/4);return a.x=b,a.y=c,a},c.names=["Miller_Cylindrical","mill"]},{"../common/adjust_lon":5}],53:[function(a,b,c){var d=a("../common/adjust_lon"),e=1e-10;c.init=function(){},c.forward=function(a){for(var b=a.x,c=a.y,f=d(b-this.long0),g=c,h=Math.PI*Math.sin(c),i=0;!0;i++){var j=-(g+Math.sin(g)-h)/(1+Math.cos(g));if(g+=j,Math.abs(j)<e)break}g/=2,Math.PI/2-Math.abs(c)<e&&(f=0);var k=.900316316158*this.a*f*Math.cos(g)+this.x0,l=1.4142135623731*this.a*Math.sin(g)+this.y0;return a.x=k,a.y=l,a},c.inverse=function(a){var b,c;a.x-=this.x0,a.y-=this.y0,c=a.y/(1.4142135623731*this.a),Math.abs(c)>.999999999999&&(c=.999999999999),b=Math.asin(c);var e=d(this.long0+a.x/(.900316316158*this.a*Math.cos(b)));e<-Math.PI&&(e=-Math.PI),e>Math.PI&&(e=Math.PI),c=(2*b+Math.sin(2*b))/Math.PI,Math.abs(c)>1&&(c=1);var f=Math.asin(c);return a.x=e,a.y=f,a},c.names=["Mollweide","moll"]},{"../common/adjust_lon":5}],54:[function(a,b,c){var d=484813681109536e-20;c.iterations=1,c.init=function(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013},c.forward=function(a){var b,c=a.x,e=a.y,f=e-this.lat0,g=c-this.long0,h=f/d*1e-5,i=g,j=1,k=0;for(b=1;10>=b;b++)j*=h,k+=this.A[b]*j;var l,m,n=k,o=i,p=1,q=0,r=0,s=0;for(b=1;6>=b;b++)l=p*n-q*o,m=q*n+p*o,p=l,q=m,r=r+this.B_re[b]*p-this.B_im[b]*q,s=s+this.B_im[b]*p+this.B_re[b]*q;return a.x=s*this.a+this.x0,a.y=r*this.a+this.y0,a},c.inverse=function(a){var b,c,e,f=a.x,g=a.y,h=f-this.x0,i=g-this.y0,j=i/this.a,k=h/this.a,l=1,m=0,n=0,o=0;for(b=1;6>=b;b++)c=l*j-m*k,e=m*j+l*k,l=c,m=e,n=n+this.C_re[b]*l-this.C_im[b]*m,o=o+this.C_im[b]*l+this.C_re[b]*m;for(var p=0;p<this.iterations;p++){var q,r,s=n,t=o,u=j,v=k;for(b=2;6>=b;b++)q=s*n-t*o,r=t*n+s*o,s=q,t=r,u+=(b-1)*(this.B_re[b]*s-this.B_im[b]*t),v+=(b-1)*(this.B_im[b]*s+this.B_re[b]*t);s=1,t=0;var w=this.B_re[1],x=this.B_im[1];for(b=2;6>=b;b++)q=s*n-t*o,r=t*n+s*o,s=q,t=r,w+=b*(this.B_re[b]*s-this.B_im[b]*t),x+=b*(this.B_im[b]*s+this.B_re[b]*t);var y=w*w+x*x;n=(u*w+v*x)/y,o=(v*w-u*x)/y}var z=n,A=o,B=1,C=0;for(b=1;9>=b;b++)B*=z,C+=this.D[b]*B;var D=this.lat0+C*d*1e5,E=this.long0+A;return a.x=E,a.y=D,a},c.names=["New_Zealand_Map_Grid","nzmg"]},{}],55:[function(a,b,c){var d=a("../common/tsfnz"),e=a("../common/adjust_lon"),f=a("../common/phi2z"),g=Math.PI/2,h=Math.PI/4,i=1e-10;c.init=function(){this.no_off=this.no_off||!1,this.no_rot=this.no_rot||!1,isNaN(this.k0)&&(this.k0=1);var a=Math.sin(this.lat0),b=Math.cos(this.lat0),c=this.e*a;this.bl=Math.sqrt(1+this.es/(1-this.es)*Math.pow(b,4)),this.al=this.a*this.bl*this.k0*Math.sqrt(1-this.es)/(1-c*c);var f=d(this.e,this.lat0,a),g=this.bl/b*Math.sqrt((1-this.es)/(1-c*c));1>g*g&&(g=1);var h,i;if(isNaN(this.longc)){var j=d(this.e,this.lat1,Math.sin(this.lat1)),k=d(this.e,this.lat2,Math.sin(this.lat2));this.el=this.lat0>=0?(g+Math.sqrt(g*g-1))*Math.pow(f,this.bl):(g-Math.sqrt(g*g-1))*Math.pow(f,this.bl);var l=Math.pow(j,this.bl),m=Math.pow(k,this.bl);h=this.el/l,i=.5*(h-1/h);var n=(this.el*this.el-m*l)/(this.el*this.el+m*l),o=(m-l)/(m+l),p=e(this.long1-this.long2);this.long0=.5*(this.long1+this.long2)-Math.atan(n*Math.tan(.5*this.bl*p)/o)/this.bl,this.long0=e(this.long0);var q=e(this.long1-this.long0);this.gamma0=Math.atan(Math.sin(this.bl*q)/i),this.alpha=Math.asin(g*Math.sin(this.gamma0))}else h=this.lat0>=0?g+Math.sqrt(g*g-1):g-Math.sqrt(g*g-1),this.el=h*Math.pow(f,this.bl),i=.5*(h-1/h),this.gamma0=Math.asin(Math.sin(this.alpha)/g),this.long0=this.longc-Math.asin(i*Math.tan(this.gamma0))/this.bl;this.uc=this.no_off?0:this.lat0>=0?this.al/this.bl*Math.atan2(Math.sqrt(g*g-1),Math.cos(this.alpha)):-1*this.al/this.bl*Math.atan2(Math.sqrt(g*g-1),Math.cos(this.alpha))},c.forward=function(a){var b,c,f,j=a.x,k=a.y,l=e(j-this.long0);if(Math.abs(Math.abs(k)-g)<=i)f=k>0?-1:1,c=this.al/this.bl*Math.log(Math.tan(h+f*this.gamma0*.5)),b=-1*f*g*this.al/this.bl;else{var m=d(this.e,k,Math.sin(k)),n=this.el/Math.pow(m,this.bl),o=.5*(n-1/n),p=.5*(n+1/n),q=Math.sin(this.bl*l),r=(o*Math.sin(this.gamma0)-q*Math.cos(this.gamma0))/p;c=Math.abs(Math.abs(r)-1)<=i?Number.POSITIVE_INFINITY:.5*this.al*Math.log((1-r)/(1+r))/this.bl,b=Math.abs(Math.cos(this.bl*l))<=i?this.al*this.bl*l:this.al*Math.atan2(o*Math.cos(this.gamma0)+q*Math.sin(this.gamma0),Math.cos(this.bl*l))/this.bl}return this.no_rot?(a.x=this.x0+b,a.y=this.y0+c):(b-=this.uc,a.x=this.x0+c*Math.cos(this.alpha)+b*Math.sin(this.alpha),a.y=this.y0+b*Math.cos(this.alpha)-c*Math.sin(this.alpha)),a},c.inverse=function(a){var b,c;this.no_rot?(c=a.y-this.y0,b=a.x-this.x0):(c=(a.x-this.x0)*Math.cos(this.alpha)-(a.y-this.y0)*Math.sin(this.alpha),b=(a.y-this.y0)*Math.cos(this.alpha)+(a.x-this.x0)*Math.sin(this.alpha),b+=this.uc);var d=Math.exp(-1*this.bl*c/this.al),h=.5*(d-1/d),j=.5*(d+1/d),k=Math.sin(this.bl*b/this.al),l=(k*Math.cos(this.gamma0)+h*Math.sin(this.gamma0))/j,m=Math.pow(this.el/Math.sqrt((1+l)/(1-l)),1/this.bl);return Math.abs(l-1)<i?(a.x=this.long0,a.y=g):Math.abs(l+1)<i?(a.x=this.long0,a.y=-1*g):(a.y=f(this.e,m),a.x=e(this.long0-Math.atan2(h*Math.cos(this.gamma0)-k*Math.sin(this.gamma0),Math.cos(this.bl*b/this.al))/this.bl)),a},c.names=["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","omerc"]},{"../common/adjust_lon":5,"../common/phi2z":16,"../common/tsfnz":24}],56:[function(a,b,c){var d=a("../common/e0fn"),e=a("../common/e1fn"),f=a("../common/e2fn"),g=a("../common/e3fn"),h=a("../common/adjust_lon"),i=a("../common/adjust_lat"),j=a("../common/mlfn"),k=1e-10,l=a("../common/gN"),m=20;c.init=function(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=d(this.es),this.e1=e(this.es),this.e2=f(this.es),this.e3=g(this.es),this.ml0=this.a*j(this.e0,this.e1,this.e2,this.e3,this.lat0)},c.forward=function(a){var b,c,d,e=a.x,f=a.y,g=h(e-this.long0);if(d=g*Math.sin(f),this.sphere)Math.abs(f)<=k?(b=this.a*g,c=-1*this.a*this.lat0):(b=this.a*Math.sin(d)/Math.tan(f),c=this.a*(i(f-this.lat0)+(1-Math.cos(d))/Math.tan(f)));else if(Math.abs(f)<=k)b=this.a*g,c=-1*this.ml0;else{var m=l(this.a,this.e,Math.sin(f))/Math.tan(f);b=m*Math.sin(d),c=this.a*j(this.e0,this.e1,this.e2,this.e3,f)-this.ml0+m*(1-Math.cos(d))}return a.x=b+this.x0,a.y=c+this.y0,a},c.inverse=function(a){var b,c,d,e,f,g,i,l,n;if(d=a.x-this.x0,e=a.y-this.y0,this.sphere)if(Math.abs(e+this.a*this.lat0)<=k)b=h(d/this.a+this.long0),c=0;else{g=this.lat0+e/this.a,i=d*d/this.a/this.a+g*g,l=g;var o;for(f=m;f;--f)if(o=Math.tan(l),n=-1*(g*(l*o+1)-l-.5*(l*l+i)*o)/((l-g)/o-1),l+=n,Math.abs(n)<=k){c=l;break}b=h(this.long0+Math.asin(d*Math.tan(l)/this.a)/Math.sin(c))}else if(Math.abs(e+this.ml0)<=k)c=0,b=h(this.long0+d/this.a);else{g=(this.ml0+e)/this.a,i=d*d/this.a/this.a+g*g,l=g;var p,q,r,s,t;for(f=m;f;--f)if(t=this.e*Math.sin(l),p=Math.sqrt(1-t*t)*Math.tan(l),q=this.a*j(this.e0,this.e1,this.e2,this.e3,l),r=this.e0-2*this.e1*Math.cos(2*l)+4*this.e2*Math.cos(4*l)-6*this.e3*Math.cos(6*l),s=q/this.a,n=(g*(p*s+1)-s-.5*p*(s*s+i))/(this.es*Math.sin(2*l)*(s*s+i-2*g*s)/(4*p)+(g-s)*(p*r-2/Math.sin(2*l))-r),l-=n,Math.abs(n)<=k){c=l;break}p=Math.sqrt(1-this.es*Math.pow(Math.sin(c),2))*Math.tan(c),b=h(this.long0+Math.asin(d*p/this.a)/Math.sin(c))}return a.x=b,a.y=c,a},c.names=["Polyconic","poly"]},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/mlfn":14}],57:[function(a,b,c){var d=a("../common/adjust_lon"),e=a("../common/adjust_lat"),f=a("../common/pj_enfn"),g=20,h=a("../common/pj_mlfn"),i=a("../common/pj_inv_mlfn"),j=Math.PI/2,k=1e-10,l=a("../common/asinz");c.init=function(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=f(this.es)},c.forward=function(a){var b,c,e=a.x,f=a.y;if(e=d(e-this.long0),this.sphere){if(this.m)for(var i=this.n*Math.sin(f),j=g;j;--j){var l=(this.m*f+Math.sin(f)-i)/(this.m+Math.cos(f));if(f-=l,Math.abs(l)<k)break}else f=1!==this.n?Math.asin(this.n*Math.sin(f)):f;b=this.a*this.C_x*e*(this.m+Math.cos(f)),c=this.a*this.C_y*f}else{var m=Math.sin(f),n=Math.cos(f);c=this.a*h(f,m,n,this.en),b=this.a*e*n/Math.sqrt(1-this.es*m*m)}return a.x=b,a.y=c,a},c.inverse=function(a){var b,c,f,g;return a.x-=this.x0,f=a.x/this.a,a.y-=this.y0,b=a.y/this.a,this.sphere?(b/=this.C_y,f/=this.C_x*(this.m+Math.cos(b)),this.m?b=l((this.m*b+Math.sin(b))/this.n):1!==this.n&&(b=l(Math.sin(b)/this.n)),f=d(f+this.long0),b=e(b)):(b=i(a.y/this.a,this.es,this.en),g=Math.abs(b),j>g?(g=Math.sin(b),c=this.long0+a.x*Math.sqrt(1-this.es*g*g)/(this.a*Math.cos(b)),f=d(c)):j>g-k&&(f=this.long0)),a.x=f,a.y=b,a},c.names=["Sinusoidal","sinu"]},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/asinz":6,"../common/pj_enfn":17,"../common/pj_inv_mlfn":18,"../common/pj_mlfn":19}],58:[function(a,b,c){c.init=function(){var a=this.lat0;this.lambda0=this.long0;var b=Math.sin(a),c=this.a,d=this.rf,e=1/d,f=2*e-Math.pow(e,2),g=this.e=Math.sqrt(f);this.R=this.k0*c*Math.sqrt(1-f)/(1-f*Math.pow(b,2)),this.alpha=Math.sqrt(1+f/(1-f)*Math.pow(Math.cos(a),4)),this.b0=Math.asin(b/this.alpha);var h=Math.log(Math.tan(Math.PI/4+this.b0/2)),i=Math.log(Math.tan(Math.PI/4+a/2)),j=Math.log((1+g*b)/(1-g*b));this.K=h-this.alpha*i+this.alpha*g/2*j},c.forward=function(a){var b=Math.log(Math.tan(Math.PI/4-a.y/2)),c=this.e/2*Math.log((1+this.e*Math.sin(a.y))/(1-this.e*Math.sin(a.y))),d=-this.alpha*(b+c)+this.K,e=2*(Math.atan(Math.exp(d))-Math.PI/4),f=this.alpha*(a.x-this.lambda0),g=Math.atan(Math.sin(f)/(Math.sin(this.b0)*Math.tan(e)+Math.cos(this.b0)*Math.cos(f))),h=Math.asin(Math.cos(this.b0)*Math.sin(e)-Math.sin(this.b0)*Math.cos(e)*Math.cos(f));return a.y=this.R/2*Math.log((1+Math.sin(h))/(1-Math.sin(h)))+this.y0,a.x=this.R*g+this.x0,a},c.inverse=function(a){for(var b=a.x-this.x0,c=a.y-this.y0,d=b/this.R,e=2*(Math.atan(Math.exp(c/this.R))-Math.PI/4),f=Math.asin(Math.cos(this.b0)*Math.sin(e)+Math.sin(this.b0)*Math.cos(e)*Math.cos(d)),g=Math.atan(Math.sin(d)/(Math.cos(this.b0)*Math.cos(d)-Math.sin(this.b0)*Math.tan(e))),h=this.lambda0+g/this.alpha,i=0,j=f,k=-1e3,l=0;Math.abs(j-k)>1e-7;){if(++l>20)return;i=1/this.alpha*(Math.log(Math.tan(Math.PI/4+f/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(j))/2)),k=j,j=2*Math.atan(Math.exp(i))-Math.PI/2}return a.x=h,a.y=j,a},c.names=["somerc"]},{}],59:[function(a,b,c){var d=Math.PI/2,e=1e-10,f=a("../common/sign"),g=a("../common/msfnz"),h=a("../common/tsfnz"),i=a("../common/phi2z"),j=a("../common/adjust_lon");c.ssfn_=function(a,b,c){return b*=c,Math.tan(.5*(d+a))*Math.pow((1-b)/(1+b),.5*c)},c.init=function(){this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=e&&(this.k0=.5*(1+f(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=e&&(this.con=this.lat0>0?1:-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=e&&(this.k0=.5*this.cons*g(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/h(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=g(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-d,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))},c.forward=function(a){var b,c,f,g,i,k,l=a.x,m=a.y,n=Math.sin(m),o=Math.cos(m),p=j(l-this.long0);return Math.abs(Math.abs(l-this.long0)-Math.PI)<=e&&Math.abs(m+this.lat0)<=e?(a.x=0/0,a.y=0/0,a):this.sphere?(b=2*this.k0/(1+this.sinlat0*n+this.coslat0*o*Math.cos(p)),a.x=this.a*b*o*Math.sin(p)+this.x0,a.y=this.a*b*(this.coslat0*n-this.sinlat0*o*Math.cos(p))+this.y0,a):(c=2*Math.atan(this.ssfn_(m,n,this.e))-d,g=Math.cos(c),f=Math.sin(c),Math.abs(this.coslat0)<=e?(i=h(this.e,m*this.con,this.con*n),k=2*this.a*this.k0*i/this.cons,a.x=this.x0+k*Math.sin(l-this.long0),a.y=this.y0-this.con*k*Math.cos(l-this.long0),a):(Math.abs(this.sinlat0)<e?(b=2*this.a*this.k0/(1+g*Math.cos(p)),a.y=b*f):(b=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*f+this.cosX0*g*Math.cos(p))),a.y=b*(this.cosX0*f-this.sinX0*g*Math.cos(p))+this.y0),a.x=b*g*Math.sin(p)+this.x0,a))},c.inverse=function(a){a.x-=this.x0,a.y-=this.y0;var b,c,f,g,h,k=Math.sqrt(a.x*a.x+a.y*a.y);if(this.sphere){var l=2*Math.atan(k/(.5*this.a*this.k0));return b=this.long0,c=this.lat0,e>=k?(a.x=b,a.y=c,a):(c=Math.asin(Math.cos(l)*this.sinlat0+a.y*Math.sin(l)*this.coslat0/k),b=j(Math.abs(this.coslat0)<e?this.lat0>0?this.long0+Math.atan2(a.x,-1*a.y):this.long0+Math.atan2(a.x,a.y):this.long0+Math.atan2(a.x*Math.sin(l),k*this.coslat0*Math.cos(l)-a.y*this.sinlat0*Math.sin(l))),a.x=b,a.y=c,a)}if(Math.abs(this.coslat0)<=e){if(e>=k)return c=this.lat0,b=this.long0,a.x=b,a.y=c,a;a.x*=this.con,a.y*=this.con,f=k*this.cons/(2*this.a*this.k0),c=this.con*i(this.e,f),b=this.con*j(this.con*this.long0+Math.atan2(a.x,-1*a.y))}else g=2*Math.atan(k*this.cosX0/(2*this.a*this.k0*this.ms1)),b=this.long0,e>=k?h=this.X0:(h=Math.asin(Math.cos(g)*this.sinX0+a.y*Math.sin(g)*this.cosX0/k),b=j(this.long0+Math.atan2(a.x*Math.sin(g),k*this.cosX0*Math.cos(g)-a.y*this.sinX0*Math.sin(g)))),c=-1*i(this.e,Math.tan(.5*(d+h)));return a.x=b,a.y=c,a},c.names=["stere"]},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/sign":21,"../common/tsfnz":24}],60:[function(a,b,c){var d=a("./gauss"),e=a("../common/adjust_lon");c.init=function(){d.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))},c.forward=function(a){var b,c,f,g;return a.x=e(a.x-this.long0),d.forward.apply(this,[a]),b=Math.sin(a.y),c=Math.cos(a.y),f=Math.cos(a.x),g=this.k0*this.R2/(1+this.sinc0*b+this.cosc0*c*f),a.x=g*c*Math.sin(a.x),a.y=g*(this.cosc0*b-this.sinc0*c*f),a.x=this.a*a.x+this.x0,a.y=this.a*a.y+this.y0,a},c.inverse=function(a){var b,c,f,g,h;if(a.x=(a.x-this.x0)/this.a,a.y=(a.y-this.y0)/this.a,a.x/=this.k0,a.y/=this.k0,h=Math.sqrt(a.x*a.x+a.y*a.y)){var i=2*Math.atan2(h,this.R2);b=Math.sin(i),c=Math.cos(i),g=Math.asin(c*this.sinc0+a.y*b*this.cosc0/h),f=Math.atan2(a.x*b,h*this.cosc0*c-a.y*this.sinc0*b)}else g=this.phic0,f=0;return a.x=f,a.y=g,d.inverse.apply(this,[a]),a.x=e(a.x+this.long0),a},c.names=["Stereographic_North_Pole","Oblique_Stereographic","Polar_Stereographic","sterea","Oblique Stereographic Alternative"]},{"../common/adjust_lon":5,"./gauss":45}],61:[function(a,b,c){var d=a("../common/e0fn"),e=a("../common/e1fn"),f=a("../common/e2fn"),g=a("../common/e3fn"),h=a("../common/mlfn"),i=a("../common/adjust_lon"),j=Math.PI/2,k=1e-10,l=a("../common/sign"),m=a("../common/asinz");c.init=function(){this.e0=d(this.es),this.e1=e(this.es),this.e2=f(this.es),this.e3=g(this.es),this.ml0=this.a*h(this.e0,this.e1,this.e2,this.e3,this.lat0)},c.forward=function(a){var b,c,d,e=a.x,f=a.y,g=i(e-this.long0),j=Math.sin(f),k=Math.cos(f);if(this.sphere){var l=k*Math.sin(g);if(Math.abs(Math.abs(l)-1)<1e-10)return 93;c=.5*this.a*this.k0*Math.log((1+l)/(1-l)),b=Math.acos(k*Math.cos(g)/Math.sqrt(1-l*l)),0>f&&(b=-b),d=this.a*this.k0*(b-this.lat0)}else{var m=k*g,n=Math.pow(m,2),o=this.ep2*Math.pow(k,2),p=Math.tan(f),q=Math.pow(p,2);b=1-this.es*Math.pow(j,2);var r=this.a/Math.sqrt(b),s=this.a*h(this.e0,this.e1,this.e2,this.e3,f);c=this.k0*r*m*(1+n/6*(1-q+o+n/20*(5-18*q+Math.pow(q,2)+72*o-58*this.ep2)))+this.x0,d=this.k0*(s-this.ml0+r*p*n*(.5+n/24*(5-q+9*o+4*Math.pow(o,2)+n/30*(61-58*q+Math.pow(q,2)+600*o-330*this.ep2))))+this.y0}return a.x=c,a.y=d,a},c.inverse=function(a){var b,c,d,e,f,g,h=6;if(this.sphere){var n=Math.exp(a.x/(this.a*this.k0)),o=.5*(n-1/n),p=this.lat0+a.y/(this.a*this.k0),q=Math.cos(p);b=Math.sqrt((1-q*q)/(1+o*o)),f=m(b),0>p&&(f=-f),g=0===o&&0===q?this.long0:i(Math.atan2(o,q)+this.long0)}else{var r=a.x-this.x0,s=a.y-this.y0;for(b=(this.ml0+s/this.k0)/this.a,c=b,e=0;!0&&(d=(b+this.e1*Math.sin(2*c)-this.e2*Math.sin(4*c)+this.e3*Math.sin(6*c))/this.e0-c,c+=d,!(Math.abs(d)<=k));e++)if(e>=h)return 95;if(Math.abs(c)<j){var t=Math.sin(c),u=Math.cos(c),v=Math.tan(c),w=this.ep2*Math.pow(u,2),x=Math.pow(w,2),y=Math.pow(v,2),z=Math.pow(y,2);b=1-this.es*Math.pow(t,2);var A=this.a/Math.sqrt(b),B=A*(1-this.es)/b,C=r/(A*this.k0),D=Math.pow(C,2);f=c-A*v*D/B*(.5-D/24*(5+3*y+10*w-4*x-9*this.ep2-D/30*(61+90*y+298*w+45*z-252*this.ep2-3*x))),g=i(this.long0+C*(1-D/6*(1+2*y+w-D/20*(5-2*w+28*y-3*x+8*this.ep2+24*z)))/u)}else f=j*l(s),g=this.long0}return a.x=g,a.y=f,a},c.names=["Transverse_Mercator","Transverse Mercator","tmerc"]},{"../common/adjust_lon":5,"../common/asinz":6,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/mlfn":14,"../common/sign":21}],62:[function(a,b,c){var d=.017453292519943295,e=a("./tmerc");c.dependsOn="tmerc",c.init=function(){this.zone&&(this.lat0=0,this.long0=(6*Math.abs(this.zone)-183)*d,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,e.init.apply(this),this.forward=e.forward,this.inverse=e.inverse)},c.names=["Universal Transverse Mercator System","utm"]},{"./tmerc":61}],63:[function(a,b,c){var d=a("../common/adjust_lon"),e=Math.PI/2,f=1e-10,g=a("../common/asinz");c.init=function(){this.R=this.a},c.forward=function(a){var b,c,h=a.x,i=a.y,j=d(h-this.long0);Math.abs(i)<=f&&(b=this.x0+this.R*j,c=this.y0);var k=g(2*Math.abs(i/Math.PI));(Math.abs(j)<=f||Math.abs(Math.abs(i)-e)<=f)&&(b=this.x0,c=i>=0?this.y0+Math.PI*this.R*Math.tan(.5*k):this.y0+Math.PI*this.R*-Math.tan(.5*k));var l=.5*Math.abs(Math.PI/j-j/Math.PI),m=l*l,n=Math.sin(k),o=Math.cos(k),p=o/(n+o-1),q=p*p,r=p*(2/n-1),s=r*r,t=Math.PI*this.R*(l*(p-s)+Math.sqrt(m*(p-s)*(p-s)-(s+m)*(q-s)))/(s+m);0>j&&(t=-t),b=this.x0+t;var u=m+p;return t=Math.PI*this.R*(r*u-l*Math.sqrt((s+m)*(m+1)-u*u))/(s+m),c=i>=0?this.y0+t:this.y0-t,a.x=b,a.y=c,a},c.inverse=function(a){var b,c,e,g,h,i,j,k,l,m,n,o,p;return a.x-=this.x0,a.y-=this.y0,n=Math.PI*this.R,e=a.x/n,g=a.y/n,h=e*e+g*g,i=-Math.abs(g)*(1+h),j=i-2*g*g+e*e,k=-2*i+1+2*g*g+h*h,p=g*g/k+(2*j*j*j/k/k/k-9*i*j/k/k)/27,l=(i-j*j/3/k)/k,m=2*Math.sqrt(-l/3),n=3*p/l/m,Math.abs(n)>1&&(n=n>=0?1:-1),o=Math.acos(n)/3,c=a.y>=0?(-m*Math.cos(o+Math.PI/3)-j/3/k)*Math.PI:-(-m*Math.cos(o+Math.PI/3)-j/3/k)*Math.PI,b=Math.abs(e)<f?this.long0:d(this.long0+Math.PI*(h-1+Math.sqrt(1+2*(e*e-g*g)+h*h))/2/e),a.x=b,a.y=c,a},c.names=["Van_der_Grinten_I","VanDerGrinten","vandg"]},{"../common/adjust_lon":5,"../common/asinz":6}],64:[function(a,b){var c=.017453292519943295,d=57.29577951308232,e=1,f=2,g=a("./datum_transform"),h=a("./adjust_axis"),i=a("./Proj"),j=a("./common/toPoint");b.exports=function k(a,b,l){function m(a,b){return(a.datum.datum_type===e||a.datum.datum_type===f)&&"WGS84"!==b.datumCode}var n;return Array.isArray(l)&&(l=j(l)),a.datum&&b.datum&&(m(a,b)||m(b,a))&&(n=new i("WGS84"),k(a,n,l),a=n),"enu"!==a.axis&&h(a,!1,l),"longlat"===a.projName?(l.x*=c,l.y*=c):(a.to_meter&&(l.x*=a.to_meter,l.y*=a.to_meter),a.inverse(l)),a.from_greenwich&&(l.x+=a.from_greenwich),l=g(a.datum,b.datum,l),b.from_greenwich&&(l.x-=b.from_greenwich),"longlat"===b.projName?(l.x*=d,l.y*=d):(b.forward(l),b.to_meter&&(l.x/=b.to_meter,l.y/=b.to_meter)),"enu"!==b.axis&&h(b,!0,l),l}},{"./Proj":2,"./adjust_axis":3,"./common/toPoint":23,"./datum_transform":30}],65:[function(a,b){function c(a,b,c){a[b]=c.map(function(a){var b={};return d(a,b),b}).reduce(function(a,b){return i(a,b)},{})}function d(a,b){var e;return Array.isArray(a)?(e=a.shift(),"PARAMETER"===e&&(e=a.shift()),1===a.length?Array.isArray(a[0])?(b[e]={},d(a[0],b[e])):b[e]=a[0]:a.length?"TOWGS84"===e?b[e]=a:(b[e]={},["UNIT","PRIMEM","VERT_DATUM"].indexOf(e)>-1?(b[e]={name:a[0].toLowerCase(),convert:a[1]},3===a.length&&(b[e].auth=a[2])):"SPHEROID"===e?(b[e]={name:a[0],a:a[1],rf:a[2]},4===a.length&&(b[e].auth=a[3])):["GEOGCS","GEOCCS","DATUM","VERT_CS","COMPD_CS","LOCAL_CS","FITTED_CS","LOCAL_DATUM"].indexOf(e)>-1?(a[0]=["name",a[0]],c(b,e,a)):a.every(function(a){return Array.isArray(a)})?c(b,e,a):d(a,b[e])):b[e]=!0,void 0):void(b[a]=!0)}function e(a,b){var c=b[0],d=b[1];!(c in a)&&d in a&&(a[c]=a[d],3===b.length&&(a[c]=b[2](a[c])))}function f(a){return a*h}function g(a){function b(b){var c=a.to_meter||1;return parseFloat(b,10)*c}"GEOGCS"===a.type?a.projName="longlat":"LOCAL_CS"===a.type?(a.projName="identity",a.local=!0):a.projName="object"==typeof a.PROJECTION?Object.keys(a.PROJECTION)[0]:a.PROJECTION,a.UNIT&&(a.units=a.UNIT.name.toLowerCase(),"metre"===a.units&&(a.units="meter"),a.UNIT.convert&&(a.to_meter=parseFloat(a.UNIT.convert,10))),a.GEOGCS&&(a.datumCode=a.GEOGCS.DATUM?a.GEOGCS.DATUM.name.toLowerCase():a.GEOGCS.name.toLowerCase(),"d_"===a.datumCode.slice(0,2)&&(a.datumCode=a.datumCode.slice(2)),("new_zealand_geodetic_datum_1949"===a.datumCode||"new_zealand_1949"===a.datumCode)&&(a.datumCode="nzgd49"),"wgs_1984"===a.datumCode&&("Mercator_Auxiliary_Sphere"===a.PROJECTION&&(a.sphere=!0),a.datumCode="wgs84"),"_ferro"===a.datumCode.slice(-6)&&(a.datumCode=a.datumCode.slice(0,-6)),"_jakarta"===a.datumCode.slice(-8)&&(a.datumCode=a.datumCode.slice(0,-8)),~a.datumCode.indexOf("belge")&&(a.datumCode="rnb72"),a.GEOGCS.DATUM&&a.GEOGCS.DATUM.SPHEROID&&(a.ellps=a.GEOGCS.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===a.ellps.toLowerCase().slice(0,13)&&(a.ellps="intl"),a.a=a.GEOGCS.DATUM.SPHEROID.a,a.rf=parseFloat(a.GEOGCS.DATUM.SPHEROID.rf,10)),~a.datumCode.indexOf("osgb_1936")&&(a.datumCode="osgb36")),a.b&&!isFinite(a.b)&&(a.b=a.a);
var c=function(b){return e(a,b)},d=[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_2","Standard_Parallel_2"],["false_easting","False_Easting"],["false_northing","False_Northing"],["central_meridian","Central_Meridian"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",f],["longitude_of_center","Longitude_Of_Center"],["longc","longitude_of_center",f],["x0","false_easting",b],["y0","false_northing",b],["long0","central_meridian",f],["lat0","latitude_of_origin",f],["lat0","standard_parallel_1",f],["lat1","standard_parallel_1",f],["lat2","standard_parallel_2",f],["alpha","azimuth",f],["srsCode","name"]];d.forEach(c),a.long0||!a.longc||"Albers_Conic_Equal_Area"!==a.PROJECTION&&"Lambert_Azimuthal_Equal_Area"!==a.PROJECTION||(a.long0=a.longc)}var h=.017453292519943295,i=a("./extend");b.exports=function(a,b){var c=JSON.parse((","+a).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g,',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g,',"$1"]').replace(/,\["VERTCS".+/,"")),e=c.shift(),f=c.shift();c.unshift(["name",f]),c.unshift(["type",e]),c.unshift("output");var h={};return d(c,h),g(h.output),i(b,h.output)}},{"./extend":33}],66:[function(a,b,c){function d(a){return a*(Math.PI/180)}function e(a){return 180*(a/Math.PI)}function f(a){var b,c,e,f,g,i,j,k,l,m=a.lat,n=a.lon,o=6378137,p=.00669438,q=.9996,r=d(m),s=d(n);l=Math.floor((n+180)/6)+1,180===n&&(l=60),m>=56&&64>m&&n>=3&&12>n&&(l=32),m>=72&&84>m&&(n>=0&&9>n?l=31:n>=9&&21>n?l=33:n>=21&&33>n?l=35:n>=33&&42>n&&(l=37)),b=6*(l-1)-180+3,k=d(b),c=p/(1-p),e=o/Math.sqrt(1-p*Math.sin(r)*Math.sin(r)),f=Math.tan(r)*Math.tan(r),g=c*Math.cos(r)*Math.cos(r),i=Math.cos(r)*(s-k),j=o*((1-p/4-3*p*p/64-5*p*p*p/256)*r-(3*p/8+3*p*p/32+45*p*p*p/1024)*Math.sin(2*r)+(15*p*p/256+45*p*p*p/1024)*Math.sin(4*r)-35*p*p*p/3072*Math.sin(6*r));var t=q*e*(i+(1-f+g)*i*i*i/6+(5-18*f+f*f+72*g-58*c)*i*i*i*i*i/120)+5e5,u=q*(j+e*Math.tan(r)*(i*i/2+(5-f+9*g+4*g*g)*i*i*i*i/24+(61-58*f+f*f+600*g-330*c)*i*i*i*i*i*i/720));return 0>m&&(u+=1e7),{northing:Math.round(u),easting:Math.round(t),zoneNumber:l,zoneLetter:h(m)}}function g(a){var b=a.northing,c=a.easting,d=a.zoneLetter,f=a.zoneNumber;if(0>f||f>60)return null;var h,i,j,k,l,m,n,o,p,q,r=.9996,s=6378137,t=.00669438,u=(1-Math.sqrt(1-t))/(1+Math.sqrt(1-t)),v=c-5e5,w=b;"N">d&&(w-=1e7),o=6*(f-1)-180+3,h=t/(1-t),n=w/r,p=n/(s*(1-t/4-3*t*t/64-5*t*t*t/256)),q=p+(3*u/2-27*u*u*u/32)*Math.sin(2*p)+(21*u*u/16-55*u*u*u*u/32)*Math.sin(4*p)+151*u*u*u/96*Math.sin(6*p),i=s/Math.sqrt(1-t*Math.sin(q)*Math.sin(q)),j=Math.tan(q)*Math.tan(q),k=h*Math.cos(q)*Math.cos(q),l=s*(1-t)/Math.pow(1-t*Math.sin(q)*Math.sin(q),1.5),m=v/(i*r);var x=q-i*Math.tan(q)/l*(m*m/2-(5+3*j+10*k-4*k*k-9*h)*m*m*m*m/24+(61+90*j+298*k+45*j*j-252*h-3*k*k)*m*m*m*m*m*m/720);x=e(x);var y=(m-(1+2*j+k)*m*m*m/6+(5-2*k+28*j-3*k*k+8*h+24*j*j)*m*m*m*m*m/120)/Math.cos(q);y=o+e(y);var z;if(a.accuracy){var A=g({northing:a.northing+a.accuracy,easting:a.easting+a.accuracy,zoneLetter:a.zoneLetter,zoneNumber:a.zoneNumber});z={top:A.lat,right:A.lon,bottom:x,left:y}}else z={lat:x,lon:y};return z}function h(a){var b="Z";return 84>=a&&a>=72?b="X":72>a&&a>=64?b="W":64>a&&a>=56?b="V":56>a&&a>=48?b="U":48>a&&a>=40?b="T":40>a&&a>=32?b="S":32>a&&a>=24?b="R":24>a&&a>=16?b="Q":16>a&&a>=8?b="P":8>a&&a>=0?b="N":0>a&&a>=-8?b="M":-8>a&&a>=-16?b="L":-16>a&&a>=-24?b="K":-24>a&&a>=-32?b="J":-32>a&&a>=-40?b="H":-40>a&&a>=-48?b="G":-48>a&&a>=-56?b="F":-56>a&&a>=-64?b="E":-64>a&&a>=-72?b="D":-72>a&&a>=-80&&(b="C"),b}function i(a,b){var c=""+a.easting,d=""+a.northing;return a.zoneNumber+a.zoneLetter+j(a.easting,a.northing,a.zoneNumber)+c.substr(c.length-5,b)+d.substr(d.length-5,b)}function j(a,b,c){var d=k(c),e=Math.floor(a/1e5),f=Math.floor(b/1e5)%20;return l(e,f,d)}function k(a){var b=a%q;return 0===b&&(b=q),b}function l(a,b,c){var d=c-1,e=r.charCodeAt(d),f=s.charCodeAt(d),g=e+a-1,h=f+b,i=!1;g>x&&(g=g-x+t-1,i=!0),(g===u||u>e&&g>u||(g>u||u>e)&&i)&&g++,(g===v||v>e&&g>v||(g>v||v>e)&&i)&&(g++,g===u&&g++),g>x&&(g=g-x+t-1),h>w?(h=h-w+t-1,i=!0):i=!1,(h===u||u>f&&h>u||(h>u||u>f)&&i)&&h++,(h===v||v>f&&h>v||(h>v||v>f)&&i)&&(h++,h===u&&h++),h>w&&(h=h-w+t-1);var j=String.fromCharCode(g)+String.fromCharCode(h);return j}function m(a){if(a&&0===a.length)throw"MGRSPoint coverting from nothing";for(var b,c=a.length,d=null,e="",f=0;!/[A-Z]/.test(b=a.charAt(f));){if(f>=2)throw"MGRSPoint bad conversion from: "+a;e+=b,f++}var g=parseInt(e,10);if(0===f||f+3>c)throw"MGRSPoint bad conversion from: "+a;var h=a.charAt(f++);if("A">=h||"B"===h||"Y"===h||h>="Z"||"I"===h||"O"===h)throw"MGRSPoint zone letter "+h+" not handled: "+a;d=a.substring(f,f+=2);for(var i=k(g),j=n(d.charAt(0),i),l=o(d.charAt(1),i);l<p(h);)l+=2e6;var m=c-f;if(m%2!==0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+a;var q,r,s,t,u,v=m/2,w=0,x=0;return v>0&&(q=1e5/Math.pow(10,v),r=a.substring(f,f+v),w=parseFloat(r)*q,s=a.substring(f+v),x=parseFloat(s)*q),t=w+j,u=x+l,{easting:t,northing:u,zoneLetter:h,zoneNumber:g,accuracy:q}}function n(a,b){for(var c=r.charCodeAt(b-1),d=1e5,e=!1;c!==a.charCodeAt(0);){if(c++,c===u&&c++,c===v&&c++,c>x){if(e)throw"Bad character: "+a;c=t,e=!0}d+=1e5}return d}function o(a,b){if(a>"V")throw"MGRSPoint given invalid Northing "+a;for(var c=s.charCodeAt(b-1),d=0,e=!1;c!==a.charCodeAt(0);){if(c++,c===u&&c++,c===v&&c++,c>w){if(e)throw"Bad character: "+a;c=t,e=!0}d+=1e5}return d}function p(a){var b;switch(a){case"C":b=11e5;break;case"D":b=2e6;break;case"E":b=28e5;break;case"F":b=37e5;break;case"G":b=46e5;break;case"H":b=55e5;break;case"J":b=64e5;break;case"K":b=73e5;break;case"L":b=82e5;break;case"M":b=91e5;break;case"N":b=0;break;case"P":b=8e5;break;case"Q":b=17e5;break;case"R":b=26e5;break;case"S":b=35e5;break;case"T":b=44e5;break;case"U":b=53e5;break;case"V":b=62e5;break;case"W":b=7e6;break;case"X":b=79e5;break;default:b=-1}if(b>=0)return b;throw"Invalid zone letter: "+a}var q=6,r="AJSAJS",s="AFAFAF",t=65,u=73,v=79,w=86,x=90;c.forward=function(a,b){return b=b||5,i(f({lat:a[1],lon:a[0]}),b)},c.inverse=function(a){var b=g(m(a.toUpperCase()));return[b.left,b.bottom,b.right,b.top]},c.toPoint=function(a){var b=c.inverse(a);return[(b[2]+b[0])/2,(b[3]+b[1])/2]}},{}],67:[function(a,b){b.exports={name:"proj4",version:"2.3.3",description:"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",main:"lib/index.js",directories:{test:"test",doc:"docs"},scripts:{test:"./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"},repository:{type:"git",url:"git://github.com/proj4js/proj4js.git"},author:"",license:"MIT",jam:{main:"dist/proj4.js",include:["dist/proj4.js","README.md","AUTHORS","LICENSE.md"]},devDependencies:{"grunt-cli":"~0.1.13",grunt:"~0.4.2","grunt-contrib-connect":"~0.6.0","grunt-contrib-jshint":"~0.8.0",chai:"~1.8.1",mocha:"~1.17.1","grunt-mocha-phantomjs":"~0.4.0",browserify:"~3.24.5","grunt-browserify":"~1.3.0","grunt-contrib-uglify":"~0.3.2",curl:"git://github.com/cujojs/curl.git",istanbul:"~0.2.4",tin:"~0.4.0"},dependencies:{mgrs:"0.0.0"}}},{}],"./includedProjections":[function(a,b){b.exports=a("gWUPNW")},{}],gWUPNW:[function(a,b){var c=[a("./lib/projections/tmerc"),a("./lib/projections/utm"),a("./lib/projections/sterea"),a("./lib/projections/stere"),a("./lib/projections/somerc"),a("./lib/projections/omerc"),a("./lib/projections/lcc"),a("./lib/projections/krovak"),a("./lib/projections/cass"),a("./lib/projections/laea"),a("./lib/projections/aea"),a("./lib/projections/gnom"),a("./lib/projections/cea"),a("./lib/projections/eqc"),a("./lib/projections/poly"),a("./lib/projections/nzmg"),a("./lib/projections/mill"),a("./lib/projections/sinu"),a("./lib/projections/moll"),a("./lib/projections/eqdc"),a("./lib/projections/vandg"),a("./lib/projections/aeqd")];b.exports=function(proj4){c.forEach(function(a){proj4.Proj.projections.add(a)})}},{"./lib/projections/aea":39,"./lib/projections/aeqd":40,"./lib/projections/cass":41,"./lib/projections/cea":42,"./lib/projections/eqc":43,"./lib/projections/eqdc":44,"./lib/projections/gnom":46,"./lib/projections/krovak":47,"./lib/projections/laea":48,"./lib/projections/lcc":49,"./lib/projections/mill":52,"./lib/projections/moll":53,"./lib/projections/nzmg":54,"./lib/projections/omerc":55,"./lib/projections/poly":56,"./lib/projections/sinu":57,"./lib/projections/somerc":58,"./lib/projections/stere":59,"./lib/projections/sterea":60,"./lib/projections/tmerc":61,"./lib/projections/utm":62,"./lib/projections/vandg":63}]},{},[35])(35)});/*! poly2tri v1.3.5 | (c) 2009-2014 Poly2Tri Contributors */
!function(t){if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else{var n;"undefined"!=typeof window?n=window:"undefined"!=typeof global?n=global:"undefined"!=typeof self&&(n=self),n.poly2tri=t()}}(function(){return function t(n,e,i){function o(s,p){if(!e[s]){if(!n[s]){var a="function"==typeof require&&require;if(!p&&a)return a(s,!0);if(r)return r(s,!0);throw new Error("Cannot find module '"+s+"'")}var h=e[s]={exports:{}};n[s][0].call(h.exports,function(t){var e=n[s][1][t];return o(e?e:t)},h,h.exports,t,n,e,i)}return e[s].exports}for(var r="function"==typeof require&&require,s=0;s<i.length;s++)o(i[s]);return o}({1:[function(t,n){n.exports={version:"1.3.5"}},{}],2:[function(t,n){"use strict";var e=function(t,n){this.point=t,this.triangle=n||null,this.next=null,this.prev=null,this.value=t.x},i=function(t,n){this.head_=t,this.tail_=n,this.search_node_=t};i.prototype.head=function(){return this.head_},i.prototype.setHead=function(t){this.head_=t},i.prototype.tail=function(){return this.tail_},i.prototype.setTail=function(t){this.tail_=t},i.prototype.search=function(){return this.search_node_},i.prototype.setSearch=function(t){this.search_node_=t},i.prototype.findSearchNode=function(){return this.search_node_},i.prototype.locateNode=function(t){var n=this.search_node_;if(t<n.value){for(;n=n.prev;)if(t>=n.value)return this.search_node_=n,n}else for(;n=n.next;)if(t<n.value)return this.search_node_=n.prev,n.prev;return null},i.prototype.locatePoint=function(t){var n=t.x,e=this.findSearchNode(n),i=e.point.x;if(n===i){if(t!==e.point)if(t===e.prev.point)e=e.prev;else{if(t!==e.next.point)throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");e=e.next}}else if(i>n)for(;(e=e.prev)&&t!==e.point;);else for(;(e=e.next)&&t!==e.point;);return e&&(this.search_node_=e),e},n.exports=i,n.exports.Node=e},{}],3:[function(t,n){"use strict";function e(t,n){if(!t)throw new Error(n||"Assert Failed")}n.exports=e},{}],4:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n){this.x=+t||0,this.y=+n||0,this._p2t_edge_list=null};i.prototype.toString=function(){return e.toStringBase(this)},i.prototype.toJSON=function(){return{x:this.x,y:this.y}},i.prototype.clone=function(){return new i(this.x,this.y)},i.prototype.set_zero=function(){return this.x=0,this.y=0,this},i.prototype.set=function(t,n){return this.x=+t||0,this.y=+n||0,this},i.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},i.prototype.add=function(t){return this.x+=t.x,this.y+=t.y,this},i.prototype.sub=function(t){return this.x-=t.x,this.y-=t.y,this},i.prototype.mul=function(t){return this.x*=t,this.y*=t,this},i.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},i.prototype.normalize=function(){var t=this.length();return this.x/=t,this.y/=t,t},i.prototype.equals=function(t){return this.x===t.x&&this.y===t.y},i.negate=function(t){return new i(-t.x,-t.y)},i.add=function(t,n){return new i(t.x+n.x,t.y+n.y)},i.sub=function(t,n){return new i(t.x-n.x,t.y-n.y)},i.mul=function(t,n){return new i(t*n.x,t*n.y)},i.cross=function(t,n){return"number"==typeof t?"number"==typeof n?t*n:new i(-t*n.y,t*n.x):"number"==typeof n?new i(n*t.y,-n*t.x):t.x*n.y-t.y*n.x},i.toString=e.toString,i.compare=e.compare,i.cmp=e.compare,i.equals=e.equals,i.dot=function(t,n){return t.x*n.x+t.y*n.y},n.exports=i},{"./xy":11}],5:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n){this.name="PointError",this.points=n=n||[],this.message=t||"Invalid Points!";for(var i=0;i<n.length;i++)this.message+=" "+e.toString(n[i])};i.prototype=new Error,i.prototype.constructor=i,n.exports=i},{"./xy":11}],6:[function(t,n,e){(function(n){"use strict";var i=n.poly2tri;e.noConflict=function(){return n.poly2tri=i,e},e.VERSION=t("../dist/version.json").version,e.PointError=t("./pointerror"),e.Point=t("./point"),e.Triangle=t("./triangle"),e.SweepContext=t("./sweepcontext");var o=t("./sweep");e.triangulate=o.triangulate,e.sweep={Triangulate:o.triangulate}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(t,n,e){"use strict";function i(t){t.initTriangulation(),t.createAdvancingFront(),o(t),r(t)}function o(t){var n,e=t.pointCount();for(n=1;e>n;++n)for(var i=t.getPoint(n),o=s(t,i),r=i._p2t_edge_list,a=0;r&&a<r.length;++a)p(t,r[a],o)}function r(t){for(var n=t.front().head().next.triangle,e=t.front().head().next.point;!n.getConstrainedEdgeCW(e);)n=n.neighborCCW(e);t.meshClean(n)}function s(t,n){var e=t.locateNode(n),i=u(t,n,e);return n.x<=e.point.x+F&&d(t,e),g(t,i),i}function p(t,n,e){t.edge_event.constrained_edge=n,t.edge_event.right=n.p.x>n.q.x,h(e.triangle,n.p,n.q)||(C(t,n,e),a(t,n.p,n.q,e.triangle,n.q))}function a(t,n,e,i,o){if(!h(i,n,e)){var r=i.pointCCW(o),s=z(e,r,n);if(s===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,r,n]);var p=i.pointCW(o),u=z(e,p,n);if(u===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,p,n]);s===u?(i=s===M.CW?i.neighborCCW(o):i.neighborCW(o),a(t,n,e,i,o)):q(t,n,e,i,o)}}function h(t,n,e){var i=t.edgeIndex(n,e);if(-1!==i){t.markConstrainedEdgeByIndex(i);var o=t.getNeighbor(i);return o&&o.markConstrainedEdgeByPoints(n,e),!0}return!1}function u(t,n,e){var i=new O(n,e.point,e.next.point);i.markNeighbor(e.triangle),t.addToMap(i);var o=new B(n);return o.next=e.next,o.prev=e,e.next.prev=o,e.next=o,l(t,i)||t.mapTriangleToNodes(i),o}function d(t,n){var e=new O(n.prev.point,n.point,n.next.point);e.markNeighbor(n.prev.triangle),e.markNeighbor(n.triangle),t.addToMap(e),n.prev.next=n.next,n.next.prev=n.prev,l(t,e)||t.mapTriangleToNodes(e)}function g(t,n){for(var e=n.next;e.next&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.next;for(e=n.prev;e.prev&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.prev;n.next&&n.next.next&&f(n)&&y(t,n)}function f(t){var n=t.point.x-t.next.next.point.x,e=t.point.y-t.next.next.point.y;return S(e>=0,"unordered y"),n>=0||Math.abs(n)<e}function l(t,n){for(var e=0;3>e;++e)if(!n.delaunay_edge[e]){var i=n.getNeighbor(e);if(i){var o=n.getPoint(e),r=i.oppositePoint(n,o),s=i.index(r);if(i.constrained_edge[s]||i.delaunay_edge[s]){n.constrained_edge[e]=i.constrained_edge[s];continue}var p=c(o,n.pointCCW(o),n.pointCW(o),r);if(p){n.delaunay_edge[e]=!0,i.delaunay_edge[s]=!0,_(n,o,i,r);var a=!l(t,n);return a&&t.mapTriangleToNodes(n),a=!l(t,i),a&&t.mapTriangleToNodes(i),n.delaunay_edge[e]=!1,i.delaunay_edge[s]=!1,!0}}}return!1}function c(t,n,e,i){var o=t.x-i.x,r=t.y-i.y,s=n.x-i.x,p=n.y-i.y,a=o*p,h=s*r,u=a-h;if(0>=u)return!1;var d=e.x-i.x,g=e.y-i.y,f=d*r,l=o*g,c=f-l;if(0>=c)return!1;var _=s*g,y=d*p,x=o*o+r*r,v=s*s+p*p,C=d*d+g*g,b=x*(_-y)+v*c+C*u;return b>0}function _(t,n,e,i){var o,r,s,p;o=t.neighborCCW(n),r=t.neighborCW(n),s=e.neighborCCW(i),p=e.neighborCW(i);var a,h,u,d;a=t.getConstrainedEdgeCCW(n),h=t.getConstrainedEdgeCW(n),u=e.getConstrainedEdgeCCW(i),d=e.getConstrainedEdgeCW(i);var g,f,l,c;g=t.getDelaunayEdgeCCW(n),f=t.getDelaunayEdgeCW(n),l=e.getDelaunayEdgeCCW(i),c=e.getDelaunayEdgeCW(i),t.legalize(n,i),e.legalize(i,n),e.setDelaunayEdgeCCW(n,g),t.setDelaunayEdgeCW(n,f),t.setDelaunayEdgeCCW(i,l),e.setDelaunayEdgeCW(i,c),e.setConstrainedEdgeCCW(n,a),t.setConstrainedEdgeCW(n,h),t.setConstrainedEdgeCCW(i,u),e.setConstrainedEdgeCW(i,d),t.clearNeighbors(),e.clearNeighbors(),o&&e.markNeighbor(o),r&&t.markNeighbor(r),s&&t.markNeighbor(s),p&&e.markNeighbor(p),t.markNeighbor(e)}function y(t,n){for(t.basin.left_node=z(n.point,n.next.point,n.next.next.point)===M.CCW?n.next.next:n.next,t.basin.bottom_node=t.basin.left_node;t.basin.bottom_node.next&&t.basin.bottom_node.point.y>=t.basin.bottom_node.next.point.y;)t.basin.bottom_node=t.basin.bottom_node.next;if(t.basin.bottom_node!==t.basin.left_node){for(t.basin.right_node=t.basin.bottom_node;t.basin.right_node.next&&t.basin.right_node.point.y<t.basin.right_node.next.point.y;)t.basin.right_node=t.basin.right_node.next;t.basin.right_node!==t.basin.bottom_node&&(t.basin.width=t.basin.right_node.point.x-t.basin.left_node.point.x,t.basin.left_highest=t.basin.left_node.point.y>t.basin.right_node.point.y,x(t,t.basin.bottom_node))}}function x(t,n){if(!v(t,n)){d(t,n);var e;if(n.prev!==t.basin.left_node||n.next!==t.basin.right_node){if(n.prev===t.basin.left_node){if(e=z(n.point,n.next.point,n.next.next.point),e===M.CW)return;n=n.next}else if(n.next===t.basin.right_node){if(e=z(n.point,n.prev.point,n.prev.prev.point),e===M.CCW)return;n=n.prev}else n=n.prev.point.y<n.next.point.y?n.prev:n.next;x(t,n)}}}function v(t,n){var e;return e=t.basin.left_highest?t.basin.left_node.point.y-n.point.y:t.basin.right_node.point.y-n.point.y,t.basin.width>e?!0:!1}function C(t,n,e){t.edge_event.right?b(t,n,e):E(t,n,e)}function b(t,n,e){for(;e.next.point.x<n.p.x;)z(n.q,e.next.point,n.p)===M.CCW?m(t,n,e):e=e.next}function m(t,n,e){e.point.x<n.p.x&&(z(e.point,e.next.point,e.next.next.point)===M.CCW?W(t,n,e):(w(t,n,e),m(t,n,e)))}function W(t,n,e){d(t,e.next),e.next.point!==n.p&&z(n.q,e.next.point,n.p)===M.CCW&&z(e.point,e.next.point,e.next.next.point)===M.CCW&&W(t,n,e)}function w(t,n,e){z(e.next.point,e.next.next.point,e.next.next.next.point)===M.CCW?W(t,n,e.next):z(n.q,e.next.next.point,n.p)===M.CCW&&w(t,n,e.next)}function E(t,n,e){for(;e.prev.point.x>n.p.x;)z(n.q,e.prev.point,n.p)===M.CW?P(t,n,e):e=e.prev}function P(t,n,e){e.point.x>n.p.x&&(z(e.point,e.prev.point,e.prev.prev.point)===M.CW?T(t,n,e):(N(t,n,e),P(t,n,e)))}function N(t,n,e){z(e.prev.point,e.prev.prev.point,e.prev.prev.prev.point)===M.CW?T(t,n,e.prev):z(n.q,e.prev.prev.point,n.p)===M.CW&&N(t,n,e.prev)}function T(t,n,e){d(t,e.prev),e.prev.point!==n.p&&z(n.q,e.prev.point,n.p)===M.CW&&z(e.point,e.prev.point,e.prev.prev.point)===M.CW&&T(t,n,e)}function q(t,n,e,i,o){var r=i.neighborAcross(o);S(r,"FLIP failed due to missing triangle!");var s=r.oppositePoint(i,o);if(i.getConstrainedEdgeAcross(o)){var p=i.index(o);throw new D("poly2tri Intersecting Constraints",[o,s,i.getPoint((p+1)%3),i.getPoint((p+2)%3)])}if(H(o,i.pointCCW(o),i.pointCW(o),s))if(_(i,o,r,s),t.mapTriangleToNodes(i),t.mapTriangleToNodes(r),o===e&&s===n)e===t.edge_event.constrained_edge.q&&n===t.edge_event.constrained_edge.p&&(i.markConstrainedEdgeByPoints(n,e),r.markConstrainedEdgeByPoints(n,e),l(t,i),l(t,r));else{var h=z(e,s,n);i=I(t,h,i,r,o,s),q(t,n,e,i,o)}else{var u=k(n,e,r,s);A(t,n,e,i,r,u),a(t,n,e,i,o)}}function I(t,n,e,i,o,r){var s;return n===M.CCW?(s=i.edgeIndex(o,r),i.delaunay_edge[s]=!0,l(t,i),i.clearDelaunayEdges(),e):(s=e.edgeIndex(o,r),e.delaunay_edge[s]=!0,l(t,e),e.clearDelaunayEdges(),i)}function k(t,n,e,i){var o=z(n,i,t);if(o===M.CW)return e.pointCCW(i);if(o===M.CCW)return e.pointCW(i);throw new D("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[n,i,t])}function A(t,n,e,i,o,r){var s=o.neighborAcross(r);S(s,"FLIP failed due to missing triangle");var p=s.oppositePoint(o,r);if(H(e,i.pointCCW(e),i.pointCW(e),p))q(t,e,p,s,p);else{var a=k(n,e,s,p);A(t,n,e,i,s,a)}}var S=t("./assert"),D=t("./pointerror"),O=t("./triangle"),B=t("./advancingfront").Node,L=t("./utils"),F=L.EPSILON,M=L.Orientation,z=L.orient2d,H=L.inScanArea,j=L.isAngleObtuse;e.triangulate=i},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(t,n){"use strict";var e=t("./pointerror"),i=t("./point"),o=t("./triangle"),r=t("./sweep"),s=t("./advancingfront"),p=s.Node,a=.3,h=function(t,n){if(this.p=t,this.q=n,t.y>n.y)this.q=t,this.p=n;else if(t.y===n.y)if(t.x>n.x)this.q=t,this.p=n;else if(t.x===n.x)throw new e("poly2tri Invalid Edge constructor: repeated points!",[t]);this.q._p2t_edge_list||(this.q._p2t_edge_list=[]),this.q._p2t_edge_list.push(this)},u=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};u.prototype.clear=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};var d=function(){this.constrained_edge=null,this.right=!1},g=function(t,n){n=n||{},this.triangles_=[],this.map_=[],this.points_=n.cloneArrays?t.slice(0):t,this.edge_list=[],this.pmin_=this.pmax_=null,this.front_=null,this.head_=null,this.tail_=null,this.af_head_=null,this.af_middle_=null,this.af_tail_=null,this.basin=new u,this.edge_event=new d,this.initEdges(this.points_)};g.prototype.addHole=function(t){this.initEdges(t);var n,e=t.length;for(n=0;e>n;n++)this.points_.push(t[n]);return this},g.prototype.AddHole=g.prototype.addHole,g.prototype.addHoles=function(t){var n,e=t.length;for(n=0;e>n;n++)this.initEdges(t[n]);return this.points_=this.points_.concat.apply(this.points_,t),this},g.prototype.addPoint=function(t){return this.points_.push(t),this},g.prototype.AddPoint=g.prototype.addPoint,g.prototype.addPoints=function(t){return this.points_=this.points_.concat(t),this},g.prototype.triangulate=function(){return r.triangulate(this),this},g.prototype.getBoundingBox=function(){return{min:this.pmin_,max:this.pmax_}},g.prototype.getTriangles=function(){return this.triangles_},g.prototype.GetTriangles=g.prototype.getTriangles,g.prototype.front=function(){return this.front_},g.prototype.pointCount=function(){return this.points_.length},g.prototype.head=function(){return this.head_},g.prototype.setHead=function(t){this.head_=t},g.prototype.tail=function(){return this.tail_},g.prototype.setTail=function(t){this.tail_=t},g.prototype.getMap=function(){return this.map_},g.prototype.initTriangulation=function(){var t,n=this.points_[0].x,e=this.points_[0].x,o=this.points_[0].y,r=this.points_[0].y,s=this.points_.length;for(t=1;s>t;t++){var p=this.points_[t];p.x>n&&(n=p.x),p.x<e&&(e=p.x),p.y>o&&(o=p.y),p.y<r&&(r=p.y)}this.pmin_=new i(e,r),this.pmax_=new i(n,o);var h=a*(n-e),u=a*(o-r);this.head_=new i(n+h,r-u),this.tail_=new i(e-h,r-u),this.points_.sort(i.compare)},g.prototype.initEdges=function(t){var n,e=t.length;for(n=0;e>n;++n)this.edge_list.push(new h(t[n],t[(n+1)%e]))},g.prototype.getPoint=function(t){return this.points_[t]},g.prototype.addToMap=function(t){this.map_.push(t)},g.prototype.locateNode=function(t){return this.front_.locateNode(t.x)},g.prototype.createAdvancingFront=function(){var t,n,e,i=new o(this.points_[0],this.tail_,this.head_);this.map_.push(i),t=new p(i.getPoint(1),i),n=new p(i.getPoint(0),i),e=new p(i.getPoint(2)),this.front_=new s(t,e),t.next=n,n.next=e,n.prev=t,e.prev=n},g.prototype.removeNode=function(){},g.prototype.mapTriangleToNodes=function(t){for(var n=0;3>n;++n)if(!t.getNeighbor(n)){var e=this.front_.locatePoint(t.pointCW(t.getPoint(n)));e&&(e.triangle=t)}},g.prototype.removeFromMap=function(t){var n,e=this.map_,i=e.length;for(n=0;i>n;n++)if(e[n]===t){e.splice(n,1);break}},g.prototype.meshClean=function(t){for(var n,e,i=[t];n=i.pop();)if(!n.isInterior())for(n.setInterior(!0),this.triangles_.push(n),e=0;3>e;e++)n.constrained_edge[e]||i.push(n.getNeighbor(e))},n.exports=g},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n,e){this.points_=[t,n,e],this.neighbors_=[null,null,null],this.interior_=!1,this.constrained_edge=[!1,!1,!1],this.delaunay_edge=[!1,!1,!1]},o=e.toString;i.prototype.toString=function(){return"["+o(this.points_[0])+o(this.points_[1])+o(this.points_[2])+"]"},i.prototype.getPoint=function(t){return this.points_[t]},i.prototype.GetPoint=i.prototype.getPoint,i.prototype.getPoints=function(){return this.points_},i.prototype.getNeighbor=function(t){return this.neighbors_[t]},i.prototype.containsPoint=function(t){var n=this.points_;return t===n[0]||t===n[1]||t===n[2]},i.prototype.containsEdge=function(t){return this.containsPoint(t.p)&&this.containsPoint(t.q)},i.prototype.containsPoints=function(t,n){return this.containsPoint(t)&&this.containsPoint(n)},i.prototype.isInterior=function(){return this.interior_},i.prototype.setInterior=function(t){return this.interior_=t,this},i.prototype.markNeighborPointers=function(t,n,e){var i=this.points_;if(t===i[2]&&n===i[1]||t===i[1]&&n===i[2])this.neighbors_[0]=e;else if(t===i[0]&&n===i[2]||t===i[2]&&n===i[0])this.neighbors_[1]=e;else{if(!(t===i[0]&&n===i[1]||t===i[1]&&n===i[0]))throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2]=e}},i.prototype.markNeighbor=function(t){var n=this.points_;t.containsPoints(n[1],n[2])?(this.neighbors_[0]=t,t.markNeighborPointers(n[1],n[2],this)):t.containsPoints(n[0],n[2])?(this.neighbors_[1]=t,t.markNeighborPointers(n[0],n[2],this)):t.containsPoints(n[0],n[1])&&(this.neighbors_[2]=t,t.markNeighborPointers(n[0],n[1],this))},i.prototype.clearNeighbors=function(){this.neighbors_[0]=null,this.neighbors_[1]=null,this.neighbors_[2]=null},i.prototype.clearDelaunayEdges=function(){this.delaunay_edge[0]=!1,this.delaunay_edge[1]=!1,this.delaunay_edge[2]=!1},i.prototype.pointCW=function(t){var n=this.points_;return t===n[0]?n[2]:t===n[1]?n[0]:t===n[2]?n[1]:null},i.prototype.pointCCW=function(t){var n=this.points_;return t===n[0]?n[1]:t===n[1]?n[2]:t===n[2]?n[0]:null},i.prototype.neighborCW=function(t){return t===this.points_[0]?this.neighbors_[1]:t===this.points_[1]?this.neighbors_[2]:this.neighbors_[0]},i.prototype.neighborCCW=function(t){return t===this.points_[0]?this.neighbors_[2]:t===this.points_[1]?this.neighbors_[0]:this.neighbors_[1]},i.prototype.getConstrainedEdgeCW=function(t){return t===this.points_[0]?this.constrained_edge[1]:t===this.points_[1]?this.constrained_edge[2]:this.constrained_edge[0]},i.prototype.getConstrainedEdgeCCW=function(t){return t===this.points_[0]?this.constrained_edge[2]:t===this.points_[1]?this.constrained_edge[0]:this.constrained_edge[1]},i.prototype.getConstrainedEdgeAcross=function(t){return t===this.points_[0]?this.constrained_edge[0]:t===this.points_[1]?this.constrained_edge[1]:this.constrained_edge[2]},i.prototype.setConstrainedEdgeCW=function(t,n){t===this.points_[0]?this.constrained_edge[1]=n:t===this.points_[1]?this.constrained_edge[2]=n:this.constrained_edge[0]=n},i.prototype.setConstrainedEdgeCCW=function(t,n){t===this.points_[0]?this.constrained_edge[2]=n:t===this.points_[1]?this.constrained_edge[0]=n:this.constrained_edge[1]=n},i.prototype.getDelaunayEdgeCW=function(t){return t===this.points_[0]?this.delaunay_edge[1]:t===this.points_[1]?this.delaunay_edge[2]:this.delaunay_edge[0]},i.prototype.getDelaunayEdgeCCW=function(t){return t===this.points_[0]?this.delaunay_edge[2]:t===this.points_[1]?this.delaunay_edge[0]:this.delaunay_edge[1]},i.prototype.setDelaunayEdgeCW=function(t,n){t===this.points_[0]?this.delaunay_edge[1]=n:t===this.points_[1]?this.delaunay_edge[2]=n:this.delaunay_edge[0]=n},i.prototype.setDelaunayEdgeCCW=function(t,n){t===this.points_[0]?this.delaunay_edge[2]=n:t===this.points_[1]?this.delaunay_edge[0]=n:this.delaunay_edge[1]=n},i.prototype.neighborAcross=function(t){return t===this.points_[0]?this.neighbors_[0]:t===this.points_[1]?this.neighbors_[1]:this.neighbors_[2]},i.prototype.oppositePoint=function(t,n){var e=t.pointCW(n);return this.pointCW(e)},i.prototype.legalize=function(t,n){var e=this.points_;if(t===e[0])e[1]=e[0],e[0]=e[2],e[2]=n;else if(t===e[1])e[2]=e[1],e[1]=e[0],e[0]=n;else{if(t!==e[2])throw new Error("poly2tri Invalid Triangle.legalize() call");e[0]=e[2],e[2]=e[1],e[1]=n}},i.prototype.index=function(t){var n=this.points_;if(t===n[0])return 0;if(t===n[1])return 1;if(t===n[2])return 2;throw new Error("poly2tri Invalid Triangle.index() call")},i.prototype.edgeIndex=function(t,n){var e=this.points_;if(t===e[0]){if(n===e[1])return 2;if(n===e[2])return 1}else if(t===e[1]){if(n===e[2])return 0;if(n===e[0])return 2}else if(t===e[2]){if(n===e[0])return 1;if(n===e[1])return 0}return-1},i.prototype.markConstrainedEdgeByIndex=function(t){this.constrained_edge[t]=!0},i.prototype.markConstrainedEdgeByEdge=function(t){this.markConstrainedEdgeByPoints(t.p,t.q)},i.prototype.markConstrainedEdgeByPoints=function(t,n){var e=this.points_;n===e[0]&&t===e[1]||n===e[1]&&t===e[0]?this.constrained_edge[2]=!0:n===e[0]&&t===e[2]||n===e[2]&&t===e[0]?this.constrained_edge[1]=!0:(n===e[1]&&t===e[2]||n===e[2]&&t===e[1])&&(this.constrained_edge[0]=!0)},n.exports=i},{"./xy":11}],10:[function(t,n,e){"use strict";function i(t,n,e){var i=(t.x-e.x)*(n.y-e.y),o=(t.y-e.y)*(n.x-e.x),r=i-o;return r>-s&&s>r?p.COLLINEAR:r>0?p.CCW:p.CW}function o(t,n,e,i){var o=(t.x-n.x)*(i.y-n.y)-(i.x-n.x)*(t.y-n.y);if(o>=-s)return!1;var r=(t.x-e.x)*(i.y-e.y)-(i.x-e.x)*(t.y-e.y);return s>=r?!1:!0}function r(t,n,e){var i=n.x-t.x,o=n.y-t.y,r=e.x-t.x,s=e.y-t.y;return 0>i*r+o*s}var s=1e-12;e.EPSILON=s;var p={CW:1,CCW:-1,COLLINEAR:0};e.Orientation=p,e.orient2d=i,e.inScanArea=o,e.isAngleObtuse=r},{}],11:[function(t,n){"use strict";function e(t){return"("+t.x+";"+t.y+")"}function i(t){var n=t.toString();return"[object Object]"===n?e(t):n}function o(t,n){return t.y===n.y?t.x-n.x:t.y-n.y}function r(t,n){return t.x===n.x&&t.y===n.y}n.exports={toString:i,toStringBase:e,compare:o,equals:r}},{}]},{},[6])(6)});/** @define {boolean} */
var VADSTENA_MERGE = true;

/** @define {boolean} */
var SEZNAMCZ = false;

var Vadstena = {};

//prevent minification
window["Vadstena"] = Vadstena;
window["ga"] = (window["ga"] != null) ? window["ga"] : {}; //google analytics
window["VadstenaMap_"] = (window["VadstenaMap_"] != null) ? window["VadstenaMap_"] : null;
window["Q"] = (window["Q"] != null) ? window["Q"] : {}; //google analytics


//demo
//cat init.js matrix.js math.js utility.js config.js bbox.js cache.js camera.js geometry.js gpuDevice.js gpuMesh.js gpuProgram.js gpuShaders.js gpuTexture.js gpuTile.js mesh.js metatile.js renderer.js tile.js tileid.js browser.js demo.js > minifiedViewer.js

//only lib
//cat init.js matrix.js math.js utility.js config.js bbox.js cache.js camera.js geometry.js gpuDevice.js gpuMesh.js gpuProgram.js gpuShaders.js gpuTexture.js gpuTile.js mesh.js metatile.js renderer.js tile.js tileid.js browser.js > minifiedViewer.js

//minify
//http://closure-compiler.appspot.com/home
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

// glMatrix v0.9.5
Vadstena.glMatrixArrayType2 = /*typeof Float32Array != "undefined" ? Float32Array : typeof WebGLFloatArray != "undefined" ? WebGLFloatArray :*/ Array;

Vadstena.vec2 = {};
Vadstena.vec2.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(2);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
    }
    return b;
};

Vadstena.vec4 = {};
Vadstena.vec4.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};
Vadstena.vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

Vadstena.vec3 = {};
Vadstena.vec3.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(3);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
    }
    return b;
};
Vadstena.vec3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    return b;
};
Vadstena.vec3.add = function (a, b, c) {
    if (!c || a == c) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
        return a;
    }
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
};
Vadstena.vec3.subtract = function (a, b, c) {
    if (!c || a == c) {
        a[0] -= b[0];
        a[1] -= b[1];
        a[2] -= b[2];
        return a;
    }
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
};
Vadstena.vec3.negate = function (a, b) {
    b || (b = a);
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    return b;
};
Vadstena.vec3.scale = function (a, b, c) {
    if (!c || a == c) {
        a[0] *= b;
        a[1] *= b;
        a[2] *= b;
        return a;
    }
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
};
Vadstena.vec3.normalize = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return b;
};
Vadstena.vec3.cross = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1];
    a = a[2];
    var g = b[0],
        f = b[1];
    b = b[2];
    c[0] = e * b - a * f;
    c[1] = a * g - d * b;
    c[2] = d * f - e * g;
    return c;
};
Vadstena.vec3.length = function (a) {
    var b = a[0],
        c = a[1];
    a = a[2];
    return Math.sqrt(b * b + c * c + a * a);
};
Vadstena.vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};
Vadstena.vec3.squareDistance = function (a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    var dz = b[2] - a[2];
    return dx*dx + dy*dy + dz*dz;
};
Vadstena.vec3.direction = function (a, b, c) {
    c || (c = a);
    var d = a[0] - b[0],
        e = a[1] - b[1];
    a = a[2] - b[2];
    b = Math.sqrt(d * d + e * e + a * a);
    if (!b) {
        c[0] = 0;
        c[1] = 0;
        c[2] = 0;
        return c;
    }
    b = 1 / b;
    c[0] = d * b;
    c[1] = e * b;
    c[2] = a * b;
    return c;
};
Vadstena.vec3.lerp = function (a, b, c, d) {
    d || (d = a);
    d[0] = a[0] + c * (b[0] - a[0]);
    d[1] = a[1] + c * (b[1] - a[1]);
    d[2] = a[2] + c * (b[2] - a[2]);
    return d;
};
Vadstena.vec3.str = function (a) {
    return "[" + a[0] + ", " + a[1] + ", " + a[2] + "]";
};
Vadstena.mat3 = {};
Vadstena.mat3.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(9);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
    }
    return b;
};
Vadstena.mat3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    return b;
};
Vadstena.mat3.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 1;
    a[5] = 0;
    a[6] = 0;
    a[7] = 0;
    a[8] = 1;
    return a;
};
Vadstena.mat3.transpose = function (a, b) {
    if (!b || a == b) {
        var c = a[1],
            d = a[2],
            e = a[5];
        a[1] = a[3];
        a[2] = a[6];
        a[3] = c;
        a[5] = a[7];
        a[6] = d;
        a[7] = e;
        return a;
    }
    b[0] = a[0];
    b[1] = a[3];
    b[2] = a[6];
    b[3] = a[1];
    b[4] = a[4];
    b[5] = a[7];
    b[6] = a[2];
    b[7] = a[5];
    b[8] = a[8];
    return b;
};
Vadstena.mat3.toMat4 = function (a, b) {
    b || (b = Vadstena.mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = 0;
    b[4] = a[3];
    b[5] = a[4];
    b[6] = a[5];
    b[7] = 0;
    b[8] = a[6];
    b[9] = a[7];
    b[10] = a[8];
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};
Vadstena.mat3.str = function (a) {
    return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + "]";
};
Vadstena.mat4 = {};
Vadstena.mat4.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(16);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
        b[10] = a[10];
        b[11] = a[11];
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        b[15] = a[15];
    }
    return b;
};
Vadstena.mat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    b[15] = a[15];
    return b;
};
Vadstena.mat4.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = 1;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 1;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return a;
};
Vadstena.mat4.transpose = function (a, b) {
    if (!b || a == b) {
        var c = a[1],
            d = a[2],
            e = a[3],
            g = a[6],
            f = a[7],
            h = a[11];
        a[1] = a[4];
        a[2] = a[8];
        a[3] = a[12];
        a[4] = c;
        a[6] = a[9];
        a[7] = a[13];
        a[8] = d;
        a[9] = g;
        a[11] = a[14];
        a[12] = e;
        a[13] = f;
        a[14] = h;
        return a;
    }
    b[0] = a[0];
    b[1] = a[4];
    b[2] = a[8];
    b[3] = a[12];
    b[4] = a[1];
    b[5] = a[5];
    b[6] = a[9];
    b[7] = a[13];
    b[8] = a[2];
    b[9] = a[6];
    b[10] = a[10];
    b[11] = a[14];
    b[12] = a[3];
    b[13] = a[7];
    b[14] = a[11];
    b[15] = a[15];
    return b;
};
Vadstena.mat4.determinant = function (a) {
    var b = a[0],
        c = a[1],
        d = a[2],
        e = a[3],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[7],
        j = a[8],
        k = a[9],
        l = a[10],
        o = a[11],
        m = a[12],
        n = a[13],
        p = a[14];
    a = a[15];
    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;
};
Vadstena.mat4.inverse = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = a[4],
        h = a[5],
        i = a[6],
        j = a[7],
        k = a[8],
        l = a[9],
        o = a[10],
        m = a[11],
        n = a[12],
        p = a[13],
        r = a[14],
        s = a[15],
        A = c * h - d * f,
        B = c * i - e * f,
        t = c * j - g * f,
        u = d * i - e * h,
        v = d * j - g * h,
        w = e * j - g * i,
        x = k * p - l * n,
        y = k * r - o * n,
        z = k * s - m * n,
        C = l * r - o * p,
        D = l * s - m * p,
        E = o * s - m * r,
        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);
    b[0] = (h * E - i * D + j * C) * q;
    b[1] = (-d * E + e * D - g * C) * q;
    b[2] = (p * w - r * v + s * u) * q;
    b[3] = (-l * w + o * v - m * u) * q;
    b[4] = (-f * E + i * z - j * y) * q;
    b[5] = (c * E - e * z + g * y) * q;
    b[6] = (-n * w + r * t - s * B) * q;
    b[7] = (k * w - o * t + m * B) * q;
    b[8] = (f * D - h * z + j * x) * q;
    b[9] = (-c * D + d * z - g * x) * q;
    b[10] = (n * v - p * t + s * A) * q;
    b[11] = (-k * v + l * t - m * A) * q;
    b[12] = (-f * C + h * y - i * x) * q;
    b[13] = (c * C - d * y + e * x) * q;
    b[14] = (-n * u + p * B - r * A) * q;
    b[15] = (k * u - l * B + o * A) * q;
    return b;
};
Vadstena.mat4.toRotationMat = function (a, b) {
    b || (b = Vadstena.mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};
Vadstena.mat4.toMat3 = function (a, b) {
    b || (b = Vadstena.mat3.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[4];
    b[4] = a[5];
    b[5] = a[6];
    b[6] = a[8];
    b[7] = a[9];
    b[8] = a[10];
    return b;
};
Vadstena.mat4.toInverseMat3 = function (a, b) {
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[8],
        j = a[9],
        k = a[10],
        l = k * f - h * j,
        o = -k * g + h * i,
        m = j * g - f * i,
        n = c * l + d * o + e * m;
    if (!n) return null;
    n = 1 / n;
    b || (b = Vadstena.mat3.create());
    b[0] = l * n;
    b[1] = (-k * d + e * j) * n;
    b[2] = (h * d - e * f) * n;
    b[3] = o * n;
    b[4] = (k * c - e * i) * n;
    b[5] = (-h * c + e * g) * n;
    b[6] = m * n;
    b[7] = (-j * c + d * i) * n;
    b[8] = (f * c - d * g) * n;
    return b;
};
Vadstena.mat4.multiply = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1],
        g = a[2],
        f = a[3],
        h = a[4],
        i = a[5],
        j = a[6],
        k = a[7],
        l = a[8],
        o = a[9],
        m = a[10],
        n = a[11],
        p = a[12],
        r = a[13],
        s = a[14];
    a = a[15];
    var A = b[0],
        B = b[1],
        t = b[2],
        u = b[3],
        v = b[4],
        w = b[5],
        x = b[6],
        y = b[7],
        z = b[8],
        C = b[9],
        D = b[10],
        E = b[11],
        q = b[12],
        F = b[13],
        G = b[14];
    b = b[15];
    c[0] = A * d + B * h + t * l + u * p;
    c[1] = A * e + B * i + t * o + u * r;
    c[2] = A * g + B * j + t * m + u * s;
    c[3] = A * f + B * k + t * n + u * a;
    c[4] = v * d + w * h + x * l + y * p;
    c[5] = v * e + w * i + x * o + y * r;
    c[6] = v * g + w * j + x * m + y * s;
    c[7] = v * f + w * k + x * n + y * a;
    c[8] = z * d + C * h + D * l + E * p;
    c[9] = z * e + C * i + D * o + E * r;
    c[10] = z *
        g + C * j + D * m + E * s;
    c[11] = z * f + C * k + D * n + E * a;
    c[12] = q * d + F * h + G * l + b * p;
    c[13] = q * e + F * i + G * o + b * r;
    c[14] = q * g + F * j + G * m + b * s;
    c[15] = q * f + F * k + G * n + b * a;
    return c;
};
Vadstena.mat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1];
    b = b[2];
    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];
    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];
    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];
    return c;
};
Vadstena.mat4.multiplyVec4 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1],
        g = b[2];
    b = b[3];
    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;
    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;
    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;
    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;
    return c;
};
Vadstena.mat4.translate = function (a, b, c) {
    var d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
        return a;
    }
    var g = a[0],
        f = a[1],
        h = a[2],
        i = a[3],
        j = a[4],
        k = a[5],
        l = a[6],
        o = a[7],
        m = a[8],
        n = a[9],
        p = a[10],
        r = a[11];
    c[0] = g;
    c[1] = f;
    c[2] = h;
    c[3] = i;
    c[4] = j;
    c[5] = k;
    c[6] = l;
    c[7] = o;
    c[8] = m;
    c[9] = n;
    c[10] = p;
    c[11] = r;
    c[12] = g * d + j * e + m * b + a[12];
    c[13] = f * d + k * e + n * b + a[13];
    c[14] = h * d + l * e + p * b + a[14];
    c[15] = i * d + o * e + r * b + a[15];
    return c;
};
Vadstena.mat4.scale = function (a, b, c) {
    var d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[0] *= d;
        a[1] *= d;
        a[2] *= d;
        a[3] *= d;
        a[4] *= e;
        a[5] *= e;
        a[6] *= e;
        a[7] *= e;
        a[8] *= b;
        a[9] *= b;
        a[10] *= b;
        a[11] *= b;
        return a;
    }
    c[0] = a[0] * d;
    c[1] = a[1] * d;
    c[2] = a[2] * d;
    c[3] = a[3] * d;
    c[4] = a[4] * e;
    c[5] = a[5] * e;
    c[6] = a[6] * e;
    c[7] = a[7] * e;
    c[8] = a[8] * b;
    c[9] = a[9] * b;
    c[10] = a[10] * b;
    c[11] = a[11] * b;
    c[12] = a[12];
    c[13] = a[13];
    c[14] = a[14];
    c[15] = a[15];
    return c;
};
Vadstena.mat4.rotate = function (a, b, c, d) {
    var e = c[0],
        g = c[1];
    c = c[2];
    var f = Math.sqrt(e * e + g * g + c * c);
    if (!f) return null;
    if (f != 1) {
        f = 1 / f;
        e *= f;
        g *= f;
        c *= f;
    }
    var h = Math.sin(b),
        i = Math.cos(b),
        j = 1 - i;
    b = a[0];
    f = a[1];
    var k = a[2],
        l = a[3],
        o = a[4],
        m = a[5],
        n = a[6],
        p = a[7],
        r = a[8],
        s = a[9],
        A = a[10],
        B = a[11],
        t = e * e * j + i,
        u = g * e * j + c * h,
        v = c * e * j - g * h,
        w = e * g * j - c * h,
        x = g * g * j + i,
        y = c * g * j + e * h,
        z = e * c * j + g * h;
    e = g * c * j - e * h;
    g = c * c * j + i;
    if (d) {
        if (a != d) {
            d[12] = a[12];
            d[13] = a[13];
            d[14] = a[14];
            d[15] = a[15];
        }
    } else d = a;
    d[0] = b * t + o * u + r * v;
    d[1] = f * t + m * u + s * v;
    d[2] = k * t + n * u + A * v;
    d[3] = l * t + p * u + B *
        v;
    d[4] = b * w + o * x + r * y;
    d[5] = f * w + m * x + s * y;
    d[6] = k * w + n * x + A * y;
    d[7] = l * w + p * x + B * y;
    d[8] = b * z + o * e + r * g;
    d[9] = f * z + m * e + s * g;
    d[10] = k * z + n * e + A * g;
    d[11] = l * z + p * e + B * g;
    return d;
};
Vadstena.mat4.rotateX = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[4],
        g = a[5],
        f = a[6],
        h = a[7],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[0] = a[0];
            c[1] = a[1];
            c[2] = a[2];
            c[3] = a[3];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[4] = e * b + i * d;
    c[5] = g * b + j * d;
    c[6] = f * b + k * d;
    c[7] = h * b + l * d;
    c[8] = e * -d + i * b;
    c[9] = g * -d + j * b;
    c[10] = f * -d + k * b;
    c[11] = h * -d + l * b;
    return c;
};
Vadstena.mat4.rotateY = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[4] = a[4];
            c[5] = a[5];
            c[6] = a[6];
            c[7] = a[7];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * -d;
    c[1] = g * b + j * -d;
    c[2] = f * b + k * -d;
    c[3] = h * b + l * -d;
    c[8] = e * d + i * b;
    c[9] = g * d + j * b;
    c[10] = f * d + k * b;
    c[11] = h * d + l * b;
    return c;
};
Vadstena.mat4.rotateZ = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[4],
        j = a[5],
        k = a[6],
        l = a[7];
    if (c) {
        if (a != c) {
            c[8] = a[8];
            c[9] = a[9];
            c[10] = a[10];
            c[11] = a[11];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * d;
    c[1] = g * b + j * d;
    c[2] = f * b + k * d;
    c[3] = h * b + l * d;
    c[4] = e * -d + i * b;
    c[5] = g * -d + j * b;
    c[6] = f * -d + k * b;
    c[7] = h * -d + l * b;
    return c;
};
Vadstena.mat4.frustum = function (a, b, c, d, e, g, f) {
    f || (f = Vadstena.mat4.create());
    var h = b - a,
        i = d - c,
        j = g - e;
    f[0] = e * 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = e * 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = (b + a) / h;
    f[9] = (d + c) / i;
    f[10] = -(g + e) / j;
    f[11] = -1;
    f[12] = 0;
    f[13] = 0;
    f[14] = -(g * e * 2) / j;
    f[15] = 0;
    return f;
};
Vadstena.mat4.perspective = function (a, b, c, d, e) {
    a = c * Math.tan(a * Math.PI / 360);
    b = a * b;
    return Vadstena.mat4.frustum(-b, b, -a, a, c, d, e);
};
Vadstena.mat4.ortho = function (a, b, c, d, e, g, f) {
    f || (f = Vadstena.mat4.create());
    var h = b - a,
        i = d - c,
        j = g - e;
    f[0] = 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = 0;
    f[9] = 0;
    f[10] = -2 / j;
    f[11] = 0;
    f[12] = -(a + b) / h;
    f[13] = -(d + c) / i;
    f[14] = -(g + e) / j;
    f[15] = 1;
    return f;
};
Vadstena.mat4.lookAt = function (a, b, c, d) {
    d || (d = Vadstena.mat4.create());
    var e = a[0],
        g = a[1];
    a = a[2];
    var f = c[0],
        h = c[1],
        i = c[2];
    c = b[1];
    var j = b[2];
    if (e == b[0] && g == c && a == j) return Vadstena.mat4.identity(d);
    var k, l, o, m;
    c = e - b[0];
    j = g - b[1];
    b = a - b[2];
    m = 1 / Math.sqrt(c * c + j * j + b * b);
    c *= m;
    j *= m;
    b *= m;
    k = h * b - i * j;
    i = i * c - f * b;
    f = f * j - h * c;
    if (m = Math.sqrt(k * k + i * i + f * f)) {
        m = 1 / m;
        k *= m;
        i *= m;
        f *= m;
    } else f = i = k = 0;
    h = j * f - b * i;
    l = b * k - c * f;
    o = c * i - j * k;
    if (m = Math.sqrt(h * h + l * l + o * o)) {
        m = 1 / m;
        h *= m;
        l *= m;
        o *= m;
    } else o = l = h = 0;
    d[0] = k;
    d[1] = h;
    d[2] = c;
    d[3] = 0;
    d[4] = i;
    d[5] = l;
    d[6] = j;
    d[7] = 0;
    d[8] = f;
    d[9] =
        o;
    d[10] = b;
    d[11] = 0;
    d[12] = -(k * e + i * g + f * a);
    d[13] = -(h * e + l * g + o * a);
    d[14] = -(c * e + j * g + b * a);
    d[15] = 1;
    return d;
};
Vadstena.mat4.str = function (a) {
    return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + "]";
};
Vadstena.quat4 = {};
Vadstena.quat4.create = function (a) {
    var b = new Vadstena.glMatrixArrayType2(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};
Vadstena.quat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    return b;
};
Vadstena.quat4.calculateW = function (a, b) {
    var c = a[0],
        d = a[1],
        e = a[2];
    if (!b || a == b) {
        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
        return a;
    }
    b[0] = c;
    b[1] = d;
    b[2] = e;
    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
    return b;
};
Vadstena.quat4.inverse = function (a, b) {
    if (!b || a == b) {
        a[0] *= 1;
        a[1] *= 1;
        a[2] *= 1;
        return a;
    }
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    b[3] = a[3];
    return b;
};
Vadstena.quat4.length = function (a) {
    var b = a[0],
        c = a[1],
        d = a[2];
    a = a[3];
    return Math.sqrt(b * b + c * c + d * d + a * a);
};
Vadstena.quat4.normalize = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = Math.sqrt(c * c + d * d + e * e + g * g);
    if (f == 0) {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        return b;
    }
    f = 1 / f;
    b[0] = c * f;
    b[1] = d * f;
    b[2] = e * f;
    b[3] = g * f;
    return b;
};
Vadstena.quat4.multiply = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1],
        g = a[2];
    a = a[3];
    var f = b[0],
        h = b[1],
        i = b[2];
    b = b[3];
    c[0] = d * b + a * f + e * i - g * h;
    c[1] = e * b + a * h + g * f - d * i;
    c[2] = g * b + a * i + d * h - e * f;
    c[3] = a * b - d * f - e * h - g * i;
    return c;
};
Vadstena.quat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1],
        g = b[2];
    b = a[0];
    var f = a[1],
        h = a[2];
    a = a[3];
    var i = a * d + f * g - h * e,
        j = a * e + h * d - b * g,
        k = a * g + b * e - f * d;
    d = -b * d - f * e - h * g;
    c[0] = i * a + d * -b + j * -h - k * -f;
    c[1] = j * a + d * -f + k * -b - i * -h;
    c[2] = k * a + d * -h + i * -f - j * -b;
    return c;
};
Vadstena.quat4.toMat3 = function (a, b) {
    b || (b = Vadstena.mat3.create());
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    var l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = k + g;
    b[4] = 1 - (j + e);
    b[5] = d - f;
    b[6] = c - h;
    b[7] = d + f;
    b[8] = 1 - (j + l);
    return b;
};
Vadstena.quat4.toMat4 = function (a, b) {
    b || (b = Vadstena.mat4.create());
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    var l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = 0;
    b[4] = k + g;
    b[5] = 1 - (j + e);
    b[6] = d - f;
    b[7] = 0;
    b[8] = c - h;
    b[9] = d + f;
    b[10] = 1 - (j + l);
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};
Vadstena.quat4.slerp = function (a, b, c, d) {
    d || (d = a);
    var e = c;
    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;
    d[0] = 1 - c * a[0] + e * b[0];
    d[1] = 1 - c * a[1] + e * b[1];
    d[2] = 1 - c * a[2] + e * b[2];
    d[3] = 1 - c * a[3] + e * b[3];
    return d;
};
Vadstena.quat4.str = function (a) {
    return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + "]";
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.frustumMatrix = function(left_, right_, bottom_, top_, near_, far_)
{
    var w = (right_ - left_);
    var h = (top_ - bottom_);
    var d = (far_ - near_);

    var m = Vadstena.mat4.create([2*near_/w, 0, (right_+left_)/w, 0,
        0, 2*near_/h, (top_+bottom_)/h, 0,
        0, 0, -(far_+near_)/d, -2*far_*near_/d,
        0, 0, -1, 0]);

    Vadstena.mat4.transpose(m);
    return m;
};


Vadstena.perspectiveMatrix = function(fovy_, aspect_, near_, far_)
{
    var ymax_ = near_ * Math.tan(fovy_ * Math.PI / 360.0);
    var xmax_ = ymax_ * aspect_;
    return Vadstena.frustumMatrix(-xmax_, xmax_, -ymax_, ymax_, near_, far_);
};


Vadstena.rotationMatrix = function(axis_, angle_)
{
    var ca = Math.cos(angle_), sa = Math.sin(angle_);
    var m;

    switch (axis_) {
    case 0:
        m = [
            1,  0,  0, 0,
            0, ca,-sa, 0,
            0, sa, ca, 0,
            0,  0,  0, 1 ];
            break;
    case 1:
        m = [
            ca, 0,-sa, 0,
             0, 1,  0, 0,
            sa, 0, ca, 0,
             0, 0,  0, 1 ];
             break;
    default:
        m = [
            ca,-sa, 0, 0,
            sa, ca, 0, 0,
            0,  0,  1, 0,
            0,  0,  0, 1 ];
            break;
    }

    Vadstena.mat4.transpose(m);
    return m;
};


Vadstena.scaleMatrix = function(sx, sy, sz)
{
    var m = [
        sx,  0,  0, 0,
         0, sy,  0, 0,
         0,  0, sz, 0,
         0,  0,  0, 1 ];

    Vadstena.mat4.transpose(m);
    return m;
};

Vadstena.scaleMatrixf = function(s)
{
    return Vadstena.scaleMatrix(s, s, s);
};


Vadstena.translationMatrix = function(tx, ty, tz)
{
    var m = [
        1, 0, 0, tx,
        0, 1, 0, ty,
        0, 0, 1, tz,
        0, 0, 0, 1 ];

    Vadstena.mat4.transpose(m);
    return m;
};

Vadstena.translationMatrix2f = function(t)
{
    return Vadstena.translationMatrix(t[0], t[1], 0);
};

Vadstena.translationMatrix3f = function(t)
{
    return Vadstena.translationMatrix(t[0], t[1], t[2]);
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file


Vadstena.clamp = function(value_, min_, max_)
{
    if (value_ < min_) value_ = min_;
    else if (value_ > max_) value_ = max_;

    return value_;
};

Vadstena.radians = function(degrees_)
{
    return degrees_ * Math.PI / 180;
};

Vadstena.padNumber = function(n, width_) {
  var z = '0';

  if (n < 0) {
      n = (-n) + '';
      width_--;     //7
      return n.length >= width_ ? ("-" + n) : "-" + (new Array(width_ - n.length + 1).join(z) + n);
  } else {
      n = n + '';
      return n.length >= width_ ? n : new Array(width_ - n.length + 1).join(z) + n;
  }
};

Vadstena.decodeFloat16 = function(binary) {
    var exponent = (binary & 0x7C00) >> 10;
        fraction = binary & 0x03FF;
    return (binary >> 15 ? -1 : 1) * (
        exponent ?
        (
            exponent === 0x1F ?
            fraction ? NaN : Infinity :
            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)
        ) :
        6.103515625e-5 * (fraction / 0x400)
    );
};

Vadstena.simpleFmtObj = (function obj(str, obj) {
    return str.replace(/\{([_$a-zA-Z0-9][_$a-zA-Z0-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : s);
    });
});

Vadstena.simpleFmtObjOrCall = (function obj(str, obj, call) {
    return str.replace(/\{([_$a-zA-Z(-9][_$a-zA-Z(-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : call(match));
    });
});

Vadstena.getABGRFromHexaCode = (function(code_) {
    var result_ = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(code_);

    return result_ ?
        [ parseInt(result_[4], 16),
          parseInt(result_[3], 16),
          parseInt(result_[2], 16),
          parseInt(result_[1], 16)]
    : [0,0,0,255];
});

Vadstena.stringifyFunction = (function(function_) {
    // Stringify the code
    return '(' + function_ + ').call(self);';
});

Vadstena.loadJSON = function(path_, onLoaded_, onError_, skipEval_)
{
    var xhr_ = new XMLHttpRequest();

    xhr_.onload  = (function()
    {
        var data_ = xhr_.response;

        try {
            var parsedData_ = skipEval_ ? data_ : eval("("+data_+")");
        } catch(e) {
            if (onError_ != null) {
                onError_();
            }

            return;
        }

        if (onLoaded_ != null) {
            onLoaded_(parsedData_);
        }

    }).bind(this);

    xhr_.onerror  = (function()
    {

        if (onError_ != null) {
            onError_();
        }

    }).bind(this);

    xhr_.open('GET',  path_, true);
    xhr_.send("");
};

Vadstena.loadBinary = function(path_, onLoaded_, onError_)
{
    var xhr_ = new XMLHttpRequest();

    xhr_.onreadystatechange = (function (){

        switch (xhr_.readyState)
        {
        case 0 : // UNINITIALIZED
        case 1 : // LOADING
        case 2 : // LOADED
        case 3 : // INTERACTIVE
        break;
        case 4 : // COMPLETED

                if (xhr_.status == 404)
                {
                    if (onError_ != null) {
                        onError_();
                    }

                    break;
                }

                var abuffer_ = xhr_.response;
                var data_ = new DataView(abuffer_);

                if (onLoaded_ != null) {
                    onLoaded_(data_);
                }

          break;

          default:

            if (onError_ != null) {
                onError_();
            }

            break;
          }

       }).bind(this);

    xhr_.onerror  = (function() {
        if (onError_ != null) {
            onError_();
        }
    }).bind(this);

    xhr_.open('GET', path_, true);
    xhr_.responseType = "arraybuffer";
    xhr_.send("");
};


window.performance = window.performance || {};
performance.now = (function() {
  return performance.now       ||
         performance.mozNow    ||
         performance.msNow     ||
         performance.oNow      ||
         performance.webkitNow ||
         function() { return new Date().getTime(); };
})();

//Provides requestAnimationFrame in a cross browser way.
window.requestAnimFrame = (function() {

  return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
           window.setTimeout(callback, 1000/60);
         };
})();

// only implement if no native implementation is available
if (typeof Array.isArray === 'undefined') {
  Array.isArray = (function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  });
}
//! Map configuration, parsed from mapConfig.json

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.MapConfig = function(browser_, json_, baseUrl_)
{
    this["json"] = json_;

    this.foat_ = new Vadstena.TileId(browser_);
    this.foatSize_ = 0;
    this.metaLod_ = 0;
    this.metaDelta_ = 0;
    this.defaultPosition_ = [];
    this.defaultOrientation_ = [0,0,0];

    this.baseUrl_ = baseUrl_;
    this.metaTemplate_ = "";
    this.meshTemplate_ = "";
    this.textureTemplate_ = "";

    if (json_["foat"] != null) {
        this.foat_.lod_ = json_["foat"][0];
        this.foat_.easting_ = json_["foat"][1];
        this.foat_.northing_ = json_["foat"][2];
        this.foatSize_ = json_["foat"][3];
    }

    if (json_["extents"] != null) {

        this.newIndexMode_ = true;

        this.foat_.lod_ = 0;
        this.foat_.easting_ = json_["extents"][0];
        this.foat_.northing_ = json_["extents"][1];
        this.foat_.southing_ = json_["extents"][3];
        this.foatSize_ = json_["extents"][2] - json_["extents"][0];
    }


    if (json_["meta"] != null) {
        this.metaLod_ = json_["meta"][0];
        this.metaDelta_ = json_["meta"][1];
    }

    this.metaTemplate_ = json_["metaTemplate"];
    this.meshTemplate_ = json_["meshTemplate"];
    this.textureTemplate_ = json_["textureTemplate"];

    //this.textureTemplate_ = "surfaces/grand/{lod}-{x}-{y}.jpg";

    if (json_["defaultPosition"] != null && json_["defaultOrientation"] != null) {
        for (var i = 0; i < 3; i++) {
            this.defaultPosition_[i] = json_["defaultPosition"][i];
            this.defaultOrientation_[i] = json_["defaultOrientation"][i];
        }
    }

    this.lowRes_ = json_["lowRes"] || 2.2;
    this.degdradeHorizon_ = [1, 3000, 15000, 7000];

    if (json_["degdradeHorizon"] != null && json_["degdradeHorizon"].length != null) {
        for (var i = 0; i < 4; i++) {
            this.degdradeHorizon_[i] = json_["degdradeHorizon"][i] || this.degdradeHorizon_[i];
        }
    }

    this.texelSize_ = (json_["texelSize"] != null) ? json_["texelSize"] : 0.02;
    Vadstena.texelSizeFactor_ = (json_["texelSizeFactor"] != null) ? json_["texelSizeFactor"] : 1.0;

    var size_ = this.tileSize(0);

    var level_ = Math.floor(Math.log(size_) / Math.log(2));
    var level2_ = Math.floor(Math.log(32) / Math.log(2));


    this.mapVersion_ = json_["mapVersion"] || 1;
    this.geoLayers_ = json_["geodata-layers"] || [];
/*
    var params_ = {
        "id": "test",
        "type": "tiled-geodata",
        "style": "./browser/test/style.json",
        //"url": "http://localhost:8091/{lod}-{easting}-{northing}.json",
        "url": "http://localhost:8888/{lod}-{easting}-{northing}.json",
        "minLod":3,
        "maxLod":15,
        "tileWidth":256
    };

    this.geoLayers_.push(params_);

/*
    var params_ = {
        "id": "test2",
        "type": "geodata",
        "style": "./browser/test/style.json",
        "url": "./browser/test/test.json"
    };

    this.geoLayers_.push(params_);
*/

    //this.maxHeightLod_ = level_ - level2_;
    this.maxHeightLod_ = null;

};

Vadstena.MapConfig.prototype.clone = function() {
    var json_ = JSON.parse(JSON.stringify(this["json"]));
    json_["lowRes"] =          this.lowRes_;
    json_["degdradeHorizon"] = [this.degdradeHorizon_[0], this.degdradeHorizon_[1], this.degdradeHorizon_[2], this.degdradeHorizon_[3]];
    json_["texelSize"] =       this.texelSize_;
    json_["texelSizeFactor"] = Vadstena.texelSizeFactor_;
    json_["mapVersion"] =      this.mapVersion_;
    json_["geodata-layers"] =  this.geoLayers_;
    return json_;
};

//! Returns the size of tiles at the given LOD.
Vadstena.MapConfig.prototype.tileSize = function(lod_) { //int
    if (lod_ > this.foat_.lod_) {
        return this.foatSize_ >> (lod_ - this.foat_.lod_);
    } else {
        return this.foatSize_ << (this.foat_.lod_ - lod_);
    }
};

//! Returns nearest position aligned to the tile grid of a given LOD.

Vadstena.MapConfig.prototype.metaUrl = function(id_) {
    return this.makeUrl(this.metaTemplate_, id_);
};

Vadstena.MapConfig.prototype.meshUrl = function(id_) {
    return this.makeUrl(this.meshTemplate_, id_);
};

Vadstena.MapConfig.prototype.textureUrl = function(id_) {
    return this.makeUrl(this.textureTemplate_, id_);
};

Vadstena.MapConfig.prototype.quad = function(lod_, ix, iy) {
    var quadKey = "";
    //ty = Math.pow(2,zoom - 1) - ty;
    for (i = lod_; i > 0; i--) {
        var digit = 0;
        var mask = 1 << (i-1);
        if ((ix & mask) != 0) {
            digit += 1;
        }

        if ((iy & mask) != 0) {
            digit += 2;
        }

        quadKey += digit;
    }

    return quadKey;
};

Vadstena.MapConfig.prototype.msDigit = function(iy, ix) {
    return (((iy & 3) << 1) + (ix & 1));
};

Vadstena.MapConfig.prototype.processUrlFunction = function(id_, string_) {

    if (typeof string_ == "string") {
        if (string_.indexOf("quad") != -1) {
            var string2_ = "(function(lod,x,y){" + string_.replace("quad", "return this.quad") + "})";

            try {
                var fc_ = eval(string2_).bind(this);
                return fc_(id_.lod_, id_.ix_, id_.iy_);
            } catch(e) {
                return string_;
            }
        } else if (string_.indexOf("ms_digit") != -1) {
            var string2_ = "(function(x,y){" + string_.replace("ms_digit", "return this.msDigit") + "})";

            try {
                var fc_ = eval(string2_).bind(this);
                return fc_(id_.ix_, id_.iy_);
            } catch(e) {
                return string_;
            }

        } else {
            return string_;
        }

    } else {
        return string_;
    }

};

Vadstena.MapConfig.prototype.makeUrl = function(templ_, id_, skipBaseUrl_)
{
    //if (templ_.indexOf("jpg") != -1) {
       //templ_ = "{lod}-{easting}-{northing}.jpg?v=4";
       //templ_ = "{lod}-{x}-{y}.jpg?v=4";
       //templ_ = "{quad(lod,x,y)}.jpg?v=4";
       //templ_ = "{quad(lod,x+1,y*2)}.jpg?v=4";
       //templ_ = "{lod}-{ms_digit(x,y)}.jpg?v=4";
    //}

    var tileSize_ = 1.0/this.tileSize(id_.lod_);
    var ix_ = Math.round((id_.easting_ - this.foat_.easting_) * tileSize_);
    var iy_ = Math.round((id_.northing_ - this.foat_.northing_) * tileSize_);
    var liy_ = Math.round((this.foat_.southing_ -  this.foat_.northing_ ) * tileSize_);
    iy_ = (liy_ - iy_) - 1;

    var url_ = Vadstena.simpleFmtObjOrCall(templ_, {"lod":id_.lod_, "easting":Vadstena.padNumber(id_.easting_, 7), "northing":Vadstena.padNumber(id_.northing_, 7),
                                           "x":ix_, "y":iy_, "lod":id_.lod_, "here_app_id": "abcde", "here_app_code":"12345"},
                                           this.processUrlFunction.bind(this, {lod_:id_.lod_, ix_:ix_, iy_:iy_}));

    if (skipBaseUrl_) {
        return url_;
    } else {
        return this.baseUrl_ + url_;
    }
};
/*
Vadstena.MapConfig.prototype.makeUrl = function(templ_, id_, skipBaseUrl_)
{
    var tileSize_ = 1.0/this.tileSize(id_.lod_);
    var ix = Math.round((id_.easting_ - this.foat_.easting_) * tileSize_);
    var iy = Math.round((id_.northing_ - this.foat_.northing_) * tileSize_);
    var liy = Math.round((this.foat_.southing_ -  this.foat_.northing_ ) * tileSize_);
    var iy = lyi - iy;

    var url_ = Vadstena.simpleFmtObj(templ_, {"lod":id_.lod_, "easting":Vadstena.padNumber(id_.easting_, 7), "northing":Vadstena.padNumber(id_.northing_, 7),
                                              "x":ix, "y":iy, "quadTree":this.quadTree(id_.lod_, ix, iy) });

    if (skipBaseUrl_) {
        return url_;
    } else {
        return this.baseUrl_ + url_;
    }
};*/

Vadstena.MapConfig.prototype.lodAlign = function(pos_, lod_, vec_)
{
    var size_ = this.tileSize(lod_);
    var ix_ = (Math.round((pos_[0] - this.foat_.easting_) / size_));
    var iy_ = (Math.round((pos_[1] - this.foat_.northing_) / size_));

    if (vec_ != null) {
        vec_[0] = this.foat_.easting_ + ix_*size_;
        vec_[1] = this.foat_.northing_ + iy_*size_;
        vec_[2] = pos_[2];
        return vec_;
    } else {
        return [this.foat_.easting_ + ix_*size_, this.foat_.northing_ + iy_*size_, pos_[2]];
    }
};

Vadstena.MapConfig.prototype.lodAlign2 = function(pos_, lod_, vec_)
{
    var size_ = this.tileSize(lod_);
    var ix_ = (Math.round((pos_[0] - this.foat_.easting_) / size_));
    var iy_ = (Math.round((pos_[1] - this.foat_.northing_) / size_));

    if (vec_ != null) {
        vec_[0] = ix_*size_;
        vec_[1] = iy_*size_;
        vec_[2] = pos_[2];
        return vec_;
    } else {
        return [this.foat_.easting_ + ix_*size_, this.foat_.northing_ + iy_*size_, pos_[2]];
    }
};

//! 3D browser configuration, parsed from browserConfig.json
/**
 * @constructor
 */
Vadstena.BrowserConfig = function(json_)
{
    this.cacheSize_ = (1024*1024*1024);
    this.gpuCacheSize_ = (420*1024*1024);
    this.numThreads_ = 4;

    this.cameraFOV_ = 45.0;
    //this.cameraVisibility_ = 40000.0;
    this.cameraVisibility_ = 1200000.0;
    this.cameraMinDistance_ = 180.0; //seznam 180
    this.cameraMaxDistance_ = this.cameraVisibility_;
    this.cameraMinTilt_ = -90.0;

    this.heightLod_ = 14;

    if (SEZNAMCZ != true) {
        this.cameraMaxTilt_ = 90.0; //seznam -10
        this.cameraConstrainMode_ = "aboveTerrainByPixelSize";
        //this.cameraConstrainMode_ = "aboveTerrainByGSD";
    } else {
        this.cameraMaxTilt_ =  -10;
        this.cameraConstrainMode_ = "aboveTerrainOnly";
    }

    //this.cameraConstrainDistance_ = this.cameraMinDistance_ / 5.0;
    this.cameraConstrainDistance_ = this.cameraMinDistance_ * 0.5;

    this.gridEmbeddingFactor_ = 8;
    this.gridMinTileSize_ = 32.0;

    this.hitTextureSize_ = 1024;
    this.skydomeTexture_ = "./skydome.jpg";

    if (window["VadstenaScreenScaleFactor_"] < 0.8) {
        this.hitTextureSize_ = 512;
        this.skydomeTexture_ = "./skydome-small.jpg";
    }

    this.controlInertia_ = [0.80, 0.80, 0.80];
    this.controlMode_ = "observer";

    if (json_ != null) {
        if (json_["cacheSize"] != null)     this.cacheSize_ = json_["cacheSize"];
        if (json_["gpuCacheSize"] != null)  this.gpuCacheSize_ = json_["gpuCacheSize"];
        if (json_["numThreads"] != null)    this.numThreads_ = json_["numThreads"];

        if (json_["cameraFOV"] != null)               this.cameraFOV_ = json_["cameraFOV"];
        if (json_["cameraVisibility"] != null)        this.cameraVisibility_ = json_["cameraVisibility"];
        if (json_["cameraMinDistance"] != null)       this.cameraMinDistance_ = json_["cameraMinDistance"];
        if (json_["cameraMaxDistance"] != null)       this.cameraMaxDistance_ = json_["cameraMaxDistance"];
        if (json_["cameraMinTilt"] != null)           this.cameraMinTilt_ = json_["cameraMinTilt"];
        if (json_["cameraMaxTilt"] != null)           this.cameraMaxTilt_ = json_["cameraMaxTilt"];
        if (json_["cameraConstrainMode"] != null)     this.cameraConstrainMode_ = json_["cameraConstrainMode"], this.cameraConstrainDistance_ = this.cameraMinDistance_ / 5.0;

        if (json_["gridEmbeddingFactor"] != null) this.gridEmbeddingFactor_ = json_["gridEmbeddingFactor"];
        if (json_["gridMinTileSize"] != null)     this.gridMinTileSize_ = json_["gridMinTileSize"];

        if (json_["skydomeTexture"] != null)      this.skydomeTexture_ = json_["skydomeTexture"];
        if (json_["hitTextureSize"] != null)      this.hitTextureSize_ = json_["hitTextureSize"];

        if (json_["heightLod"] != null)           this.heightLod_ = json_["heightLod"];
        if (json_["controlMode"] != null)         this.controlMode_ = json_["controlMode"];
        if (json_["controlInertia"] != null) {
            for (var i = 0; i < 3; i++) {
                this.controlInertia_[i] = json_["controlInertia"][i];
            }
        }
    }
};

Vadstena.BrowserConfig.prototype.clone = function() {
    var json_ = {};
    json_["cacheSize"] =            this.cacheSize_;
    json_["gpuCacheSize"] =         this.gpuCacheSize_;
    json_["numThreads"] =           this.numThreads_;
    json_["cameraFOV"] =            this.cameraFOV_;
    json_["cameraVisibility"] =     this.cameraVisibility_;
    json_["cameraMinDistance"] =    this.cameraMinDistance_;
    json_["cameraMaxDistance"] =    this.cameraMaxDistance_;
    json_["cameraMinTilt"] =        this.cameraMinTilt_;
    json_["cameraMaxTilt"] =        this.cameraMaxTilt_;
    json_["cameraConstrainMode"] =  this.cameraConstrainMode_;
    json_["gridEmbeddingFactor"] =  this.gridEmbeddingFactor_;
    json_["gridMinTileSize"] =      this.gridMinTileSize_;
    json_["skydomeTexture"] =       this.skydomeTexture_;
    json_["hitTextureSize"] =       this.hitTextureSize_;
    json_["heightLod"] =            this.heightLod_;
    json_["controlMode"] =          this.controlMode_;
    json_["controlInertia"] =       [this.controlInertia_[0], this.controlInertia_[1], this.controlInertia_[2]];
    return json_;
};






if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.BBox = function(xmin_, ymin_, zmin_, xmax_, ymax_, zmax_)
{
    this.min_ = [];
    this.max_ = [];


    this.min_[0] = (xmin_ != null) ? xmin_ : Number.POSITIVE_INFINITY;
    this.min_[1] = (ymin_ != null) ? ymin_ : Number.POSITIVE_INFINITY;
    this.min_[2] = (zmin_ != null) ? zmin_ : Number.POSITIVE_INFINITY;

    this.max_[0] = (xmax_ != null) ? xmax_ : Number.NEGATIVE_INFINITY;
    this.max_[1] = (ymax_ != null) ? ymax_ : Number.NEGATIVE_INFINITY;
    this.max_[2] = (zmax_ != null) ? zmax_ : Number.NEGATIVE_INFINITY;

/*
    this.min_[0] = xmin_;
    this.min_[1] = ymin_;
    this.min_[2] = zmin_;

    this.max_[0] = xmax_;
    this.max_[1] = ymax_;
    this.max_[2] = zmax_;
*/
};

Vadstena.BBox.prototype.side = function(index_) {
    return this.max_[index_] - this.min_[index_];
};

Vadstena.BBox.prototype.center = function(vec_)
{
    if (vec_ != null) {
        vec_[0] = (this.min_[0] + this.max_[0])*0.5;
        vec_[1] = (this.min_[1] + this.max_[1])*0.5;
        return vec_;
    } else {
        return [(this.min_[0] + this.max_[0])*0.5, (this.min_[1] + this.max_[1])*0.5, (this.min_[2] + this.max_[2])*0.5];
    }
};

Vadstena.BBox.prototype.translateXY = function(delta_)
{
    return new Vadstena.BBox(this.min_[0] - delta_[0], this.min_[1] - delta_[1], this.min_[2],
                             this.max_[0] - delta_[0], this.max_[1] - delta_[1], this.max_[2]);
};
//! A generic cache of items that can be downloaded with ItemType::download().
//template<typename IdType, typename ItemType>

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.QCache = function(maxCost_)
{
    this.itemsById_ = [];
    this.maxCost_ = (maxCost_ != null) ? maxCost_ : Number.MAX_VALUE;
    this.last_ = null;
    this.first_ = null;

    this.totalCost_ = 0;
    this.totalItems_ = 0;
};

Vadstena.QCache.prototype.log = function() {
    //console.log("first:" + this.first_.hash_, "next:" + this.first_.next_, "prev:" + this.first_.prev_);
    //console.log("last:" + this.last_.hash_, "next:" + this.last_.next_, "prev:" + this.last_.prev_);

    var i = 0;
    var item_ = this.first_;

    while (true) {
        //console.log("item(" + i +"):" + item_.hash_, "next:" + item_.next_, "prev:" + item_.prev_);

        if (item_.next_ == null)
            break;

        item_ = this.itemsById_[item_.next_][3];
        i++;
        if(i>10) break;
    }

    this.itemsById_.forEach(function(item_) {
        //console.log("item:id: " + item_[0]);
    });
};

Vadstena.QCache.prototype.find = function(id_) {

    var hash_ = this.hash(id_);
    var listItem_ = this.itemsById_[hash_];


    if (listItem_ != null) {

        if (this.first_ != listItem_) {

            //remove item from list
            if (listItem_.prev_ != null) {
                listItem_.prev_.next_ = listItem_.next_;
            }

            if (listItem_.next_ != null) {
                listItem_.next_.prev_ = listItem_.prev_;
            }

            if (this.last_ == listItem_) {
                this.last_ = listItem_.prev_;
            }

            var first_ = this.first_;

            //add item as first
            this.first_ = listItem_;
            this.first_.next_ = first_;
            this.first_.prev_ = null;

            first_.prev_ = this.first_;
        }

        //return
        return listItem_.item_;

    } else {
        return null;
    }
};

Vadstena.QCache.prototype.contains = function(id_) {
    return (this.itemsById_[this.hash(id_)] != null);
};

Vadstena.QCache.prototype.maxCost = function() {
    return this.maxCost_;
};

Vadstena.QCache.prototype.setMaxCost = function(cost_) {
    this.maxCost_ = cost_;
    this.checkCost();
};

Vadstena.QCache.prototype.clear = function() {

    var item_ = this.first_;

    while (item_ != null) {
        if (item_.item_ != null) {
            item_.item_.kill();
        }
        item_ = item_.next_;
    }

    this.itemsById_ = [];

    this.last_ = null;
    this.first_ = null;

    this.totalCost_ = 0;
    this.totalItems_ = 0;
};

Vadstena.QCache.prototype.insert = function(id_, item_, cost_) {

    var hash_ = this.hash(id_);

    this.totalItems_++;

    //console.log("insert: " + hash_ + " items: " + this.totalItems_);

    var listItem_ = { hash_:hash_, item_:item_, cost_:cost_, prev_: null, next_:this.first_ };

    if (this.first_ != null) {
        this.first_.prev_ = listItem_;
    }

    //add item as first in list
    this.first_ = listItem_;

    if (this.last_ == null) {
        this.last_ = listItem_;
    }

    //add list item to the map
    this.itemsById_[hash_] = listItem_;

    this.totalCost_ += cost_;

    //console.log("QCache.prototype.insert:" + this.totalCost_ + " / " + this.maxCost_);

    this.checkCost();
};


Vadstena.QCache.prototype.checkCost = function() {
    while (this.totalCost_ > this.maxCost_) {

        this.totalItems_--;

        //console.log("remove: " + this.last_.hash_ + " prev: " + this.last_.prev_ + " items: " + this.totalItems_);

        var last_ = this.last_;

        if (last_ != null) {
            //set new last
            this.last_ = this.last_.prev_;

            if (this.last_ != null) {
                this.last_.next_ = null;
            }

            //remove from map
            //delete this.itemsById_[last_.hash_];// = null;
            this.itemsById_[last_.hash_] = null;
            this.totalCost_ -= last_.cost_;

            //destroy item
            last_.item_.kill();


        } else {
            break;
        }
    }
};

// hash function for QCache
Vadstena.QCache.prototype.hash = function(id_) //TileId
{
    //TODO: speed up
    return "" + (id_.layerId_ || 0) + "." + Math.round(id_.lod_) + "." + Math.round(id_.easting_) + "." + Math.round(id_.northing_);
    //return qHash(key_.lod_) * qHash(key_.easting_) * qHash(key_.northing_);
};



/**
 * @constructor
 */
Vadstena.DownloadCache = function(browser_, cacheSize_, onDownloadFinished_, numThreads_, downloadFunction_, layer_)
{
    if (numThreads_ == null) numThreads_ = 1;

    this.browser_ = browser_;

    this.numThreads_ = numThreads_;
    this.usedThreads_ = 0;
    this.layer_ = layer_;

    this.cache_ = new Vadstena.QCache(cacheSize_);
    this.pending_ = [];
    this.pendingId_ = [];
    this.downloading_ = [];

    this.onDownloadFinished_ = onDownloadFinished_;
    this.downloadFunction_ = downloadFunction_;
};

//! Obtains an item from the cache or schedules its download if not present
Vadstena.DownloadCache.prototype.get = function(id_)
{
    //console.log("DownloadCache.prototype.get:" + this.cache_.hash(id_));
    var item_ = this.cache_.find(id_);
    if (item_ == null) this.newRequest(id_);
    return item_;
};

//! Returns true if the specified item is in the cache.
Vadstena.DownloadCache.prototype.contains = function(id_)
{
    return this.cache_.contains(id_);
};

//! Returns true if the specified item is in the cache.
Vadstena.DownloadCache.prototype.insert = function(id_, item_, cost_)
{
    return this.cache_.insert(id_, item_, cost_);
};


//! Explicitly releases LRU items to make the total size less than 'size'
Vadstena.DownloadCache.prototype.trim = function(size_)
{
    var oldSize_ = this.cache_.maxCost();
    this.cache_.setMaxCost(size_);
    this.cache_.setMaxCost(oldSize_);
};

//! Releases all items in the cache.
Vadstena.DownloadCache.prototype.reset = function()
{
    this.cache_.clear();
};


Vadstena.DownloadCache.prototype.size = function()
{
    return this.cache_.totalCost_;
};

Vadstena.DownloadCache.prototype.newRequest = function(id_)
{
    var hashId_ = this.cache_.hash(id_);

    var index_ = this.downloading_.indexOf(hashId_);

    if (index_ != -1) {
        return;
    }

    //console.log("DownloadCache.prototype.newRequest:" + hashId_);

    // update the pending list

   // put the request to the beginning of the pending list
    var index_ = this.pending_.indexOf(hashId_);
    if (index_ != -1) {
        this.pending_.splice(index_, 1);
        this.pendingId_.splice(index_, 1);
    }

    this.pending_.unshift(hashId_);
    this.pendingId_.unshift(id_);

    // keep the pending list at reasonable length
    if (this.pending_.length > 20) {
        this.pending_.pop();
        this.pendingId_.pop();
    }
};


Vadstena.DownloadCache.prototype.update = function(td_)
{
    if (this.pending_.length > 0) {
        if (this.usedThreads_ < this.numThreads_) {

            var hashId_ = this.pending_.shift();
            var id_ = this.pendingId_.shift();

            if (this.downloading_.indexOf(hashId_) == -1) {

                //console.log("DownloadCache.prototype.download:" + hashId_);

                this.downloading_.push(hashId_);
                this.usedThreads_++;

                var onLoaded_ = (function(originalID_, item_){

                    //console.log("DownloadCache.prototype.downloadDONE:" + this.cache_.hash(originalID_));

                    this.downloading_.splice(this.downloading_.indexOf(this.cache_.hash(originalID_)), 1);
                    this.usedThreads_--;
                    this.cache_.insert(originalID_, item_, item_.size());

                    if (this.onDownloadFinished_ != null) {
                        this.onDownloadFinished_(originalID_);
                    }

                }).bind(this);

                var onError_ = (function(originalID_){

                    //console.log("DownloadCache.prototype.downloadERROR:" + this.cache_.hash(originalID_));

                    this.downloading_.splice(this.downloading_.indexOf(this.cache_.hash(originalID_)), 1);
                    this.usedThreads_--;

                }).bind(this);

                if (this.downloadFunction_ != null) {
                    var tmp_ = new this.downloadFunction_(this.browser_, id_, onLoaded_, onError_, this.layer_);
                }
            }
        }
    }
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.Camera = function(parent_, fov_, near_, far_)
{
    this.parent_ = parent_;
    this.position_ = /*(position_ != null) ? position_ :*/ [0,0,0];
    this.orientation_ = /*(orientation_ != null) ? orientation_ :*/ [0,0,0]; // {yaw, pitch, roll}
    this.aspect_ = 1;
    this.fov_ = fov_;
    this.near_ = near_;
    this.far_ = far_;

    // derived quantities, calculated from camera parameters by update()
    this.modelview_ = Vadstena.mat4.create();
    this.rotationview_ = Vadstena.mat4.create();
    this.projection_ = Vadstena.mat4.create();
    this.mvp_ = Vadstena.mat4.create();
    this.frustumPlanes_ = [ [0,0,0,0], [0,0,0,0], [0,0,0,0],
                            [0,0,0,0], [0,0,0,0], [0,0,0,0] ];

    //reduce garbage collection
    this.scaleFactorVec_ = [0,0,0,0];

    this.dirty_ = true;
};

Vadstena.Camera.prototype.setPosition = function(position_) {
    this.position_ = position_;
    this.dirty_ = true;
};

Vadstena.Camera.prototype.setOrientation = function(orientation_) {
    this.orientation_ = orientation_;
    this.dirty_ = true;
};

//! Sets the viewport aspect ratio (width / height). Should be called
//! whenever the rendering viewport changes.
Vadstena.Camera.prototype.setAspect = function(aspect_) {
    this.aspect_ = aspect_;
    this.dirty_ = true;
};

Vadstena.Camera.prototype.setParams = function(fov_, near_, far_) {
    this.fov_ = fov_;
    this.near_ = near_;
    this.far_ = far_;
    this.dirty_ = true;
};

Vadstena.Camera.prototype.clone = function(newFov_) {

    var camera_ = new Vadstena.Camera(this. parent_, (newFov_ != null) ? newFov_ : this.getFov(), this.getNear(), this.getFar());

    camera_.setPosition(this.getPosition());
    camera_.setOrientation(this.getOrientation());
    camera_.setAspect(this.getAspect());
    camera_.update();

    return camera_;
};

// simple getters
Vadstena.Camera.prototype.getPosition = function(){ return [this.position_[0], this.position_[1], this.position_[2]]; };
Vadstena.Camera.prototype.getOrientation = function(){ return [this.orientation_[0], this.orientation_[1], this.orientation_[2]]; };
Vadstena.Camera.prototype.getAspect = function(){ return this.aspect_; };
Vadstena.Camera.prototype.getFov = function(){ return this.fov_; };
Vadstena.Camera.prototype.getNear = function(){ return this.near_; };
Vadstena.Camera.prototype.getFar = function(){ return this.far_; };

//! Returns rotation matrix
Vadstena.Camera.prototype.getRotationviewMatrix = function(){
    if (this.dirty_) this.update();
    return this.rotationview_;
};


//! Returns a matrix that transforms the world space to camera space.
Vadstena.Camera.prototype.getModelviewMatrix = function(){
    if (this.dirty_) this.update();
    return this.modelview_;
};

//! Returns a matrix that transforms the camera space to screen space.
Vadstena.Camera.prototype.getProjectionMatrix = function(){
    if (this.dirty_) this.update();
    return this.projection_;
};

//! Returns projectionMatrix() * modelviewMatrix()
Vadstena.Camera.prototype.getMvpMatrix = function(){
    if (this.dirty_) this.update();
    return this.mvp_;
};

//! Returns how much a length unit located at a point in world space is
//! stretched when projected to the sceen space.
Vadstena.Camera.prototype.scaleFactor = function(worldPos_, returnDist_) {
    if (this.dirty_) this.update();

    //var camPos_ = Vadstena.vec4.create();
    //Vadstena.mat4.multiplyVec4(this.modelview_, worldPos_, camPos_);
    Vadstena.mat4.multiplyVec3(this.modelview_, worldPos_, this.scaleFactorVec_);
    var dist_ = Vadstena.vec3.length(this.scaleFactorVec_); // distance from camera

    // the expression "projection(0,0) / depth" is the derivative of the
    // screen X position by the camera space X coordinate.

    // ('dist' is used instead of camera depth (camPos(2)) to make the tile
    // resolution independent of camera rotation)

    if (returnDist_ == true) {
        if (dist_ < this.near_) return [Number.POSITIVE_INFINITY, dist_];
        return [this.projection_[0] / dist_, dist_];
    }

    if (dist_ < this.near_) return Number.POSITIVE_INFINITY;
    return this.projection_[0] / dist_;
};

Vadstena.Camera.prototype.distance = function(worldPos_) {
    var delta_ = Vadstena.vec3.create();
    Vadstena.vec3.subtract(this.position_, worldPos_, delta_);
    return Vadstena.vec3.length(delta_);
};

//! Returns true if the box intersects the camera frustum.
Vadstena.Camera.prototype.boxVisible = function(box_) {

    //return true;

    if (this.dirty_) this.update();

    var points_ = [
        [ box_.min_[0], box_.min_[1], box_.min_[2], 1 ],
        [ box_.min_[0], box_.min_[1], box_.max_[2], 1 ],
        [ box_.min_[0], box_.max_[1], box_.min_[2], 1 ],
        [ box_.min_[0], box_.max_[1], box_.max_[2], 1 ],
        [ box_.max_[0], box_.min_[1], box_.min_[2], 1 ],
        [ box_.max_[0], box_.min_[1], box_.max_[2], 1 ],
        [ box_.max_[0], box_.max_[1], box_.min_[2], 1 ],
        [ box_.max_[0], box_.max_[1], box_.max_[2], 1 ]
    ];

    // test all frustum planes quickly
    for (var i = 0; i < 6; i++)
    {
        // check if all points lie on the negative side of the frustum plane
        var negative_ = true;
        for (var j = 0; j < 8; j++)
        {
            if (Vadstena.vec4.dot(this.frustumPlanes_[i], points_[j]) >= 0) {
                negative_ = false;
                break;
            }
        }
        if (negative_) return false;
    }

    // the box might be inside - further testing should be done here - TODO!
    return true;
};

Vadstena.Camera.prototype.update = function() {
   // modelview matrix, this is essentially the inverse of a matrix that
    // brings the camera from the origin to its world position (the inverse
    // is trivial here -- negative angles, reverse order of transformations)
    //this.modelview_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(Vadstena.rotationMatrix(2, Vadstena.radians(-this.orientation_[2])), Vadstena.rotationMatrix(0, Vadstena.radians(-this.orientation_[1] - 90.0)), this.rotationview_);
    Vadstena.mat4.multiply(this.rotationview_, Vadstena.rotationMatrix(2, Vadstena.radians(-this.orientation_[0])), this.rotationview_);
    Vadstena.mat4.multiply(this.rotationview_, Vadstena.translationMatrix(-this.position_[0], -this.position_[1], -this.position_[2]), this.modelview_);

    this.projection_ = Vadstena.perspectiveMatrix(this.fov_, this.aspect_, this.near_, this.far_);

    //this.mvp_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.projection_, this.modelview_, this.mvp_);

    // prepare frustum planes (in normalized device coordinates)
    this.frustumPlanes_[0] = [ 0, 0, 1, 1 ]; // far
    this.frustumPlanes_[1] = [ 0, 0,-1, 1 ]; // near
    this.frustumPlanes_[2] = [ 1, 0, 0, 1 ]; // left
    this.frustumPlanes_[3] = [-1, 0, 0, 1 ]; // right
    this.frustumPlanes_[4] = [ 0, 1, 0, 1 ]; // bottom
    this.frustumPlanes_[5] = [ 0,-1, 0, 1 ]; // top

    // transform the frustum planes to the world space, remember that
    // planes in homogeneous coordinates transform as p' = M^{-T} * p, where
    // M^{-T} is the transpose of inverse of M
    var mvpt_ = Vadstena.mat4.create();
    Vadstena.mat4.transpose(this.mvp_, mvpt_);
    for (var i = 0; i < 6; i++) {
        this.frustumPlanes_[i] = Vadstena.mat4.multiplyVec4(mvpt_, this.frustumPlanes_[i]);
    }

    // the derived quantities are now in sync with the parameters
    this.dirty_ = false;
};
Vadstena.geodataProcessorWorker = function() {
//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var layerStyles_ = {};
var layerId_ = {};
var layerBitmaps_ = {};
var forceOrigin_ = false;
var tileX_ = 0;
var tileY_ = 0;
var tileLod_ = 0;
var fonts_ = {};
var hitState_ = 0;
var groupOrigin_ = [0,0,0];
var autoLod_ = false;

var clamp = function(value_, min_, max_) {
    if (value_ < min_) {
        value_ = min_;
    }

    if (value_ > max_) {
        value_ = max_;
    }

    return value_;
};
//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var getStyle = function(styleId_, featureType_, index_) {
    var style_ = layerStyles_.styles_[styleId_];
    if (style_ == null) {
        logError("wrong-style", styleId_, null, null, index_, featureType_);
        return {};
    } else {
        return style_;
    }
};

var getStylePropertyValue = function(style_, key_, feature_, lod_) {

    var value_ = style_[key_];

    switch(typeof value_) {
        case "string":

            if (value_.length > 0) {
                //is it feature property?
                if (value_.charAt(0) == "$") {
                    var finalValue_ = feature_[value_.substr(1)];
                    if (finalValue_ != null) {
                        return finalValue_;
                    } else {
                        logError("wrong-object", style_["$$style-id"], key_, value_, null, "feature-property");
                        getDefaultStylePropertyValue(key_);
                    }
                }
            }

            return value_;

            break;

        case "object":

            //is it null?
            if (value_ == null) {
                return getDefaultStylePropertyValue(key_);
            }

            //is it array (rgb, rgba, vec2)?
            if (Array.isArray(value_) == true) {

                if (key_ == "icon-source" && layerBitmaps_[value_[0]] == null) {
                    logError("wrong-object", style_["$$style-id"], key_, value_, null, "bitmap");
                    return getDefaultStylePropertyValue(key_);
                }

                return value_;
            }

            //debugger

            var stops_ = null;
            var lodScaledArray_ = null;

            if (value_["lod-scaled"] != null) {
                var array_ = value_["lod-scaled"];

                if ((typeof array_[1]) == "number") {
                    return array_[1] * Math.pow(2*array_[2], array_[0] - lod_);
                }

                stops_ = array_[1];
                lodScaledArray_ = array_;

            } else {
                stops_ = value_["discrete"] || value_["linear"];
            }

            var lastLod_ = stops_[0][0];
            var lastValue_ = stops_[0][1];
            var valueType_ = (typeof lastValue_);
            var newValue_ = lastValue_;

            for (var i = 0, li = stops_.length; i <= li; i++) {

                if (i == li) {
                    newValue_ = lastValue_;
                    break;
                }

                if (stops_[i][0] > lod_) {

                    if (value_["discrete"] != null || lodScaledArray_ != null) { //no interpolation
                        newValue_ = lastValue_;
                        break;
                    } else { //interpolate

                        currentLod_ = stops_[i][0];
                        currentValue_ = stops_[i][1];

                        if (currentLod_ == lastLod_) { //end of array no interpolation needed
                            break;
                        }

                        switch(valueType_) {

                            case "boolean":
                                lastValue_ = lastValue_ ? 1 : 0;
                                currentValue_ = lastValue_ ? 1 : 0;
                                var newValue_ = lastValue_ + (currentValue_ - lastValue_) * ((lod_ - lastLod_) / (currentLod_ - lastLod_));

                                newValue_ = newValue_ > 0.5 ? true : false;
                                break;

                            case "number":

                                //debugger
                                var newValue_ = lastValue_ + (currentValue_ - lastValue_) * ((lod_ - lastLod_) / (currentLod_ - lastLod_));
                                break;

                            case "object":
                                var newValue_ = [];

                                for (var j = 0, lj= lastValue_.length; j < lj; j++) {
                                    newValue_[j] = lastValue_[j] + (currentValue_[j] - lastValue_[j]) * ((lod_ - lastLod_) / (currentLod_ - lastLod_));
                                }

                                break;
                        }

                        break;
                    }
                }

                lastLod_ = stops_[i][0];
                lastValue_ = stops_[i][1];
            }

            if (lodScaledArray_ != null) {
                newValue_ *= Math.pow(2*lodScaledArray_[2], lodScaledArray_[0] - lod_);
            }

            return newValue_;

            break;

        case "number":
        case "boolean":
            return value_;
    }

    return getDefaultStylePropertyValue(key_);
};

var inheritStyle = function(styleId_, style_, styleData_, layerStylesData_, depth_) {

    if (depth_ > 100) {
        logError("custom", "infinite inherit loop in style: " + styleId_);
        return;
    }

    //do we need inherite style?
    if (styleData_["inherit"] != null) {
        //get inherited style
        var styleToInherit_ = layerStylesData_["styles"][styleData_["inherit"]];

        if (styleToInherit_ != null) {

            if (styleToInherit_["inherit"] != null) {
                inheritStyle(styleData_["inherit"], style_, styleToInherit_, layerStylesData_, depth_++);
            }

            //copy inherited style properties
            for (var key_ in styleToInherit_) {
                style_[key_] = styleToInherit_[key_];
            }
        } else {
            logError("wrong-object", styleId_, "inherit", styleToInherit_, "style");
            return getDefaultStylePropertyValue(key_);
        }
    }

};

var copyStyle = function(styleId_, style_, styleData_, layerStylesData_) {

    //do we need inherite style?
    if (styleData_["inherit"] != null) {
        inheritStyle(styleId_, style_, styleData_, layerStylesData_, 0);

        /*
        //get inherited style
        var styleToInherit_ = layerStylesData_["styles"][styleData_["inherit"]];

        if (styleToInherit_ != null) {
            //copy inherited style properties
            for (var key_ in styleToInherit_) {
                style_[key_] = styleToInherit_[key_];
            }
        } else {
            logError("wrong-object", styleId_, "inherit", styleToInherit_, "style");
            return getDefaultStylePropertyValue(key_);
        }*/
    }

    //copy style properties
    //if inherited properties are present then they will be overwriten
    for (var key_ in styleData_) {
        style_[key_] = styleData_[key_];
    }

    //store style id
    style_["$$style-id"] = styleId_;
};

var logError = function(errorType_, styleId_, key_, value_, index_, subkey_) {
    if ((typeof value_) == "object") {
        value_ = JSON.stringify(value_);
    }

    switch(errorType_) {
        case "wrong-property-value":
            console.log("Error: wrong style property " + (subkey_ ? ("'" + subkey_ + "'") : "") + ": " + styleId_ + "." + key_ + " = " + value_);
            break;

        case "wrong-property-value[]":
            console.log("Error: wrong style property " + (subkey_ ? ("'" + subkey_ + "'") : "") + "["+index_+"]: " + styleId_ + "." + key_ + " = " + value_);
            break;

        case "wrong-object":
            console.log("Error: reffered "+ subkey_ + " does not exist: " + styleId_ + "." + key_ + " = " + value_);
            break;

        case "wrong-object[]":
            console.log("Error: reffered "+ subkey_ + " does not exist: " + styleId_ + "." + key_ + "["+index_+"] = " + value_);
            break;

        case "wrong-style":
            console.log("Error: reffered "+ subkey_ + " style does not exist: " + subkey_ + "["+index_+"].style = " + styleId_);
            break;

        case "wrong-bitmap":
            console.log("Error: wrong definition of bitmap: " + styleId_);
            break;

        case "custom":
            console.log("Error: " + styleId_);
            break;
    }
};

var validateValue = function(styleId_, key_, value_, type_, arrayLength_, min_, max_) {

    //check interpolator
    if (value_ != null && (typeof value_) == "object" && (value_["discrete"] != null || value_["linear"] != null || value_["lod-scaled"] != null)) {

        var stops_ = null;
        var lodScaled_ = false;

        if (value_["lod-scaled"] != null) {

            var array_ = value_["lod-scaled"];

            if (!((typeof array_) == "object" && Array.isArray(array_) && array_.length >= 2)) {
                logError("wrong-property-value", styleId_, key_, value_, null, "[]");
                return getDefaultStylePropertyValue(key_);
            }

            if (array_[2] == null) {
                array_[2] = 1;
            }

            if (!((typeof array_[0]) == "number" && (typeof array_[2]) == "number")) {
                logError("wrong-property-value", styleId_, key_, value_, null, "[]");
                return getDefaultStylePropertyValue(key_);
            }

            if ((typeof array_[1]) == "number") {
                return value_;
            }

            stops_ = array_[1];
            lodScaled_ = true;

        } else {
            stops_ = value_["discrete"] || value_["linear"];
        }

        //if stops exist then check if they are array
        if (stops_ == null || !((typeof stops_) == "object" && Array.isArray(stops_) && stops_.length > 0)) {
            logError("wrong-property-value", styleId_, key_, value_, null, "[]");
            return getDefaultStylePropertyValue(key_);
        }


        //validate stops values
        if (stops_ != null) {
            var stopsValueType_ = null;

            for (var i = 0, li = stops_.length; i < li; i++) {
                var stopItem_ = stops_[i];

                //is stop array[2]?
                if(!(stopItem_ != null && (typeof stopItem_) == "object" && Array.isArray(stopItem_) && stopItem_.length != 2)) {

                    //store fist stop type
                    if (stopsValueType_ == null) {
                        stopsValueType_ = typeof stopItem_[1];

                        if (lodScaled_ == true && stopsValueType_ != "number") {
                            logError("wrong-property-value[]", styleId_, key_, value_, i, "[]");
                            return getDefaultStylePropertyValue(key_);
                        }
                    }

                    //check lod value and type of value
                    if(!((typeof stopItem_[0]) == "number" && (typeof stopItem_[1]) == stopsValueType_)) {
                        logError("wrong-property-value[]", styleId_, key_, value_, i, "[]");
                        return getDefaultStylePropertyValue(key_);
                    }

                    //check number value
                    if (stopsValueType_ == "number") {
                        if (stopItem_[1] > max_ || stopItem_[1] < min_) {
                            logError("wrong-property-value[]", styleId_, key_, value_, i, "[]");
                            return getDefaultStylePropertyValue(key_);
                        }
                    }
                }
            }
        }


        return value_;
    }

    //console.log("validate."+styleId_+"."+key_+"."+value_);

    //check value type
    if ((typeof value_) != type_) {
        //check for exceptions
        if (!(value_ === null && (key_ == "icon-source" || key_ == "visibility"))) {
            logError("wrong-property-value", styleId_, key_, value_);
            return getDefaultStylePropertyValue(key_);
        }
    }

    //check value
    switch(typeof value_) {

        case "object":

            //accepted cases for null value
            if (value_ === null && (key_ == "line-style-texture" || key_ == "icon-source" || key_ == "visibility" || key_ == "multi-pass")) {
                return value_;
            }

            //check multipasss
            if (key_ == "multi-pass") {
                if (Array.isArray(value_) == true && value_.length > 0) {

                    for (var i = 0; i < li; i++) {
                        var valueItem_ = value_[i];

                        if (typeof valueItem_ == "object" &&
                            Array.isArray(valueItem_) == true &&
                            valueItem_.length == 2 &&
                            typeof valueItem_[0] == "number" &&
                            typeof valueItem_[1] == "string") {

                            if (layerStylesData_["styles"][valueItem_[1]] == null) {

                            }

                        } else {
                            logError("wrong-property-value[]", styleId_, key_, value_, i);
                            return getDefaultStylePropertyValue(key_);
                        }
                    }

                } else {
                    logError("wrong-property-value", styleId_, key_, value_);
                    return getDefaultStylePropertyValue(key_);
                }
            }

            //check array
            if (arrayLength_ != null) {
                if (Array.isArray(value_) == true && value_.length == arrayLength_) {

                    //validate array values
                    var i = 0;

                    if (key_ == "icon-source" || key_ == "line-style-texture") {
                        if (typeof value_[0] != "string") {
                            logError("wrong-property-value[]", styleId_, key_, value_, 0);
                            return getDefaultStylePropertyValue(key_);
                        }

                        if (layerBitmaps_[value_[0]] == null) {
                            logError("wrong-object", styleId_, key_, value_, null, "bitmap");
                            return getDefaultStylePropertyValue(key_);
                        }

                        i = 1;
                    }

                    for (li = value_.length; i < li; i++) {
                        if (typeof value_[i] != "number") {
                            logError("wrong-property-value[]", styleId_, key_, value_, i);
                            return getDefaultStylePropertyValue(key_);
                        }
                    }

                    return value_;
                } else {
                    logError("wrong-property-value", styleId_, key_, value_);
                    return getDefaultStylePropertyValue(key_);
                }
            }

            return value_;

        case "string":

            //validate line style enum
            if (key_ == "line-style") {
                switch(value_) {
                    case "solid":
                    case "texture": return value_;
                    default:
                        logError("wrong-property-value", styleId_, key_, value_);
                        return getDefaultStylePropertyValue(key_);
                }
            }

            //validate origin enum
            if (key_ == "label-origin" || key_ == "icon-origin") {
                switch(value_) {
                    case "top-left":
                    case "top-right":
                    case "top-center":
                    case "center-left":
                    case "center-right":
                    case "center-center":
                    case "bottom-left":
                    case "bottom-right":
                    case "bottom-center":   return value_;
                    default:
                        logError("wrong-property-value", styleId_, key_, value_);
                        return getDefaultStylePropertyValue(key_);
                }
            }

            //validate align enum
            if (key_ == "label-align") {
                switch(value_) {
                    case "left":
                    case "right":
                    case "center":  return value_;
                    default:
                        logError("wrong-property-value", styleId_, key_, value_);
                        return getDefaultStylePropertyValue(key_);
                }
            }

            return value_;

        case "number":

            //console.log("num2");

            if (value_ > max_ || value_ < min_) {
                logError("wrong-property-value", styleId_, key_, value_);
                return getDefaultStylePropertyValue(key_);
            }

            //console.log("num3");

            return value_;

        case "boolean":
            return value_;
    }

};

var validateStylePropertyValue = function(styleId_, key_, value_) {

    //console.log("vall:"+styleId_+"."+key_+"."+value_);
    //debugger;

    switch(key_) {
       case "inherit" :    return validateValue(styleId_, key_, value_, "string"); break;

       case "line":        return validateValue(styleId_, key_, value_, "boolean"); break;
       case "line-flat":   return validateValue(styleId_, key_, value_, "boolean"); break;
       case "line-width":  return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "line-color":  return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;
       case "line-style":  return validateValue(styleId_, key_, value_, "string"); break;
       case "line-style-texture":    return validateValue(styleId_, key_, value_, "object", 3, -Number.MAX_VALUE, Number.MAX_VALUE); break;
       case "line-style-background": return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;

       case "line-label":         return validateValue(styleId_, key_, value_, "boolean"); break;
       case "line-label-source":  return validateValue(styleId_, key_, value_, "string"); break;
       case "line-label-color":   return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;
       case "line-label-size":    return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "line-label-offset":  return validateValue(styleId_, key_, value_, "number", null, -Number.MAX_VALUE, Number.MAX_VALUE); break;

       case "point":        return validateValue(styleId_, key_, value_, "boolean"); break;
       case "point-flat":   return validateValue(styleId_, key_, value_, "boolean"); break;
       case "point-radius": return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "point-style":  return validateValue(styleId_, key_, value_, "string"); break;

       case "point-color":  return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;

       case "icon":         return validateValue(styleId_, key_, value_, "boolean"); break;
       case "icon-source":  return validateValue(styleId_, key_, value_, "object", 5, -Number.MAX_VALUE, Number.MAX_VALUE); break;
       case "icon-scale":   return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "icon-offset":  return validateValue(styleId_, key_, value_, "object", 2, -Number.MAX_VALUE, Number.MAX_VALUE); break;
       case "icon-origin":  return validateValue(styleId_, key_, value_, "string"); break;
       case "icon-color":   return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;

       case "label":         return validateValue(styleId_, key_, value_, "boolean"); break;
       case "label-color":   return validateValue(styleId_, key_, value_, "object", 4, 0, 255); break;
       case "label-source":  return validateValue(styleId_, key_, value_, "string"); break;
       case "label-size":    return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "label-offset":  return validateValue(styleId_, key_, value_, "object", 2, -Number.MAX_VALUE, Number.MAX_VALUE); break;
       case "label-origin":  return validateValue(styleId_, key_, value_, "string"); break;
       case "label-align":   return validateValue(styleId_, key_, value_, "string"); break;
       case "label-width":   return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;

       case "z-index":        return validateValue(styleId_, key_, value_, "number", null, -Number.MAX_VALUE, Number.MAX_VALUE); break;
       case "zbuffer-offset": return validateValue(styleId_, key_, value_, "object", 3, 0, Number.MAX_VALUE); break;

       case "hover-event":  return validateValue(styleId_, key_, value_, "boolean"); break;
       case "hover-style":  return validateValue(styleId_, key_, value_, "string"); break;
       case "enter-event":  return validateValue(styleId_, key_, value_, "boolean"); break;
       case "leave-event":  return validateValue(styleId_, key_, value_, "boolean"); break;
       case "click-event":  return validateValue(styleId_, key_, value_, "boolean"); break;
       case "draw-event":   return validateValue(styleId_, key_, value_, "boolean"); break;

       case "visible":     return validateValue(styleId_, key_, value_, "boolean"); break;
       case "visibility":  return validateValue(styleId_, key_, value_, "number", null, 0.0001, Number.MAX_VALUE); break;
       case "multi-pass":  return validateValue(styleId_, key_, value_, "object"); break;
    }

    return value_; //custom property
};

var getDefaultStylePropertyValue = function(key_) {
    switch(key_) {
       case "inherit": return "";

       case "line":       return false;
       case "line-flat":  return false;
       case "line-width": return 1;
       case "line-color": return [255,255,255,255];
       case "line-style": return "solid";
       case "line-style-texture":    return null;
       case "line-style-background": return [0,0,0,0];

       case "line-label":        return false;
       case "line-label-color":  return [255,255,255,255];
       case "line-label-source": return "name";
       case "line-label-size":   return 1;
       case "line-label-offset": return 0;

       case "point":        return false;
       case "point-flat":   return false;
       case "point-radius": return 1;
       case "point-style":  return "solid";
       case "point-color":  return [255,255,255,255];

       case "icon":        return false;
       case "icon-source": return null;
       case "icon-scale":  return 1;
       case "icon-offset": return [0,0];
       case "icon-origin": return "bottom-center";
       case "icon-color":  return [255,255,255,255];

       case "label":         return false;
       case "label-color":   return [255,255,255,255];
       case "label-source":  return "name";
       case "label-size":    return 10;
       case "label-offset":  return [0,0];
       case "label-origin":  return "bottom-center";
       case "label-align":   return "center";
       case "label-width":   return 200;

       case "z-index":        return 0;
       case "zbuffer-offset": return [1,1,1];

       case "hover-event": return false;
       case "hover-style": return "";
       case "enter-event": return false;
       case "leave-event": return false;
       case "click-event": return false;
       case "draw-event":  return false;

       case "visible":    return true;
       case "visibility": return 0;
       case "multi-pass": return null;
    }
};


var processStyle = function(styleId_, styleData_, layerStylesData_) {

    var style_ = {};

    //copy style and inherit style if needed
    copyStyle(styleId_, style_, styleData_, layerStylesData_);

    //console.log(JSON.stringify(style_));

    //replace constants and validate properties
    for (var key_ in style_) {

        var value_ = style_[key_];

        //replace constant with value
        if ((typeof value_) == "string") {
            if (value_.length > 0) {
                //is it constant?
                if (value_.charAt(0) == "@") {

                    if (layerStylesData_["constants"] != null) {
                        if (layerStylesData_["constants"][value_] != null) {

                            //replace constant with value
                            style_[key_] = layerStylesData_["constants"][value_];
                        } else {
                            logError("wrong-object", styleId_, key_, value_, null, "constant");

                            //replace constant with deafault value
                            style_[key_] = getDefaultStylePropertyValue(key_);
                        }
                    } else {
                        logError("wrong-object", styleId_, key_, value_, null, "constant");

                        //replace constant with deafault value
                        style_[key_] = getDefaultStylePropertyValue(key_);
                    }
                }
            }
        }

        //console.log("process."+styleId_+"."+key_+"."+value_);
        //console.log("out1: "+JSON.stringify(style_[key_]));

        style_[key_] = validateStylePropertyValue(styleId_, key_, style_[key_]);

        //console.log("out2: "+JSON.stringify(style_[key_]));
    }

    return style_;
};

var processStyles = function(layerStylesData_) {

    layerBitmaps_ = {};

    //get bitmaps
    var bitmaps_ = layerStylesData_["bitmaps"] || {};

    //build map
    for (var key_ in bitmaps_) {
        var bitmap_ = bitmaps_[key_];
        var skip_ = false;

        if ((typeof bitmap_) == "string") {
            bitmap_ = {"url":bitmap_};
        } else if((typeof bitmap_) == "object"){
            if (bitmap_["url"] == null) {
                logError("wrong-bitmap", key_);
            }
        } else {
            logError("wrong-bitmap", key_);
        }

        if (skip_ != true) {
            layerBitmaps_[key_] = bitmap_;
        }
    }

    //load bitmaps
    postMessage({"command":"loadBitmaps", "bitmaps": layerBitmaps_});

    //get layers
    layerStyles_ = {
        styles_ : {}
    };

    var styles_ = layerStylesData_["styles"] || {};

    //console.log(JSON.stringify(styles_));

    //process layers
    for (var key_ in styles_) {
        layerStyles_.styles_[key_] = processStyle(key_, styles_[key_], layerStylesData_);

        //console.log(JSON.stringify(layerStyles_.styles_[key_]));
    }
};


//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var processLineStringPass = function(lineString_, lod_, style_, zIndex_, eventInfo_) {

    var points_ = lineString_["points"] || [];

    if (points_.length == 0) {
        return;
    }

    var line_ = getStylePropertyValue(style_, "line", lineString_, lod_);

    if (line_ == false) {
        return;
    }

    var hoverEvent_ = getStylePropertyValue(style_, "hover-event", lineString_, lod_);
    var clickEvent_ = getStylePropertyValue(style_, "click-event", lineString_, lod_);
    var drawEvent_ = getStylePropertyValue(style_, "draw-event", lineString_, lod_);
    var enterEvent_ = getStylePropertyValue(style_, "enter-event", lineString_, lod_);
    var leaveEvent_ = getStylePropertyValue(style_, "leave-event", lineString_, lod_);

    var zbufferOffset_ = getStylePropertyValue(style_, "zbuffer-offset", lineString_, lod_);

    var lineFlat_ = getStylePropertyValue(style_, "line-flat", lineString_, lod_);
    var lineColor_ = getStylePropertyValue(style_, "line-color", lineString_, lod_);
    var lineWidth_ = 0.5 * getStylePropertyValue(style_, "line-width", lineString_, lod_);

    var lineStyle_ = getStylePropertyValue(style_, "line-style", lineString_, lod_);
    var lineStyleTexture_ = getStylePropertyValue(style_, "line-style-texture", lineString_, lod_);
    var lineStyleBackground_ = getStylePropertyValue(style_, "line-style-background", lineString_, lod_);

    var lineLabel_ = getStylePropertyValue(style_, "line-label", lineString_, lod_);
    var lineLabelSize_ = getStylePropertyValue(style_, "line-label-size", lineString_, lod_);

    if (lineLabel_ == true) {
        var lineLabelPoints_ = new Array(points_.length);
        var lineLabelPoints2_ = new Array(points_.length);
    }

    //console.log("lineflat: "+lineFlat_);
    //var lineWidth_ = Math.pow(2, 23 - lod_) / 32;

    var index_ = 0;
    var index2_ = 0;

    //console.log("lod: " + lod_ + "  width: " + lineWidth_);

    var circleBuffer_ = [];
    var circleBuffer2_ = [];
    var circleSides_ = 8;//Math.max(8, (14 - lod_) * 8);

    var angle_ = 0, step_ = (2.0*Math.PI) / circleSides_;

    for (var i = 0; i < circleSides_; i++) {
        circleBuffer_[i] = [-Math.sin(angle_), Math.cos(angle_)];
        circleBuffer2_[i] = angle_;
        angle_ += step_;
    }

    circleBuffer_[circleSides_] = [0, 1.0];
    circleBuffer2_[circleSides_] = 0;


    var p = points_[0];
    var p1 = [p[0], p[1], p[2]];

    if (forceOrigin_ == true) {
        p1 = [p1[0] - tileX_, p1[1] - tileY_, p1[2]];
    }

    if (forceScale_ != null) {
        p1 = [p1[0] * forceScale_[0], p1[1] * forceScale_[1], p1[2] * forceScale_[2]];
    }

    var texturedLine_ = (lineStyle_ != "solid");

    //allocate buffers
    var lineVertices_ = (texturedLine_ || !lineFlat_ ? 4 : 3) * 3 * 2;
    var joinVertices_ = circleSides_ * (texturedLine_ || !lineFlat_? 4 : 3) * 3;
    var vertexBuffer_ = new Array(points_.length * lineVertices_ + points_.length * joinVertices_);

    if (lineFlat_ == false || texturedLine_ == true) {
        var lineNormals_ = 3 * 4 * 2;
        var joinNormals_ = circleSides_ * 3 * 4;
        var normalBuffer_ = new Array(points_.length * lineNormals_ + points_.length * joinNormals_);
    }

    if (texturedLine_ == true) {
        var joinParams_ = Array(points_.length);
    }

    var dlines_ = false;
    var distance_ = 0.001;
    var distance2_ = 0.001;

    //add lines
    for (var i = 0, li = points_.length - 1; i < li; i++) {

        if (dlines_ == true) {
            var p2 = points_[i+1];
            p2 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];

            if (forceOrigin_ == true) {
                p2 = [p2[0] - tileX_, p2[1] - tileY_, p2[2]];
            }

            if (forceScale_ != null) {
                p2 = [p2[0] * forceScale_[0], p2[1] * forceScale_[1], p2[2] * forceScale_[2]];
            }

        } else {
            p1 = points_[i];
            var p2 = points_[i+1];

            if (forceOrigin_ == true) {
                p1 = [p1[0] - tileX_, p1[1] - tileY_, p1[2]];
                p2 = [p2[0] - tileX_, p2[1] - tileY_, p2[2]];
            }

            if (forceScale_ != null) {
                p1 = [p1[0] * forceScale_[0], p1[1] * forceScale_[1], p1[2] * forceScale_[2]];
                p2 = [p2[0] * forceScale_[0], p2[1] * forceScale_[1], p2[2] * forceScale_[2]];
            }
        }


        if (lineFlat_ == true && !texturedLine_) {

            //direction vector
            var v = [p2[0] - p1[0], p2[1] - p1[1], 0];

            //get line length
            var l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
            distance2_ += l;

            //normalize vector to line width and rotate 90 degrees
            l = (l != 0) ? (lineWidth_ / l) : 0;
            var n = [-v[1]*l, v[0]*l,0];

            //add polygon
            vertexBuffer_[index_] = p1[0] + n[0];
            vertexBuffer_[index_+1] = p1[1] + n[1];
            vertexBuffer_[index_+2] = p1[2];

            vertexBuffer_[index_+3] = p1[0] - n[0];
            vertexBuffer_[index_+4] = p1[1] - n[1];
            vertexBuffer_[index_+5] = p1[2];

            vertexBuffer_[index_+6] = p2[0] + n[0];
            vertexBuffer_[index_+7] = p2[1] + n[1];
            vertexBuffer_[index_+8] = p2[2];

            //add polygon
            vertexBuffer_[index_+9] = p1[0] - n[0];
            vertexBuffer_[index_+10] = p1[1] - n[1];
            vertexBuffer_[index_+11] = p1[2];

            vertexBuffer_[index_+12] = p2[0] - n[0];
            vertexBuffer_[index_+13] = p2[1] - n[1];
            vertexBuffer_[index_+14] = p2[2];

            vertexBuffer_[index_+15] = p2[0] + n[0];
            vertexBuffer_[index_+16] = p2[1] + n[1];
            vertexBuffer_[index_+17] = p2[2];

            index_ += 18;

        } else {

            //direction vector
            var v = [p2[0] - p1[0], p2[1] - p1[1], 0];

            //get line length
            var l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
            distance2_ += l;

            //console.log("distance("+i+"): " + distance_ + " " + distance2_);

            if (lineFlat_ == true) {

                //normalize vector to line width and rotate 90 degrees
                l = (l != 0) ? (lineWidth_ / l) : 0;
                var n = [-v[1]*l, v[0]*l,0];

                if (joinParams_ != null) {
                    joinParams_[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;
                }

                //add polygon
                vertexBuffer_[index_] = p1[0];
                vertexBuffer_[index_+1] = p1[1];
                vertexBuffer_[index_+2] = p1[2];
                vertexBuffer_[index_+3] = distance_;
                normalBuffer_[index2_] = n[0];
                normalBuffer_[index2_+1] = n[1];
                normalBuffer_[index2_+2] = 0;
                normalBuffer_[index2_+3] = lineWidth_;

                vertexBuffer_[index_+4] = p1[0];
                vertexBuffer_[index_+5] = p1[1];
                vertexBuffer_[index_+6] = p1[2];
                vertexBuffer_[index_+7] = -distance_;
                normalBuffer_[index2_+4] = -n[0];
                normalBuffer_[index2_+5] = -n[1];
                normalBuffer_[index2_+6] = 0;
                normalBuffer_[index2_+7] = -lineWidth_;

                vertexBuffer_[index_+8] = p2[0];
                vertexBuffer_[index_+9] = p2[1];
                vertexBuffer_[index_+10] = p2[2];
                vertexBuffer_[index_+11] = distance2_;
                normalBuffer_[index2_+8] = n[0];
                normalBuffer_[index2_+9] = n[1];
                normalBuffer_[index2_+10] = 0;
                normalBuffer_[index2_+11] = lineWidth_;

                //add polygon
                vertexBuffer_[index_+12] = p1[0];
                vertexBuffer_[index_+13] = p1[1];
                vertexBuffer_[index_+14] = p1[2];
                vertexBuffer_[index_+15] = -distance_;
                normalBuffer_[index2_+12] = -n[0];
                normalBuffer_[index2_+13] = -n[1];
                normalBuffer_[index2_+14] = 0;
                normalBuffer_[index2_+15] = -lineWidth_;

                vertexBuffer_[index_+16] = p2[0];
                vertexBuffer_[index_+17] = p2[1];
                vertexBuffer_[index_+18] = p2[2];
                vertexBuffer_[index_+19] = -distance2_;
                normalBuffer_[index2_+16] = -n[0];
                normalBuffer_[index2_+17] = -n[1];
                normalBuffer_[index2_+18] = 0;
                normalBuffer_[index2_+19] = -lineWidth_;

                vertexBuffer_[index_+20] = p2[0];
                vertexBuffer_[index_+21] = p2[1];
                vertexBuffer_[index_+22] = p2[2];
                vertexBuffer_[index_+23] = distance2_;
                normalBuffer_[index2_+20] = n[0];
                normalBuffer_[index2_+21] = n[1];
                normalBuffer_[index2_+22] = 0;
                normalBuffer_[index2_+23] = lineWidth_;

                index_ += 24;
                index2_ += 24;

            } else {

                //add polygon
                vertexBuffer_[index_] = p1[0];
                vertexBuffer_[index_+1] = p1[1];
                vertexBuffer_[index_+2] = p1[2];
                vertexBuffer_[index_+3] = distance_;
                normalBuffer_[index2_] = p2[0];
                normalBuffer_[index2_+1] = p2[1];
                normalBuffer_[index2_+2] = p2[2];
                normalBuffer_[index2_+3] = lineWidth_;

                vertexBuffer_[index_+4] = p1[0];
                vertexBuffer_[index_+5] = p1[1];
                vertexBuffer_[index_+6] = p1[2];
                vertexBuffer_[index_+7] = -distance_;
                normalBuffer_[index2_+4] = p2[0];
                normalBuffer_[index2_+5] = p2[1];
                normalBuffer_[index2_+6] = p2[2];
                normalBuffer_[index2_+7] = -lineWidth_;

                vertexBuffer_[index_+8] = p2[0];
                vertexBuffer_[index_+9] = p2[1];
                vertexBuffer_[index_+10] = p2[2];
                vertexBuffer_[index_+11] = -distance2_;
                normalBuffer_[index2_+8] = p1[0];
                normalBuffer_[index2_+9] = p1[1];
                normalBuffer_[index2_+10] = p1[2];
                normalBuffer_[index2_+11] = lineWidth_;

                //add polygon
                vertexBuffer_[index_+12] = p1[0];
                vertexBuffer_[index_+13] = p1[1];
                vertexBuffer_[index_+14] = p1[2];
                vertexBuffer_[index_+15] = distance_;
                normalBuffer_[index2_+12] = p2[0];
                normalBuffer_[index2_+13] = p2[1];
                normalBuffer_[index2_+14] = p2[2];
                normalBuffer_[index2_+15] = lineWidth_;

                vertexBuffer_[index_+16] = p2[0];
                vertexBuffer_[index_+17] = p2[1];
                vertexBuffer_[index_+18] = p2[2];
                vertexBuffer_[index_+19] = -distance2_;
                normalBuffer_[index2_+16] = p1[0];
                normalBuffer_[index2_+17] = p1[1];
                normalBuffer_[index2_+18] = p1[2];
                normalBuffer_[index2_+19] = lineWidth_;

                vertexBuffer_[index_+20] = p2[0];
                vertexBuffer_[index_+21] = p2[1];
                vertexBuffer_[index_+22] = p2[2];
                vertexBuffer_[index_+23] = distance2_;
                normalBuffer_[index2_+20] = p1[0];
                normalBuffer_[index2_+21] = p1[1];
                normalBuffer_[index2_+22] = p1[2];
                normalBuffer_[index2_+23] = -lineWidth_;

                index_ += 24;
                index2_ += 24;
            }
        }

        distance_ = distance2_;
        p1 = p2; //only for dlines
    }

    var p1 = [p[0], p[1], p[2]];
    var center_ = [0,0,0];

    var lindex_ = index_; //debug only
    var lindex2_ = index2_; //debug only

    //add joins
    for (var i = 0, li = points_.length; i < li; i++) {

        if (forceOrigin_ == true) {
            p1 = [p1[0] - tileX_, p1[1] - tileY_, p1[2]];
        }

        if (forceScale_ != null) {
            p1 = [p1[0] * forceScale_[0], p1[1] * forceScale_[1], p1[2] * forceScale_[2]];
        }

        center_[0] += p1[0];
        center_[1] += p1[1];
        center_[2] += p1[2];

        var angleShift_ = (joinParams_ != null) ? joinParams_[i] : 0;

        for (var j = 0; j < circleSides_; j++) {

            if (lineFlat_ == true && !texturedLine_) {

                //add polygon
                vertexBuffer_[index_] = p1[0];
                vertexBuffer_[index_+1] = p1[1];
                vertexBuffer_[index_+2] = p1[2];

                vertexBuffer_[index_+3] = p1[0] + circleBuffer_[j][0] * lineWidth_;
                vertexBuffer_[index_+4] = p1[1] + circleBuffer_[j][1] * lineWidth_;
                vertexBuffer_[index_+5] = p1[2];

                vertexBuffer_[index_+6] = p1[0] + circleBuffer_[j+1][0] * lineWidth_;
                vertexBuffer_[index_+7] = p1[1] + circleBuffer_[j+1][1] * lineWidth_;
                vertexBuffer_[index_+8] = p1[2];

                index_ += 9;

            } else {

                //distance_ = vertexBuffer_[(i >> 1) * lineVertices_ + ((i & 1) ? 11 : 3)];
                if (i != (li-1)) {
                    distance_ = vertexBuffer_[i * lineVertices_ + 3];
                } else {
                    distance_ = vertexBuffer_[(i - 1) * lineVertices_ + 11];
                }
                //distance_ = vertexBuffer_[((i == li) ? i - 1 : i) * lineVertices_ + 3];

                //if (distance_ == null) {
                  //  debugger
                //}

                //console.log("distance-dot("+i+"): " + distance_);

                //add polygon
                vertexBuffer_[index_] = p1[0];
                vertexBuffer_[index_+1] = p1[1];
                vertexBuffer_[index_+2] = p1[2];
                vertexBuffer_[index_+3] = distance_;
                normalBuffer_[index2_] = 0;
                normalBuffer_[index2_+1] = 0;
                normalBuffer_[index2_+2] = 0;
                normalBuffer_[index2_+3] = 0;

                vertexBuffer_[index_+4] = p1[0];
                vertexBuffer_[index_+5] = p1[1];
                vertexBuffer_[index_+6] = p1[2];
                vertexBuffer_[index_+7] = distance_;
                normalBuffer_[index2_+4] = circleBuffer_[j][0] * lineWidth_;
                normalBuffer_[index2_+5] = circleBuffer_[j][1] * lineWidth_;
                normalBuffer_[index2_+6] = circleBuffer2_[j] + angleShift_;
                normalBuffer_[index2_+7] = 0;

                vertexBuffer_[index_+8] = p1[0];
                vertexBuffer_[index_+9] = p1[1];
                vertexBuffer_[index_+10] = p1[2];
                vertexBuffer_[index_+11] = distance_;
                normalBuffer_[index2_+8] = circleBuffer_[j+1][0] * lineWidth_;
                normalBuffer_[index2_+9] = circleBuffer_[j+1][1] * lineWidth_;
                normalBuffer_[index2_+10] = circleBuffer2_[j+1] + angleShift_;
                normalBuffer_[index2_+11] = 0;

                index_ += 12;
                index2_ += 12;
            }

        }

        if (lineLabel_ == true) {
            var p = [p1[0], p1[1], p1[2] + lineLabelSize_*0.1];
            lineLabelPoints_[i] = p;
            lineLabelPoints2_[li - i - 1] = p;
        }

        if (dlines_ == true) {
            var p2 = points_[i+1];
            p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];
        } else {
            p1 = points_[i+1];
        }
    }

    if (li > 0) {
        center_[0] /= li;
        center_[1] /= li;
        center_[2] /= li;
    }

    center_[0] += groupOrigin_[0];
    center_[1] += groupOrigin_[1];
    center_[2] += groupOrigin_[2];

    //debug only
    //if (vertexBuffer_ != null) { vertexBuffer_ = vertexBuffer_.slice(lindex_); }
    //if (normalBuffer_ != null) { normalBuffer_ = normalBuffer_.slice(lindex2_); }

    var hitable_ = hoverEvent_ || clickEvent_ || enterEvent_ || leaveEvent_;

    var messageData_ = {"command":"addRenderJob", "vertexBuffer": vertexBuffer_,
                        "color":lineColor_, "z-index":zIndex_, "center": center_, "normalBuffer": normalBuffer_,
                        "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                        "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                        "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                        "line-width":lineWidth_*2, "lod":(autoLod_ ? null : tileLod_) };

    if (lineFlat_ == true) {
        messageData_["type"] = (texturedLine_ == true) ? "flat-tline" : "flat-line";
    } else {
        messageData_["type"] = (texturedLine_ == true) ? "pixel-tline" : "pixel-line";
    }

    if (texturedLine_ == true) {
        if (lineStyleTexture_ != null) {
            messageData_["texture"] = [layerBitmaps_[lineStyleTexture_[0]], lineStyleTexture_[1], lineStyleTexture_[2]];
            messageData_["background"] = lineStyleBackground_;
        }
    }

    postMessage(messageData_);

    //debugger
    var lineLabel_ = getStylePropertyValue(style_, "line-label", lineString_, lod_);

    if (lineLabel_ == true) {
        processLineLabel(lineLabelPoints_, lineLabelPoints2_, lineString_, center_, lod_, style_, zIndex_, eventInfo_);
    }

};

var processLineLabel = function(lineLabelPoints_, lineLabelPoints2_, lineString_, center_, lod_, style_, zIndex_, eventInfo_) {

    var labelColor_ = getStylePropertyValue(style_, "line-label-color", lineString_, lod_);
    var labelSource_ = getStylePropertyValue(style_, "line-label-source", lineString_, lod_);
    var labelSize_ = getStylePropertyValue(style_, "line-label-size", lineString_, lod_);
    var labelOffset_ = getStylePropertyValue(style_, "line-label-offset", lineString_, lod_);

    //console.log("label size: " + lod_ + "   " + labelSize_);

    if (labelSource_ == null || labelSource_ == "" || Math.abs(labelSize_) < 0.0001) {
        return;
    }

    var hoverEvent_ = getStylePropertyValue(style_, "hover-event", lineString_, lod_);
    var clickEvent_ = getStylePropertyValue(style_, "click-event", lineString_, lod_);
    var drawEvent_ = getStylePropertyValue(style_, "draw-event", lineString_, lod_);
    var enterEvent_ = getStylePropertyValue(style_, "enter-event", lineString_, lod_);
    var leaveEvent_ = getStylePropertyValue(style_, "leave-event", lineString_, lod_);

    var zbufferOffset_ = getStylePropertyValue(style_, "zbuffer-offset", lineString_, lod_);

    var vertexBuffer_ = [];
    var texcoordsBuffer_ = [];

    //debugger

    var hitable_ = hoverEvent_ || clickEvent_ || enterEvent_ || leaveEvent_;

    addStreetTextOnPath(lineLabelPoints_, labelSource_, labelSize_, fonts_["default"], labelOffset_, vertexBuffer_, texcoordsBuffer_);
    addStreetTextOnPath(lineLabelPoints2_, labelSource_, labelSize_, fonts_["default"], labelOffset_, vertexBuffer_, texcoordsBuffer_);

    postMessage({"command":"addRenderJob", "type": "line-label", "vertexBuffer": vertexBuffer_,
                  "texcoordsBuffer": texcoordsBuffer_, "color":labelColor_, "z-index":zIndex_, "center": center_,
                  "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                  "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                  "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                  "lod":(autoLod_ ? null : tileLod_) });

};


//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var processPointArrayPass = function(pointArray_, lod_, style_, zIndex_, eventInfo_) {

    var points_ = pointArray_["points"] || [];

    if (points_.length == 0) {
        return;
    }

    //debugger
    var visibility_ = getStylePropertyValue(style_, "visibility", pointArray_, lod_);
    var hoverEvent_ = getStylePropertyValue(style_, "hover-event", pointArray_, lod_);
    var clickEvent_ = getStylePropertyValue(style_, "click-event", pointArray_, lod_);
    var drawEvent_ = getStylePropertyValue(style_, "draw-event", pointArray_, lod_);
    var enterEvent_ = getStylePropertyValue(style_, "enter-event", pointArray_, lod_);
    var leaveEvent_ = getStylePropertyValue(style_, "leave-event", pointArray_, lod_);

    var zbufferOffset_ = getStylePropertyValue(style_, "zbuffer-offset", pointArray_, lod_);

    var point_ = getStylePropertyValue(style_, "point", pointArray_, lod_);
    var pointFlat_ = getStylePropertyValue(style_, "point-flat", pointArray_, lod_);
    var pointColor_ = getStylePropertyValue(style_, "point-color", pointArray_, lod_);
    var pointRadius_ = 0.5 * getStylePropertyValue(style_, "point-radius", pointArray_, lod_);
    //zIndex_ = (zIndex_ !== null) ? zIndex_ : getStylePropertyValue(style_, "z-index", pointArray_, lod_);

    var icon_ = getStylePropertyValue(style_, "icon", pointArray_, lod_);
    if (icon_ == true) {
        var iconData_ = {
            color_ : getStylePropertyValue(style_, "icon-color", pointArray_, lod_),
            scale_ : getStylePropertyValue(style_, "icon-scale", pointArray_, lod_),
            offset_ : getStylePropertyValue(style_, "icon-offset", pointArray_, lod_),
            origin_ : getStylePropertyValue(style_, "icon-origin", pointArray_, lod_),
            source_ : getStylePropertyValue(style_, "icon-source", pointArray_, lod_),
            vertexBuffer_ : [],
            originBuffer_ : [],
            texcoordsBuffer_ : []
        };
    }

    var label_ = getStylePropertyValue(style_, "label", pointArray_, lod_);
    if (label_ == true) {
        var labelData_ = {
            color_ : getStylePropertyValue(style_, "label-color", pointArray_, lod_),
            size_ : getStylePropertyValue(style_, "label-size", pointArray_, lod_),
            offset_ : getStylePropertyValue(style_, "label-offset", pointArray_, lod_),
            origin_ : getStylePropertyValue(style_, "label-origin", pointArray_, lod_),
            align_ : getStylePropertyValue(style_, "label-align", pointArray_, lod_),
            source_ : getStylePropertyValue(style_, "label-source", pointArray_, lod_),
            width_ : getStylePropertyValue(style_, "label-width", pointArray_, lod_),
            vertexBuffer_ : [],
            originBuffer_ : [],
            texcoordsBuffer_ : []
        };
    }

    var index_ = 0;
    var index2_ = 0;

    var circleBuffer_ = [];
    var circleSides_ = clamp(pointRadius_ * 8 * 0.5, 8, 32);

    var angle_ = 0, step_ = (2.0*Math.PI) / circleSides_;

    for (var i = 0; i < circleSides_; i++) {
        circleBuffer_[i] = [-Math.sin(angle_), Math.cos(angle_)];
        angle_ += step_;
    }

    circleBuffer_[circleSides_] = [0, 1.0];

    var p = points_[0];
    var p1 = [p[0], p[1], p[2]];
    var center_ = [0,0,0];

    //allocate buffers
    var pointsVertices_ = circleSides_ * 3 * 3;
    var vertexBuffer_ = new Array(points_.length * pointsVertices_);

    if (pointFlat_ == false) {
        var pointsNormals_ = circleSides_ * 3 * 4;
        var normalBuffer_ = new Array(points_.length * pointsNormals_);
    }

    var dpoints_ = false;

    //add ponints
    for (var i = 0, li = points_.length; i < li; i++) {

        if (forceOrigin_ == true) {
            p1 = [p1[0] - tileX_, p1[1] - tileY_, p1[2]];
        }

        if (forceScale_ != null) {
            p1 = [p1[0] * forceScale_[0], p1[1] * forceScale_[1], p1[2] * forceScale_[2]];
        }

        center_[0] += p1[0];
        center_[1] += p1[1];
        center_[2] += p1[2];

        for (var j = 0; j < circleSides_; j++) {

            if (icon_ == true) {
                processIcon(p1, iconData_) ;//, pointArray_, lod_, style_, zIndex_);
            }

            if (label_ == true) {
                processLabel(p1, labelData_); //, pointArray_, lod_, style_, zIndex_);
            }

            if (point_ == true) {

                if (pointFlat_ == true) {

                    //add polygon
                    vertexBuffer_[index_] = p1[0];
                    vertexBuffer_[index_+1] = p1[1];
                    vertexBuffer_[index_+2] = p1[2];

                    vertexBuffer_[index_+3] = p1[0] + circleBuffer_[j][0] * pointRadius_;
                    vertexBuffer_[index_+4] = p1[1] + circleBuffer_[j][1] * pointRadius_;
                    vertexBuffer_[index_+5] = p1[2];

                    vertexBuffer_[index_+6] = p1[0] + circleBuffer_[j+1][0] * pointRadius_;
                    vertexBuffer_[index_+7] = p1[1] + circleBuffer_[j+1][1] * pointRadius_;
                    vertexBuffer_[index_+8] = p1[2];

                } else {

                    //add polygon
                    vertexBuffer_[index_] = p1[0];
                    vertexBuffer_[index_+1] = p1[1];
                    vertexBuffer_[index_+2] = p1[2];
                    normalBuffer_[index2_] = 0;
                    normalBuffer_[index2_+1] = 0;
                    normalBuffer_[index2_+2] = 0;
                    normalBuffer_[index2_+3] = 0;

                    vertexBuffer_[index_+3] = p1[0];
                    vertexBuffer_[index_+4] = p1[1];
                    vertexBuffer_[index_+5] = p1[2];
                    normalBuffer_[index2_+4] = circleBuffer_[j][0] * pointRadius_;
                    normalBuffer_[index2_+5] = circleBuffer_[j][1] * pointRadius_;
                    normalBuffer_[index2_+6] = 0;
                    normalBuffer_[index2_+7] = 0;

                    vertexBuffer_[index_+6] = p1[0];
                    vertexBuffer_[index_+7] = p1[1];
                    vertexBuffer_[index_+8] = p1[2];
                    normalBuffer_[index2_+8] = circleBuffer_[j+1][0] * pointRadius_;
                    normalBuffer_[index2_+9] = circleBuffer_[j+1][1] * pointRadius_;
                    normalBuffer_[index2_+10] = 0;
                    normalBuffer_[index2_+11] = 0;

                    index2_ += 12;
                }

                index_ += 9;
            }
        }

        if (dpoints_ == true) {
            var p2 = points_[i+1];
            p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];
        } else {
            p1 = points_[i+1];
        }
    }

    if (li > 0) {
        center_[0] /= li;
        center_[1] /= li;
        center_[2] /= li;
    }

    center_[0] += groupOrigin_[0];
    center_[1] += groupOrigin_[1];
    center_[2] += groupOrigin_[2];

    var hitable_ = hoverEvent_ || clickEvent_ || enterEvent_ || leaveEvent_;

    if (point_ == true) {
        if (pointFlat_ == true) {
            postMessage({"command":"addRenderJob", "type": "flat-line", "vertexBuffer": vertexBuffer_,
                         "color":pointColor_, "z-index":zIndex_, "visibility": visibility_, "center": center_,
                         "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                         "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                         "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                         "lod":(autoLod_ ? null : tileLod_) });
        } else {
            postMessage({"command":"addRenderJob", "type": "pixel-line", "vertexBuffer": vertexBuffer_,
                         "normalBuffer": normalBuffer_, "color":pointColor_, "z-index":zIndex_,
                         "visibility": visibility_, "center": center_,
                         "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                         "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                         "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                         "lod":(autoLod_ ? null : tileLod_) });
        }
    }

    if (icon_ == true && iconData_.vertexBuffer_.length > 0) {
        postMessage({"command":"addRenderJob", "type": "icon", "vertexBuffer": iconData_.vertexBuffer_,
                     "originBuffer": iconData_.originBuffer_, "texcoordsBuffer": iconData_.texcoordsBuffer_,
                     "icon":layerBitmaps_[iconData_.source_[0]], "color":iconData_.color_, "z-index":zIndex_,
                     "visibility": visibility_, "center": center_,
                     "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                     "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                     "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                     "lod":(autoLod_ ? null : tileLod_) });
    }

    if (label_ == true && labelData_.vertexBuffer_.length > 0) {
        postMessage({"command":"addRenderJob", "type": "label", "vertexBuffer": labelData_.vertexBuffer_,
                     "originBuffer": labelData_.originBuffer_, "texcoordsBuffer": labelData_.texcoordsBuffer_,
                     "color":labelData_.color_, "z-index":zIndex_, "visibility": visibility_, "center": center_,
                     "hover-event":hoverEvent_, "click-event":clickEvent_, "draw-event":drawEvent_,
                     "enter-event":enterEvent_, "leave-event":leaveEvent_, "zbuffer-offset":zbufferOffset_,
                     "hitable":hitable_, "state":hitState_, "eventInfo":eventInfo_,
                     "lod":(autoLod_ ? null : tileLod_) });
    }

};

var getOriginOffset = function(origin_, width_, height_) {
    switch(origin_) {
        case "top-left":        return [0, 0];
        case "top-right":       return [-width_, 0];
        case "top-center":      return [-width_*0.5, 0];
        case "center-left":     return [0, -height_*0.5];
        case "center-right":    return [-width_, -height_*0.5];
        case "center-center":   return [-width_*0.5, -height_*0.5];
        case "bottom-left":     return [0, -height_];
        case "bottom-right":    return [-width_, -height_];
        case "bottom-center":   return [-width_*0.5, -height_];
    }
};

var processIcon = function(point_, iconData_) {

    var icon_ = iconData_.source_;

    if (icon_ == null) {
        return;
    }

    var width_ = Math.abs(icon_[3] * iconData_.scale_);
    var height_ = Math.abs(icon_[4] * iconData_.scale_);

    var vertexBuffer_ = iconData_.vertexBuffer_;
    var texcoordsBuffer_ = iconData_.texcoordsBuffer_;
    var originBuffer_ = iconData_.originBuffer_;
    var vertexBufferSize_ = vertexBuffer_.length;

    //add polygon
    vertexBuffer_.push(0, 0, 0,
                       width_, 0, 0,
                       width_, -height_, 0);

    texcoordsBuffer_.push(icon_[1], icon_[2], 0, 0,
                          icon_[1]+icon_[3], icon_[2], 0, 0,
                          icon_[1]+icon_[3], icon_[2]+icon_[4], 0, 0);

    //add polygon
    vertexBuffer_.push(0, 0, 0,
                       0, -height_, 0,
                       width_, -height_, 0);

    texcoordsBuffer_.push(icon_[1], icon_[2], 0, 0,
                          icon_[1], icon_[2]+icon_[4], 0, 0,
                          icon_[1]+icon_[3], icon_[2]+icon_[4], 0, 0);

    //get offset
    var originOffset_ = getOriginOffset(iconData_.origin_, width_, height_);
    originOffset_[0] = originOffset_[0] + iconData_.offset_[0];
    originOffset_[1] = originOffset_[1] + iconData_.offset_[1];

    //set origin buffer and apply offset
    for (var i = vertexBufferSize_, li = vertexBuffer_.length; i < li; i+=3) {
        originBuffer_.push(point_[0], point_[1], point_[2]);

        vertexBuffer_[i] +=  originOffset_[0];
        vertexBuffer_[i+1] -= originOffset_[1];
    }
};


var processLabel = function(point_, labelData_) {

    if (labelData_.source_ == null || labelData_.source_ == "" || Math.abs(labelData_.size_) < 0.0001) {
        return;
    }

    var vertexBuffer_ = labelData_.vertexBuffer_;
    var texcoordsBuffer_ = labelData_.texcoordsBuffer_;
    var originBuffer_ = labelData_.originBuffer_;
    var vertexBufferSize_ = vertexBuffer_.length;

    //debugger

    var text_ = labelData_.source_;

    //split by new line
    var lines_ = text_.match(/[^\r\n]+/g);
    var lines2_ = [];
    var align_ = false;

    //split lines by width
    for (var i = 0, li = lines_.length; i < li; i++) {

        var line_= lines_[i];

        do {
            var index_ = getSplitIndex(line_, labelData_.width_, getFontFactor(labelData_.size_, fonts_["default"]), fonts_["default"]);

            if (line_.length == index_) {
                lines2_.push(line_);
                break;
            }

            lines2_.push(line_.substring(0,index_));
            line_ = line_.substring(index_+1);
            align_ = true;

        } while(true);

    }

    var x = 0;
    var y = 0;
    var textLength_ = 0;
    var lineHeight_ = getLineHeight(labelData_.size_, fonts_["default"]);
    var maxWidth_ = 0;
    var lineWidths_ = [];

    //get max width
    for (var i = 0, li = lines2_.length; i < li; i++) {
        lineWidths_[i] = getTextLength(lines2_[i], getFontFactor(labelData_.size_, fonts_["default"]), fonts_["default"]);
        maxWidth_ = Math.max(lineWidths_[i], maxWidth_);
    }

    //generate text
    for (var i = 0, li = lines2_.length; i < li; i++) {
        var textWidth_ = lineWidths_[i];//getTextLength(lines2_[i], getFontFactor(labelData_.size_, fonts_["default"]), fonts_["default"]);
        //maxWidth_ = Math.max(textWidth_, maxWidth_);

        switch(labelData_.align_) {
            case "left": x = 0; break;
            case "right": x = maxWidth_ - textWidth_; break;
            case "center": x = (maxWidth_ - textWidth_)*0.5; break;
        }

        addText([x,y,0], [1,0,0], lines2_[i], labelData_.size_, fonts_["default"], vertexBuffer_, texcoordsBuffer_);
        y -= lineHeight_;
    }

    //get offset
    var originOffset_ = getOriginOffset(labelData_.origin_, maxWidth_, -y);
    originOffset_[0] = originOffset_[0] + labelData_.offset_[0];
    originOffset_[1] = originOffset_[1] + labelData_.offset_[1];

    //set origin buffer and apply offset
    for (var i = vertexBufferSize_, li = vertexBuffer_.length; i < li; i+=3) {
        originBuffer_.push(point_[0], point_[1], point_[2]);

        vertexBuffer_[i] +=  originOffset_[0];
        vertexBuffer_[i+1] -= originOffset_[1];
    }

};








//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var setFont = function(fontData_) {

    fonts_["default"] = {
        chars_ : fontData_["chars"],
        space_ : fontData_["space"],
        size_ : fontData_["size"]
    };

};

vec3Normalize = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return b;
};

vec3Length = function (a) {
    var b = a[0],
        c = a[1];
    a = a[2];
    return Math.sqrt(b * b + c * c + a * a);
};


var addChar = function(pos_, dir_, verticalShift_, char_, factor_, index_, index2_, textVector_, font_, vertexBuffer_, texcoordsBuffer_)
{
    //normal to dir
    var n = [-dir_[1],dir_[0],0];

    var p1 = [pos_[0], pos_[1], pos_[2]];
    var p2 = [p1[0], p1[1], p1[2]];

    var chars_ = font_.chars_;

    var fc = chars_[char_];
    var l = 0;
    var nx = textVector_[0];
    var ny = textVector_[1];

    if (char_ == 9 || char_ == 32) {  //tab or space
        fc = chars_[32]; //space

        if (fc != null) {
            p1[0] += dir_[0] * (fc.step_) * factor_;
            p1[1] += dir_[1] * (fc.step_) * factor_;
            l = fc.lx * factor_;
        }
    } else {
        if (fc != null) {
            var factorX_ = fc.lx * factor_;
            var factorY_ = fc.ly * factor_;

            var n2 = [n[0] * verticalShift_, n[1] * verticalShift_, n[2] * verticalShift_];
            var n3 = [n2[0] + n[0] * factorY_, n2[1] + n[1] * factorY_, n2[2] + n[2] * factorY_];

            p2[0] = p1[0] + dir_[0] * factorX_;
            p2[1] = p1[1] + dir_[1] * factorX_;
            p2[2] = p1[2] + dir_[2] * factorX_;

            //first polygon
            vertexBuffer_[index_] = p1[0] - n2[0];
            vertexBuffer_[index_+1] = p1[1] - n2[1];
            vertexBuffer_[index_+2] = p1[2] - n2[2];

            texcoordsBuffer_[index2_] = fc.u1;
            texcoordsBuffer_[index2_+1] = fc.v1;
            texcoordsBuffer_[index2_+2] = nx;
            texcoordsBuffer_[index2_+3] = ny;

            vertexBuffer_[index_+3] = p1[0] - n3[0];
            vertexBuffer_[index_+4] = p1[1] - n3[1];
            vertexBuffer_[index_+5] = p1[2] - n3[2];

            texcoordsBuffer_[index2_+4] = fc.u1;
            texcoordsBuffer_[index2_+5] = fc.v2;
            texcoordsBuffer_[index2_+6] = nx;
            texcoordsBuffer_[index2_+7] = ny;

            vertexBuffer_[index_+6] = p2[0] - n2[0];
            vertexBuffer_[index_+7] = p2[1] - n2[1];
            vertexBuffer_[index_+8] = p2[2] - n2[2];

            texcoordsBuffer_[index2_+8] = fc.u2;
            texcoordsBuffer_[index2_+9] = fc.v1;
            texcoordsBuffer_[index2_+10] = nx;
            texcoordsBuffer_[index2_+11] = ny;


            //next polygon
            vertexBuffer_[index_+9] = p1[0] - n3[0];
            vertexBuffer_[index_+10] = p1[1] - n3[1];
            vertexBuffer_[index_+11] = p1[2] - n3[2];

            texcoordsBuffer_[index2_+12] = fc.u1;
            texcoordsBuffer_[index2_+13] = fc.v2;
            texcoordsBuffer_[index2_+14] = nx;
            texcoordsBuffer_[index2_+15] = ny;

            vertexBuffer_[index_+12] = p2[0] - n3[0];
            vertexBuffer_[index_+13] = p2[1] - n3[1];
            vertexBuffer_[index_+14] = p2[2] - n3[2];

            texcoordsBuffer_[index2_+16] = fc.u2;
            texcoordsBuffer_[index2_+17] = fc.v2;
            texcoordsBuffer_[index2_+18] = nx;
            texcoordsBuffer_[index2_+19] = ny;

            vertexBuffer_[index_+15] = p2[0] - n2[0];
            vertexBuffer_[index_+16] = p2[1] - n2[1];
            vertexBuffer_[index_+17] = p2[2] - n2[2];

            texcoordsBuffer_[index2_+20] = fc.u2;
            texcoordsBuffer_[index2_+21] = fc.v1;
            texcoordsBuffer_[index2_+22] = nx;
            texcoordsBuffer_[index2_+23] = ny;

            index_ += 18;
            index2_ += 24;
            //polygons_ += 2;

            p1[0] = p1[0] + dir_[0] * fc.step_ * factor_;
            p1[1] = p1[1] + dir_[1] * fc.step_ * factor_;
            l = fc.lx * factor_;
        } else {
            //unknown char
        }
    }

    return [p1, index_, index2_, l];
};


var addText = function(pos_, dir_, text_, size_, font_, vertexBuffer_, texcoordsBuffer_)
{
    var textVector_ = [0,1];
    var index_ = vertexBuffer_.length;
    var index2_ = texcoordsBuffer_.length;

    var factor_ = size_ / font_.size_;
    var newLineSpace_ = font_.space_ * factor_;

    var s = [pos_[0], pos_[1], pos_[2]];
    var p1 = [pos_[0], pos_[1], pos_[2]];

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            s[0] += -dir_[1] * newLineSpace_;
            s[1] += dir_[0] * newLineSpace_;
            p1 = [s[0], s[1], s[2]];
            continue;
        }

        var shift_ = addChar(p1, dir_, 0, char_, factor_, index_, index2_, textVector_, font_, vertexBuffer_, texcoordsBuffer_);

        p1 = shift_[0];
        index_ = shift_[1];
        index2_ = shift_[2];
    }

};


var addTextOnPath = function(points_, distance_, text_, size_, textVector_, font_, verticalOffset_, vertexBuffer_, texcoordsBuffer_)
{
    if (textVector_ == null) {
        textVector_ = [0,1];
    }

    var p1 = points_[0];
    var p2 = points_[1];

    var index_ = vertexBuffer_.length;
    var index2_ = texcoordsBuffer_.length;

    var chars_ = font_.chars_;

    var factor_ = size_ / font_.size_;
    var newLineSpace_ = font_.space_ * factor_;

    var s = [p1[0], p1[1], p1[2]];
    var p1 = [p1[0], p1[1], p1[2]];
    var l = distance_;

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            s[0] += -dir_[1] * newLineSpace_;
            s[1] += dir_[0] * newLineSpace_;
            p1 = [s[0], s[1], s[2]];
            continue;
        }

        if (char_ == 9) { //tab
            char_ = 32;
        }

        var fc = chars_[char_];
        var ll = 1;
        if (fc != null) {
            ll = fc.step_ * factor_;
        }

        var posAndDir_ = getPathPositionAndDirection(points_, l);
        var posAndDir2_ = getPathPositionAndDirection(points_, l+ll);

        //average dir
        var dir_ = [(posAndDir2_[1][0] + posAndDir_[1][0])*0.5,
                    (posAndDir2_[1][1] + posAndDir_[1][1])*0.5,
                    (posAndDir2_[1][2] + posAndDir_[1][2])*0.5];

        vec3Normalize(dir_);

        var shift_ = addChar(posAndDir_[0], dir_, -factor_*font_.size_*0.7+verticalOffset_, char_, factor_, index_, index2_, textVector_, font_, vertexBuffer_, texcoordsBuffer_);

        p1 = shift_[0];
        index_ = shift_[1];
        index2_ = shift_[2];
        l += ll;
    }

};

var addStreetTextOnPath = function(points_, text_, size_, font_, verticalOffset_, vertexBuffer_, texcoordsBuffer_)
{
    var factor_ = size_ / font_.size_;
    var textLength_ = getTextLength(text_, factor_, font_);
    var pathLength_ = getPathLength(points_);
    var shift_ = (pathLength_ -  textLength_)*0.5;
    if (shift_ < 0) {
        shift_ = 0;
    }

    if (textLength_ > pathLength_) {
        return;
    }

    var textVector_ = getPathTextVector(points_, shift_, text_, factor_, font_);

    addTextOnPath(points_, shift_, text_, size_, textVector_, font_, verticalOffset_, vertexBuffer_, texcoordsBuffer_);
};

var getFontFactor = function(size_, font_)
{
    return size_ / font_.size_;
};

var getLineHeight = function(size_, font_)
{
    var factor_ = size_ / font_.size_;
    return font_.space_ * factor_;
};

var getTextLength = function(text_, factor_, font_)
{
    var l = 0;
    var chars_ = font_.chars_;

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            continue;
        }

        if (char_ == 9) {  //tab or space
            char_ = 32;
        }

        var fc = chars_[char_];

        if (fc != null) {
            l += fc.step_ * factor_;
        }
    }

    return l;
};

var getSplitIndex = function(text_, width_, factor_, font_)
{
    var l = 0;
    var chars_ = font_.chars_;

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (l > width_ && (char_ == 10 || char_ == 9 || char_ == 32)) {
            return i;
        }

        if (char_ == 10) { //new line
            continue;
        }

        if (char_ == 9) {  //tab or space
            char_ = 32;
        }

        var fc = chars_[char_];

        if (fc != null) {
            l += fc.step_ * factor_;
        }
    }

    return li;
};

var getPathLength = function(points_) {
    var l = 0;

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        var p1 = points_[i];
        var p2 = points_[i+1];
        var dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        l += vec3Length(dir_);
    }

    return l;
};

var getPathPositionAndDirection = function(points_, distance_)
{
    var l = 0;
    var p1 = [0,0,0];
    var dir_ = [1,0,0];

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        p1 = points_[i];
        var p2 = points_[i+1];
        dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        var ll = vec3Length(dir_);

        if ((l + ll) > distance_) {

            var factor_ = (distance_ - l) / (ll);
            var p = [p1[0] + dir_[0] * factor_,
                     p1[1] + dir_[1] * factor_,
                     p1[2] + dir_[2] * factor_];

            vec3Normalize(dir_);

            return [p, dir_];
        }

        l += ll;
    }

    return [p1, dir_];
};

var getPathTextVector = function(points_, shift_, text_, factor_, font_)
{
    var l = 0;
    var p1 = [0,0,0];
    var dir_ = [1,0,0];
    var textDir_ = [0,0,0];
    var textStart_ = shift_;
    var textEnd_ = shift_ + getTextLength(text_, factor_, font_);

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        p1 = points_[i];
        var p2 = points_[i+1];
        dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        l += vec3Length(dir_);

        if (l > textStart_) {
            vec3Normalize(dir_);
            textDir_[0] += dir_[0];
            textDir_[1] += dir_[1];
            textDir_[2] += dir_[2];
        }

        if (l > textEnd_) {
            vec3Normalize(textDir_);
            return [-textDir_[1], textDir_[0],0];
        }
    }

    return textDir_;
};

//---------------------------------------------------
// this file loaded from geoWorkerDebug or merged
// into one function in case of minification process
//---------------------------------------------------

var processFeaturePass = function(type_, feature_, lod_, style_, zIndex_, eventInfo_) {

    switch(type_) {
        case "line-string":
            if (getStylePropertyValue(style_, "point", feature_, lod_) ||
                getStylePropertyValue(style_, "label", feature_, lod_)) {
                processPointArrayPass(feature_, lod_, style_, zIndex_, eventInfo_);
            }

            processLineStringPass(feature_, lod_, style_, zIndex_, eventInfo_);
            break;

        case "point-array":
            processPointArrayPass(feature_, lod_, style_, zIndex_, eventInfo_);

            if (getStylePropertyValue(style_, "line", feature_, lod_) ||
                getStylePropertyValue(style_, "line-label", feature_, lod_)) {
                processLineStringPass(feature_, lod_, style_, zIndex_, eventInfo_);
            }

            break;
    }

};

var processFeature= function(type_, feature_, lod_, featureIndex_) {

    var style_ = getStyle(feature_["style"], type_, featureIndex_);
    var visible_ = getStylePropertyValue(style_, "visible", feature_, lod_);
    var zIndex_ = getStylePropertyValue(style_, "z-index", feature_, lod_);

    if (visible_ == false) {
        return;
    }

    var eventInfo_ = {};

    for (var key_ in feature_) {
        if (key_ != "points" && key_ != "d-points") {
            eventInfo_[key_] = feature_[key_];
        }
    }

    var hoverStyleId_ = getStylePropertyValue(style_, "hover-style", feature_, lod_);
    var hoverStyle_ = (hoverStyleId_ != "") ? getStyle(hoverStyleId_, type_, featureIndex_) : null;

    if (hoverStyle_ != null) {
        hitState_ = 1;
        processFeaturePass(type_, feature_, lod_, style_, zIndex_, eventInfo_);
        hitState_ = 2;
        processFeaturePass(type_, feature_, lod_, hoverStyle_, zIndex_, eventInfo_);
    } else {
        hitState_ = 0;
        processFeaturePass(type_, feature_, lod_, style_, zIndex_, eventInfo_);
    }


    var multiPass_ = getStylePropertyValue(style_, "multi-pass", feature_, lod_);

    if (multiPass_ != null) {
        for (var i = 0, li = multiPass_.length; i < li; i++) {
            var zIndex_ = multiPass_[i][0];
            var style_ = getStyle(multiPass_[i][1], type_, featureIndex_);

            visible_ = getStylePropertyValue(style_, "visible", feature_, lod_);

            if (visible_ == false) {
                continue;
            }

            hoverStyleId_ = getStylePropertyValue(style_, "hover-style", feature_, lod_);
            hoverStyle_ = (hoverStyleId_ != "") ? getStyle(hoverStyleId_, type_, featureIndex_) : null;

            if (hoverStyle_ != null) {
                hitState_ = 1;
                processFeaturePass(type_, feature_, lod_, style_, zIndex_, eventInfo_);
                hitState_ = 2;
                processFeaturePass(type_, feature_, lod_, hoverStyle_, zIndex_, eventInfo_);
            } else {
                hitState_ = 0;
                processFeaturePass(type_, feature_, lod_, style_, zIndex_, eventInfo_);
            }
        }
    }

};


var processGroup = function(group_, lod_) {

    var points_ = group_["points"] || [];

    if (group_["origin"] == null && (tileX_ != 0 && tileY_ != 0)) {
        group_["origin"] = [tileX_, tileY_, 0];
        forceOrigin_ = true;
    } else {
        forceOrigin_ = false;
    }

    groupOrigin_ = group_["origin"];

    if (group_["scale"] != null) {
        forceScale_ = group_["scale"];
    } else {
        forceScale_ = null;
    }


    postMessage({"command":"beginGroup", "id": group_["id"], "bbox": group_["bbox"], "origin": group_["origin"]});

    //process points
    for (var i = 0, li = points_.length; i < li; i++) {
        processFeature("point-array", points_[i], lod_, i);
    }

    var lines_ = group_["lines"] || [];

    //process lines
    for (var i = 0, li = lines_.length; i < li; i++) {
        processFeature("line-string", lines_[i], lod_, i);
    }

    postMessage({"command":"endGroup"});
};


var processGeodata = function(data_, lod_) {

    //console.log("processGeodata");

    //create object from JSON
    if ((typeof data_) == "string") {
        try {
            var geodata_ = JSON.parse(data_);
        } catch (e) {
            geodata_ = null;
        }
    } else {
        geodata_ = data_;
    }

    if (geodata_) {

        var groups_ = geodata_["layers"] || geodata_["groups"] || [];

        //process layers
        for (var i = 0, li = groups_.length; i < li; i++) {
            processGroup(groups_[i], lod_);
        }
    }

    //console.log("processGeodata-ready");
};

self.onmessage = function (e) {
    var message_ = e.data;
    var command_ = message_["command"];
    var data_ = message_["data"];

    switch(command_) {

        case "setStyles":
            processStyles(data_);
            postMessage("ready");
            break;

        case "setFont":
            setFont(data_);
            postMessage("ready");
            break;

        case "processGeodata":

            tileX_ = message_["x"] || 0;
            tileY_ = message_["y"] || 0;
            tileLod_ = message_["lod"] || 1;
            autoLod_ = message_["autoLod"] || false;

            processGeodata(data_, tileLod_);
            postMessage("allProcessed");
            postMessage("ready");
            break;
    }
};

};

Vadstena.geodataProcessor = function(layer_, listener_) {
    this.layer_ = layer_;
    this.browser_ = layer_.browser_;
    this.killed_ = false;
    this.listener_ = listener_;
    this.ready_ = true;

    if (VADSTENA_MERGE == true){

        //strigify function
        var windowURL_ = window.URL || window.webkitURL;
        var blob_;
        var stringified_ = Vadstena.stringifyFunction(Vadstena.geodataProcessorWorker);

        //convert string to blob
        try {
            blob_ = new Blob([stringified_], {type: 'application/javascript'});
        } catch (e) { // Backwards-compatibility
            window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            blob_ = new BlobBuilder();
            blob_.append(stringified_);
            blob_ = blob.getBlob();
        }

        //create worker from blob
        this.processWorker_ = new Worker(windowURL_.createObjectURL(blob_));
    } else {

        //debug worker
        this.processWorker_ = new Worker("./browser/geoWorkerDebug.js");
    }

    this.processWorker_.onmessage = this.onMessage.bind(this);
};

Vadstena.geodataProcessor.prototype.kill = function() {
    if (this.killed_ == true) {
        return;
    }

    this.killed_ = true;

    if (this.processWorker_ != null) {
        this.processWorker_.terminate();
    }
};

Vadstena.geodataProcessor.prototype.isReady = function(listener_) {
    return this.ready_ || this.killed_;
};

Vadstena.geodataProcessor.prototype.onMessage = function(message_) {

    if (this.killed_ == true) {
        return;
    }

    message_ = message_.data;

    //console.log("onmessage");

    if (message_ == "ready") {
        this.ready_ = true;
        //console.log("ready");
    }

    if (this.listener_ != null) {
        this.listener_(message_);
    }
};

Vadstena.geodataProcessor.prototype.setListener = function(listener_) {
    this.listener_ = listener_;
};

Vadstena.geodataProcessor.prototype.sendCommand = function(command_, data_, id_, autoLod_) {

    if (this.killed_ == true) {
        return;
    }

    this.ready_ = false;

    if (id_ == null) {
        id_ = {
            easting_:0,
            northing_:0,
            lod_:0
        };
    }

    //console.log("command: " + command_ + " data: " + data_);

    this.processWorker_.postMessage({"command": command_, "data":data_, "x":id_.easting_, "y":id_.northing_, "lod": id_.lod_, "autoLod":autoLod_});
};


//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.GpuFont = function(gpu_, browser_, font_, size_)
{
    this.bbox_ = null;
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.browser_ = browser_;

    this.chars_ = [];
    this.space_ = 0;
    this.font_ = font_;
    this.size_ = size_;
    this.image_ = null;
    this.texture_ = null;

    this.generate(font_, size_);
};

//destructor
Vadstena.GpuFont.prototype.kill = function()
{

};

Vadstena.GpuFont.prototype.generate = function(font_, size_)
{
    if (font_ == null) {
        font_ = "Arial, 'Helvetica Neue', Helvetica, sans-serif"; //"Calibri";
    }

    if (size_ == null) {
        size_ = 10;
    }

    var textureLX_ = 512;
    var textureLY_ = 512;
    var fx = 1.0 / textureLX_;
    var fy = 1.0 / textureLY_;

    var canvas_ = document.createElement('canvas');
    canvas_.width = textureLX_;
    canvas_.height = textureLY_;

    var ctx_ = canvas_.getContext('2d');

    //utDrawFilledRect(0, 0, _textureLX, _textureLY, [0,0,0,255]);

    var _fontSize = 10;
    ctx_.beginPath();
    ctx_.font = size_ + "pt " + font_;
    ctx_.textAlign = "left";
    ctx_.textBaseline = "top";
//  ctx_.fillStyle = "@white";
//    ctx_.fillStyle = [0,0,0,255];
    ctx_.fillStyle = "#ffffff";
    ctx_.strokeStyle = "#000000";
    ctx_.lineWidth = 5;
    ctx_.lineCap = "round";
    ctx_.lineJoin = "round";

    var lineSpace_ = Math.round(ctx_.lineWidth*0.5);

    var space_ = ctx_.lineWidth+2;
    var x = space_;
    var y = space_;


    var cly = Math.floor(ctx_.measureText("e").width * 2.5);
    var clxe = Math.floor(ctx_.measureText("e").width);
    //var clxe = Math.floor(ctx_.measureText("ee").width);

    this.chars_ = [];
    this.space_ = cly;
    this.size_ = size_;
    this.font_ = font_;

    var codes_ = [];

    for (var i = 33; i < 191; i++) {
        codes_.push(i);
    }

    for (var i = 192; i < 688; i++) {
        codes_.push(i);
    }

    codes_ = codes_.concat(0x20, 0x2026, 0x2018, 0x2019, 0x201a, 0x201b, 0x201c, 0x201d, 0x201e, 0x2032, 0x2033, 0x203c);

    for (var i = 0, li = codes_.length; i < li; i++) {
        var c = String.fromCharCode(codes_[i]);
        var clx2 = Math.round(ctx_.measureText(c).width);
        var clx = clx2 + ctx_.lineWidth;

        if (x + clx2 + space_ >= textureLX_) {
            x = space_;
            y += cly + space_;
        }

        ctx_.strokeText(c, x+lineSpace_, y);
        ctx_.fillText(c, x+lineSpace_, y);

        this.chars_[codes_[i]] = {
                u1 : x * fx,
                v1 : y * fy,
                u2 : (x + clx) * fx,
                v2 : (y + cly) * fy,
                lx : clx,
                ly : cly,
                step_ : (clx-2)
            };

        x += clx + space_;
    }

    this.image_ = ctx_.getImageData(0, 0, textureLX_, textureLY_);

    this.texture_ = new Vadstena.GpuTexture(this.gpu_, null);
    //this.texture_.createFromData(textureLX_, textureLY_, this.image_);
    this.texture_.createFromImage(this.image_, "linear");
    this.texture_.width_ = textureLX_;
    this.texture_.height_ = textureLY_;
    this.texture_.size_ = textureLX_ * textureLY_ * 4;
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuFont.prototype.size = function(){ return this.size_; };


//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.GpuText = function(gpu_, browser_, font_, withNormals_)
{
    //this.bbox_ = mesh_.bbox_; //!< bbox copy from Mesh
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.browser_ = browser_;
    this.font_ = font_;
    this.withNormals_ = withNormals_;

    this.vertices_ = [];
    this.tvertices_ = [];

    this.vertexPositionBuffer_ = null;
    this.vertexTextureCoordBuffer_ = null;

    this.size_ = 0;
    this.polygons_ = 0;
};

//destructor
Vadstena.GpuText.prototype.kill = function()
{
    if (this.vertexPositionBuffer_ == null) {
        return;
    }

    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
    this.gl_.deleteBuffer(this.vertexTextureCoordBuffer_);

    if (this.browser_ != null && this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxMesh_[1][0] ++;
        this.browser_.renderer_.statsFluxMesh_[1][1] += this.size_;
    }
};

Vadstena.GpuText.prototype.addChar = function(pos_, dir_, verticalShift_, char_, factor_, index_, index2_, textVector_)
{
    //normal to dir
    var n = [-dir_[1],dir_[0],0];

    var p1 = [pos_[0], pos_[1], pos_[2]];
    var p2 = [p1[0], p1[1], p1[2]];

    var chars_ = this.font_.chars_;

    var fc = chars_[char_];
    var l = 0;
    var nx = textVector_[0];
    var ny = textVector_[1];

    if (char_ == 9 || char_ == 32) {  //tab or space
        fc = chars_[32]; //space

        if (fc != null) {
            p1[0] += dir_[0] * (fc.step_) * factor_;
            p1[1] += dir_[1] * (fc.step_) * factor_;
            l = fc.lx * factor_;
        }
    } else {
        if (fc != null) {
            var factorX_ = fc.lx * factor_;
            var factorY_ = fc.ly * factor_;

            var n2 = [n[0] * verticalShift_, n[1] * verticalShift_, n[2] * verticalShift_];
            var n3 = [n2[0] + n[0] * factorY_, n2[1] + n[1] * factorY_, n2[2] + n[2] * factorY_];

            p2[0] = p1[0] + dir_[0] * factorX_;
            p2[1] = p1[1] + dir_[1] * factorX_;
            p2[2] = p1[2] + dir_[2] * factorX_;

            //first polygon
            this.vertices_[index_] = p1[0] - n2[0];
            this.vertices_[index_+1] = p1[1] - n2[1];
            this.vertices_[index_+2] = p1[2] - n2[2];

            this.tvertices_[index2_] = fc.u1;
            this.tvertices_[index2_+1] = fc.v1;
            this.tvertices_[index2_+2] = nx;
            this.tvertices_[index2_+3] = ny;

            this.vertices_[index_+3] = p1[0] - n3[0];
            this.vertices_[index_+4] = p1[1] - n3[1];
            this.vertices_[index_+5] = p1[2] - n3[2];

            this.tvertices_[index2_+4] = fc.u1;
            this.tvertices_[index2_+5] = fc.v2;
            this.tvertices_[index2_+6] = nx;
            this.tvertices_[index2_+7] = ny;

            this.vertices_[index_+6] = p2[0] - n2[0];
            this.vertices_[index_+7] = p2[1] - n2[1];
            this.vertices_[index_+8] = p2[2] - n2[2];

            this.tvertices_[index2_+8] = fc.u2;
            this.tvertices_[index2_+9] = fc.v1;
            this.tvertices_[index2_+10] = nx;
            this.tvertices_[index2_+11] = ny;


            //next polygon
            this.vertices_[index_+9] = p1[0] - n3[0];
            this.vertices_[index_+10] = p1[1] - n3[1];
            this.vertices_[index_+11] = p1[2] - n3[2];

            this.tvertices_[index2_+12] = fc.u1;
            this.tvertices_[index2_+13] = fc.v2;
            this.tvertices_[index2_+14] = nx;
            this.tvertices_[index2_+15] = ny;

            this.vertices_[index_+12] = p2[0] - n3[0];
            this.vertices_[index_+13] = p2[1] - n3[1];
            this.vertices_[index_+14] = p2[2] - n3[2];

            this.tvertices_[index2_+16] = fc.u2;
            this.tvertices_[index2_+17] = fc.v2;
            this.tvertices_[index2_+18] = nx;
            this.tvertices_[index2_+19] = ny;

            this.vertices_[index_+15] = p2[0] - n2[0];
            this.vertices_[index_+16] = p2[1] - n2[1];
            this.vertices_[index_+17] = p2[2] - n2[2];

            this.tvertices_[index2_+20] = fc.u2;
            this.tvertices_[index2_+21] = fc.v1;
            this.tvertices_[index2_+22] = nx;
            this.tvertices_[index2_+23] = ny;

            index_ += 18;
            index2_ += 24;
            this.polygons_ += 2;

            p1[0] = p1[0] + dir_[0] * fc.step_ * factor_;
            p1[1] = p1[1] + dir_[1] * fc.step_ * factor_;
            l = fc.lx * factor_;
        } else {
            //unknown char
        }
    }

    return [p1, index_, index2_, l];
};


Vadstena.GpuText.prototype.addText = function(pos_, dir_, text_, size_)
{
    var textVector_ = [0,1];
    var index_ = this.vertices_.length;
    var index2_ = this.tvertices_.length;

    var factor_ = size_ / this.font_.size_;
    var newLineSpace_ = this.font_.space_ * factor_;

    var s = [pos_[0], pos_[1], pos_[2]];
    var p1 = [pos_[0], pos_[1], pos_[2]];

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            s[0] += -dir_[1] * newLineSpace_;
            s[1] += dir_[0] * newLineSpace_;
            p1 = [s[0], s[1], s[2]];
            continue;
        }

        var shift_ = this.addChar(p1, dir_, 0, char_, factor_, index_, index2_, textVector_);

        p1 = shift_[0];
        index_ = shift_[1];
        index2_ = shift_[2];
    }

};


Vadstena.GpuText.prototype.addTextOnPath = function(points_, distance_, text_, size_, textVector_)
{
    if (textVector_ == null) {
        textVector_ = [0,1];
    }

    var p1 = points_[0];
    var p2 = points_[1];

    var index_ = this.vertices_.length;
    var index2_ = this.tvertices_.length;

    var chars_ = this.font_.chars_;

    var factor_ = size_ / this.font_.size_;
    var newLineSpace_ = this.font_.space_ * factor_;

    var s = [p1[0], p1[1], p1[2]];
    var p1 = [p1[0], p1[1], p1[2]];
    var l = distance_;

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            s[0] += -dir_[1] * newLineSpace_;
            s[1] += dir_[0] * newLineSpace_;
            p1 = [s[0], s[1], s[2]];
            continue;
        }

        if (char_ == 9) { //tab
            char_ = 32;
        }

        var fc = chars_[char_];
        var ll = 1;
        if (fc != null) {
            ll = fc.step_ * factor_;
        }

        var posAndDir_ = this.getPathPositionAndDirection(points_, l);
        var posAndDir2_ = this.getPathPositionAndDirection(points_, l+ll);

        //average dir
        var dir_ = [(posAndDir2_[1][0] + posAndDir_[1][0])*0.5,
                    (posAndDir2_[1][1] + posAndDir_[1][1])*0.5,
                    (posAndDir2_[1][2] + posAndDir_[1][2])*0.5];

        Vadstena.vec3.normalize(dir_);

        var shift_ = this.addChar(posAndDir_[0], dir_, -factor_*this.font_.size_*0.7, char_, factor_, index_, index2_, textVector_);

        p1 = shift_[0];
        index_ = shift_[1];
        index2_ = shift_[2];
        l += ll;
    }

};

Vadstena.GpuText.prototype.addStreetTextOnPath = function(points_, text_, size_)
{
    var factor_ = size_ / this.font_.size_;
    var textLength_ = this.getTextLength(text_, factor_);
    var pathLength_ = this.getPathLength(points_);
    var shift_ = (pathLength_ -  textLength_)*0.5;
    if (shift_ < 0) {
        shift_ = 0;
    }

    if (textLength_ > pathLength_) {
        return;
    }

    var textVector_ = this.getPathTextVector(points_, shift_, text_, factor_);

    this.addTextOnPath(points_, shift_, text_, size_, textVector_);
};

Vadstena.GpuText.prototype.getFontFactor = function(size_)
{
    return size_ / this.font_.size_;
};

Vadstena.GpuText.prototype.getTextLength = function(text_, factor_)
{
    var l = 0;
    var chars_ = this.font_.chars_;

    for (var i = 0, li = text_.length; i < li; i++)
    {
        var char_ = text_.charCodeAt(i);

        if (char_ == 10) { //new line
            continue;
        }

        if (char_ == 9) {  //tab or space
            char_ = 32;
        }

        var fc = chars_[char_];

        if (fc != null) {
            l += fc.step_ * factor_;
        }
    }

    return l;
};

Vadstena.GpuText.prototype.getPathLength = function(points_) {
    var l = 0;

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        var p1 = points_[i];
        var p2 = points_[i+1];
        var dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        l += Vadstena.vec3.length(dir_);
    }

    return l;
};

Vadstena.GpuText.prototype.getPathPositionAndDirection = function(points_, distance_)
{
    var l = 0;
    var p1 = [0,0,0];
    var dir_ = [1,0,0];

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        p1 = points_[i];
        var p2 = points_[i+1];
        dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        var ll = Vadstena.vec3.length(dir_);

        if ((l + ll) > distance_) {

            var factor_ = (distance_ - l) / (ll);
            var p = [p1[0] + dir_[0] * factor_,
                     p1[1] + dir_[1] * factor_,
                     p1[2] + dir_[2] * factor_];

            Vadstena.vec3.normalize(dir_);

            return [p, dir_];
        }

        l += ll;
    }

    return [p1, dir_];
};

Vadstena.GpuText.prototype.getPathTextVector = function(points_, shift_, text_, factor_)
{
    var l = 0;
    var p1 = [0,0,0];
    var dir_ = [1,0,0];
    var textDir_ = [0,0,0];
    var textStart_ = shift_;
    var textEnd_ = shift_ + this.getTextLength(text_, factor_);

    for (var i = 0, li = points_.length-1; i < li; i++)
    {
        p1 = points_[i];
        var p2 = points_[i+1];
        dir_ = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

        l += Vadstena.vec3.length(dir_);

        if (l > textStart_) {
            Vadstena.vec3.normalize(dir_);
            textDir_[0] += dir_[0];
            textDir_[1] += dir_[1];
            textDir_[2] += dir_[2];
        }

        if (l > textEnd_) {
            Vadstena.vec3.normalize(textDir_);
            return [-textDir_[1], textDir_[0],0];
        }
    }

    return textDir_;
};

Vadstena.GpuText.prototype.compile = function()
{
    var gl_ = this.gl_;
    if (gl_ == null)
        return;

    this.kill();

    this.vertexPositionBuffer_ = null;
    this.vertexTextureCoordBuffer_ = null;
    this.vertexNormalBuffer_ = null;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = this.vertices_.length / 3;

    //create texture coords buffer
    this.vertexTextureCoordBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexTextureCoordBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.tvertices_), gl_.STATIC_DRAW);
    this.vertexTextureCoordBuffer_.itemSize = 4;
    this.vertexTextureCoordBuffer_.numItems = this.tvertices_.length / 4;

    this.size_ = this.vertexPositionBuffer_.numItems * 3 * 4 + this.vertexTextureCoordBuffer_.numItems * 4 * 4;
    this.polygons_ = this.vertexPositionBuffer_.numItems / 3;

    if (this.browser_ != null && this.browser_.renderer_ != null) {
        //this.browser_.renderer_.statsCreateGpuTextTime_ += performance.now() - timer_;
        //this.browser_.renderer_.statsFluxMesh_[0][0] ++;
        //this.browser_.renderer_.statsFluxMesh_[0][1] += this.size_;
    }


    if (this.withNormals_ == true) {
        this.normals_ = [];
    }

};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuText.prototype.draw = function(program_, attrPosition_, attrTexCoord_)
{
    var gl_ = this.gl_;
    if (gl_ == null)
        return;

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);
    var textureCoordAttribute_ = program_.getAttribute(attrTexCoord_);

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //bind texture coords
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexTextureCoordBuffer_);
    gl_.vertexAttribPointer(textureCoordAttribute_, this.vertexTextureCoordBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //draw polygons
    gl_.drawArrays(gl_.TRIANGLES, 0, this.vertexPositionBuffer_.numItems);
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuText.prototype.size = function(){ return this.size_; };

Vadstena.GpuText.prototype.bbox = function(){ return this.bbox_; };

Vadstena.GpuText.prototype.getPolygons = function(){ return this.polygons_; };


if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//! Holds the GPU data for a tile.
/**
 * @constructor
 */
Vadstena.GpuGeodata = function(gpu_, tile_)
{
    this.gpu_ = gpu_;
    this.type_ = tile_.type_;
    this.gpuGroups_ = [];
    this.tile_ = tile_;
    this.curerntGpuGroup_ = null;
    this.geodataProcessor_ = tile_.layer_.geodataProcessor_;
    this.size_ = 0;
    this.killed_ = false;
    this.ready_ = false;

    this.isReady();
};

Vadstena.GpuGeodata.prototype.kill = function() {

    this.killed_ = true;

    switch(this.type_){
        case "geodata":

            for (var i = 0, li = this.gpuGroups_.length; i < li; i++) {
                this.gpuGroups_[i].kill();
            }

            break;
    }
};

Vadstena.GpuGeodata.prototype.onGeodataProcessorMessage = function(message_) {

    if (this.killed_ == true){
        return;
    }

    if (message_["command"] != null) {

        switch (message_["command"]) {

            case "beginGroup":
                this.currentGpuGroup_ = new Vadstena.GpuGroup(message_["id"], message_["bbox"], message_["origin"], this.gpu_, this.tile_.browser_, this.tile_.layer_);
                this.gpuGroups_.push(this.currentGpuGroup_);
                break;

            case "addRenderJob":
                this.currentGpuGroup_.addRenderJob(message_);
                break;

            case "endGroup":
                this.size += this.currentGpuGroup_.size();
                break;
        }

    } else {

        switch (message_) {
            case "allProcessed":
                this.tile_.browser_.renderer_.dirty_ = true;
                this.ready_ = true;
                break;

            case "ready":
                break;

        }
    }

};

Vadstena.GpuGeodata.prototype.isReady = function() {

    if (this.ready_ == false && this.geodataProcessor_.isReady() == true) {

        switch(this.type_){

            case "geodata":
                this.geodataProcessor_.setListener(this.onGeodataProcessorMessage.bind(this));
                this.geodataProcessor_.sendCommand("processGeodata", this.tile_.geodata_, this.tile_.id_, this.tile_.layer_.autoLods_);
                break;
        }

    }

    return this.ready_;
};


Vadstena.GpuGeodata.prototype.draw = function(mv_, mvp_, applyOrigin_) {

    if (this.ready_ == true) {

        switch(this.type_){

            case "geodata":

                for (var i = 0, li = this.gpuGroups_.length; i < li; i++) {
                    this.gpuGroups_[i].draw(mv_, mvp_, applyOrigin_);
                }

                break;
        }

    }

    return this.ready_;
};

Vadstena.GpuGeodata.prototype.size = function() {
    return this.size_;
};


//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.GpuGroup = function(id_, bbox_, origin_, gpu_, browser_, layer_)
{
    this.id_ = id_;
    this.bbox_ = null;
    this.origin_ = origin_ || [0,0,0];
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.renderer_ = browser_.renderer_;
    this.browser_ = browser_;
    this.layer_ = layer_;
    this.jobs_ = [];

    if (bbox_ != null && bbox_[0] != null && bbox_[1] != null) {
        this.bbox_ = new Vadstena.BBox(bbox_[0][0], bbox_[0][1], bbox_[0][2], bbox_[1][0], bbox_[1][1], bbox_[1][2]);
    }

    this.size_ = 0;
    this.polygons_ = 0;
};

//destructor
Vadstena.GpuGroup.prototype.kill = function()
{
    for (var i = 0, li = this.jobs_.length; i < li; i++) {

        switch(this.jobs_[i].type_) {
            case "flat-line":
                this.gl_.deleteBuffer(this.jobs_[i].vertexPositionBuffer_);
                break;

            case "flat-tline":
            case "pixel-line":
            case "pixel-tline":
                this.gl_.deleteBuffer(this.jobs_[i].vertexPositionBuffer_);
                this.gl_.deleteBuffer(this.jobs_[i].vertexNormalBuffer_);
                break;

            case "line-label":
                this.gl_.deleteBuffer(this.jobs_[i].vertexPositionBuffer_);
                this.gl_.deleteBuffer(this.jobs_[i].vertexTexcoordBuffer_);
                break;

            case "icon":
            case "label":
                this.gl_.deleteBuffer(this.jobs_[i].vertexPositionBuffer_);
                this.gl_.deleteBuffer(this.jobs_[i].vertexTexcoordBuffer_);
                this.gl_.deleteBuffer(this.jobs_[i].vertexOriginBuffer_);
                break;

        }

    }
};

Vadstena.GpuGroup.prototype.size = function()
{
    return this.size_;
};

Vadstena.GpuGroup.prototype.getZbufferOffset = function(params_)
{
    return this.size_;
};

Vadstena.GpuGroup.prototype.addLineJob = function(data_)
{
    var gl_ = this.gl_;

    var vertices_ = data_["vertexBuffer"];
    var color_ = data_["color"];
    var f = 1.0/255;

    var job_ = {};
    job_.type_ = "flat-line";
    job_.program_ = data_["program"];
    job_.color_ = [color_[0]*f, color_[1]*f, color_[2]*f, color_[3]*f];
    job_.zIndex_ = data_["z-index"] + 256;
    job_.clickEvent_ = data_["click-event"];
    job_.hoverEvent_ = data_["hover-event"];
    job_.enterEvent_ = data_["enter-event"];
    job_.leaveEvent_ = data_["leave-event"];
    job_.hitable_ = data_["hitable"];
    job_.eventInfo_ = data_["eventInfo"];
    job_.state_ = data_["state"];
    job_.center_ = data_["center"];
    job_.lod_ = data_["lod"];
    job_.lineWidth_ = data_["line-width"];
    job_.zbufferOffset_ = data_["zbuffer-offset"];

    //create vertex buffer
    job_.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    job_.vertexPositionBuffer_.itemSize = 3;
    job_.vertexPositionBuffer_.numItems = vertices_.length / 3;

    this.jobs_.push(job_);

    this.size_ += job_.vertexPositionBuffer_.numItems * 3 * 4;
    this.polygons_ += job_.vertexPositionBuffer_.numItems / 3;
};

Vadstena.GpuGroup.prototype.addExtentedLineJob = function(data_)
{
    var gl_ = this.gl_;

    var vertices_ = data_["vertexBuffer"];
    var normals_ = data_["normalBuffer"];
    var color_ = data_["color"];
    var f = 1.0/255;

    var job_ = {};
    job_.type_ = data_["type"];
    job_.program_ = data_["program"];
    job_.color_ = [color_[0]*f, color_[1]*f, color_[2]*f, color_[3]*f];
    job_.zIndex_ = data_["z-index"] + 256;
    job_.clickEvent_ = data_["click-event"];
    job_.hoverEvent_ = data_["hover-event"];
    job_.hitable_ = data_["hitable"];
    job_.eventInfo_ = data_["eventInfo"];
    job_.enterEvent_ = data_["enter-event"];
    job_.leaveEvent_ = data_["leave-event"];
    job_.state_ = data_["state"];
    job_.center_ = data_["center"];
    job_.lod_ = data_["lod"];
    job_.layer_ = this.layer_;
    job_.lineWidth_ = data_["line-width"];
    job_.zbufferOffset_ = data_["zbuffer-offset"];

    if (data_["texture"] != null) {
        var texture_ = data_["texture"];
        var bitmap_ = texture_[0];
        job_.texture_ = [this.renderer_.getBitmap(bitmap_["url"], bitmap_["filter"] || "linear", bitmap_["tiled"] || false),
                                                  texture_[1], texture_[2], texture_[3], texture_[4]];
        var background_ = data_["background"];

        if (background_[3] != 0) {
            job_.background_ = [background_[0]*f, background_[1]*f, background_[2]*f, background_[3]*f];
        }
    }

    switch(job_.type_) {
        case "flat-tline":   job_.program_ = (background_[3] != 0) ? this.renderer_.progTBLine_ : this.renderer_.progTLine_;  break;
        case "pixel-line":   job_.program_ = this.renderer_.progLine3_;  break;
        case "pixel-tline":  job_.program_ = (background_[3] != 0) ? this.renderer_.progTPBLine_ : this.renderer_.progTPLine_; break;
    }

    //create vertex buffer
    job_.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    job_.vertexPositionBuffer_.itemSize = 4;
    job_.vertexPositionBuffer_.numItems = vertices_.length / 4;

    //create normal buffer
    job_.vertexNormalBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexNormalBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(normals_), gl_.STATIC_DRAW);
    job_.vertexNormalBuffer_.itemSize = 4;
    job_.vertexNormalBuffer_.numItems = normals_.length / 4;

    this.jobs_.push(job_);

    this.size_ += job_.vertexPositionBuffer_.numItems * 3 * 4 + job_.vertexNormalBuffer_.numItems * 4 * 4;
    this.polygons_ += job_.vertexPositionBuffer_.numItems / 3;
};

Vadstena.GpuGroup.prototype.addLineLabelJob = function(data_)
{
    var gl_ = this.gl_;

    var vertices_ = data_["vertexBuffer"];
    var texcoords_ = data_["texcoordsBuffer"];
    var color_ = data_["color"];
    var f = 1.0/255;

    var job_ = {};
    job_.type_ = "line-label";
    job_.program_ = data_["program"];
    job_.color_ = [color_[0]*f, color_[1]*f, color_[2]*f, color_[3]*f];
    job_.zIndex_ = data_["z-index"] + 256;
    job_.clickEvent_ = data_["click-event"];
    job_.hoverEvent_ = data_["hover-event"];
    job_.enterEvent_ = data_["enter-event"];
    job_.leaveEvent_ = data_["leave-event"];
    job_.hitable_ = data_["hitable"];
    job_.eventInfo_ = data_["eventInfo"];
    job_.state_ = data_["state"];
    job_.center_ = data_["center"];
    job_.lod_ = data_["lod"];
    job_.zbufferOffset_ = data_["zbuffer-offset"];

    //create vertex buffer
    job_.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    job_.vertexPositionBuffer_.itemSize = 3;
    job_.vertexPositionBuffer_.numItems = vertices_.length / 3;

    //create normal buffer
    job_.vertexTexcoordBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexTexcoordBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(texcoords_), gl_.STATIC_DRAW);
    job_.vertexTexcoordBuffer_.itemSize = 4;
    job_.vertexTexcoordBuffer_.numItems = texcoords_.length / 4;

    this.jobs_.push(job_);

    this.size_ += job_.vertexPositionBuffer_.numItems * 3 * 4 + job_.vertexTexcoordBuffer_.numItems * 4 * 4;
    this.polygons_ += job_.vertexPositionBuffer_.numItems / 3;
};

Vadstena.GpuGroup.prototype.addIconJob = function(data_, label_)
{
    var gl_ = this.gl_;

    var vertices_ = data_["vertexBuffer"];
    var texcoords_ = data_["texcoordsBuffer"];
    var origins_ = data_["originBuffer"];
    var color_ = data_["color"];
    var f = 1.0/255;

    var job_ = {};
    job_.type_ = label_ ? "label" : "icon";
    job_.program_ = data_["program"];
    job_.color_ = [color_[0]*f, color_[1]*f, color_[2]*f, color_[3]*f];
    job_.zIndex_ = data_["z-index"] + 256;
    job_.visibility_ = data_["visibility"];
    job_.center_ = data_["center"];
    job_.clickEvent_ = data_["click-event"];
    job_.hoverEvent_ = data_["hover-event"];
    job_.enterEvent_ = data_["enter-event"];
    job_.leaveEvent_ = data_["leave-event"];
    job_.hitable_ = data_["hitable"];
    job_.eventInfo_ = data_["eventInfo"];
    job_.state_ = data_["state"];
    job_.center_ = data_["center"];
    job_.lod_ = data_["lod"];
    job_.zbufferOffset_ = data_["zbuffer-offset"];

    if (label_ != true) {
        var icon_ = data_["icon"];
        job_.texture_ = this.renderer_.getBitmap(icon_["url"], icon_["filter"] || "linear", icon_["tiled"] || false);
    } else {
        job_.texture_ = this.renderer_.font_.texture_;
    }

    //create vertex buffer
    job_.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    job_.vertexPositionBuffer_.itemSize = 3;
    job_.vertexPositionBuffer_.numItems = vertices_.length / 3;

    //create normal buffer
    job_.vertexTexcoordBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexTexcoordBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(texcoords_), gl_.STATIC_DRAW);
    job_.vertexTexcoordBuffer_.itemSize = 4;
    job_.vertexTexcoordBuffer_.numItems = texcoords_.length / 4;

    //create origin buffer
    job_.vertexOriginBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexOriginBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(origins_), gl_.STATIC_DRAW);
    job_.vertexOriginBuffer_.itemSize = 3;
    job_.vertexOriginBuffer_.numItems = origins_.length / 3;

    this.jobs_.push(job_);

    this.size_ += job_.vertexPositionBuffer_.numItems * 3 * 4 +
                  job_.vertexOriginBuffer_.numItems * 3 * 4 +
                  job_.vertexTexcoordBuffer_.numItems * 4 * 4;
    this.polygons_ += job_.vertexPositionBuffer_.numItems / 3;
};


Vadstena.GpuGroup.prototype.addRenderJob = function(data_)
{
    switch(data_["type"]) {
        case "flat-line":  this.addLineJob(data_); break;
        case "flat-tline": this.addExtentedLineJob(data_); break;
        case "pixel-line": this.addExtentedLineJob(data_); break;
        case "pixel-tline": this.addExtentedLineJob(data_); break;
        case "line-label": this.addLineLabelJob(data_); break;
        case "icon":       this.addIconJob(data_); break;
        case "label":      this.addIconJob(data_, true); break;
    }
};

Vadstena.GpuGroup.prototype.draw = function(mv_, mvp_, applyOrigin_)
{
    if (this.id_ != null) {
        if (this.renderer_.layerGroupVisible_[this.id_] === false) {
            return;
        }
    }

    if (applyOrigin_ == true) {
        var mvp2_ = Vadstena.mat4.create();
        var mv2_ = Vadstena.mat4.create();

        var pos_ = this.renderer_.position_;

        var transform_ = this.renderer_.layerGroupTransform_[this.id_];

        if (transform_ != null) {
            var origin_ = transform_[1];
            origin_ = [origin_[0] - pos_[0], origin_[1] - pos_[1], origin_[2]];
            Vadstena.mat4.multiply(Vadstena.translationMatrix(origin_[0], origin_[1], origin_[2]), transform_[0], mv2_);
            Vadstena.mat4.multiply(mv_, mv2_, mv2_);
        } else {
            var origin_ = [this.origin_[0] - pos_[0], this.origin_[1] - pos_[1], this.origin_[2]];
            Vadstena.mat4.multiply(mv_, Vadstena.translationMatrix(origin_[0], origin_[1], origin_[2]), mv2_);
        }

        Vadstena.mat4.multiply(mvp_, mv2_, mvp2_);
        mv_ = mv2_;
        mvp_ = mvp2_;
    }

    var gl_ = this.gl_;
    var gpu_ = this.gpu_;

    var planet_ = this.renderer_.getPlanet();
    var cameraPos_ = this.renderer_.cameraPosition();

    var jobZBuffer_ = planet_.jobZBuffer_;
    var jobZBufferSize_ = planet_.jobZBufferSize_;

    var onlyHitable_ = this.renderer_.onlyHitLayers_;

    for (var i = 0, li = this.jobs_.length; i < li; i++) {
        var job_ = this.jobs_[i];

        if ((job_.type_ == "icon" || job_.type_ == "label") && job_.visibility_ > 0) {
            var center_ = job_.center_;
            if (Vadstena.vec3.length([center_[0]-cameraPos_[0],
                                      center_[1]-cameraPos_[1],
                                      center_[2]-cameraPos_[2]]) > job_.visibility_) {
                continue;
            }
        }

        if (onlyHitable_ && !job_.hitable_) {
            continue;
        }

        job_.mv_ = mv_;
        job_.mvp_ = mvp_;

        var zIndex_ = job_.zIndex_;
        jobZBuffer_[zIndex_][jobZBufferSize_[zIndex_]] = job_;
        jobZBufferSize_[zIndex_]++;
    }
};

Vadstena.drawGpuJob = function(gpu_, gl_, renderer_, job_, screenPixelSize_)
{
    var mv_ = job_.mv_;
    var mvp_ = job_.mvp_;

    if (job_.state_ != 0) {
        var id_ = job_.eventInfo_["id"];

        if (id_ != null && renderer_.hoverFeature_ != null) {
            if (job_.state_ == 1){  // 1 = no hover state

                if (renderer_.hoverFeature_[0]["id"] == id_) { //are we hovering over feature?
                    return;
                }

            } else { // 2 = hover state

                if (renderer_.hoverFeature_[0]["id"] != id_) { //are we hovering over feature?
                    return;
                }

            }
        } else { //id id provided
            if (job_.state_ == 2) { //skip hover style
                return;
            }
        }
    }

    var hitmapRender_ = job_.hitable_ && renderer_.onlyHitLayers_;

    var color_ = job_.color_;

    if (hitmapRender_) {
        var c = renderer_.hoverFeatureCounter_;
        color_ = [(c&255)/255, ((c>>8)&255)/255, ((c>>16)&255)/255, 1];
        renderer_.hoverFeatureList_[c] = [job_.eventInfo_, job_.center_, job_.clickEvent_, job_.hoverEvent_, job_.enterEvent_, job_.leaveEvent_];
        renderer_.hoverFeatureCounter_++;
    }

    switch(job_.type_) {
        case "flat-line":

            gpu_.setState(Vadstena.StencilLineState_, renderer_.getZoffsetFactor(job_.zbufferOffset_));
            var prog_ = renderer_.progLine_;

            gpu_.useProgram(prog_, "aPosition", null, null, null);
            prog_.setVec4("uColor", color_);
            prog_.setMat4("uMVP", mvp_);

            var vertexPositionAttribute_ = prog_.getAttribute("aPosition");

            //bind vetex positions
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);
            gl_.vertexAttribPointer(vertexPositionAttribute_, job_.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //draw polygons
            gl_.drawArrays(gl_.TRIANGLES, 0, job_.vertexPositionBuffer_.numItems);

            break;

        case "flat-tline":
        case "pixel-line":
        case "pixel-tline":

            gpu_.setState(Vadstena.StencilLineState_, renderer_.getZoffsetFactor(job_.zbufferOffset_));
            var prog_ = job_.program_;
            var texture_ = null;
            var textureParams_ = [0,0,0,0];

            if (job_.type_ != "pixel-line") {

                if (hitmapRender_) {
                    texture_ = renderer_.whiteTexture_;
                } else {
                    var t = job_.texture_;

                    if (t == null || t[0] == null) {
                        return;
                    }

                    texture_ = t[0];
                    textureParams_ = [0, t[1]/t[0].height_, (t[1]+t[2])/t[0].height_, 0];

                    if (job_.type_ == "flat-tline") {
                        textureParams_[0] = 1/job_.lineWidth_/(texture_.width_/t[2]);
                    } else {
                        var lod_ = job_.lod_ || job_.layer_.currentLod_;
                        var tileSize_ = job_.layer_.browser_.mapConfig_.tileSize(lod_);
                        var tilePixelSize_ = tileSize_ / job_.layer_.tilePixels_;
                        textureParams_[0] = 1/texture_.width_/tilePixelSize_;
                    }
                }

                if (texture_.loaded_ == false) {
                    return;
                }

                gpu_.bindTexture(texture_);
            }

            gpu_.useProgram(prog_, "aPosition", null, null, null);
            prog_.setVec4("uColor", color_);
            prog_.setVec2("uScale", screenPixelSize_);
            prog_.setMat4("uMVP", mvp_);

            if (job_.type_ != "pixel-line") {
                if (job_.background_ != null) {
                    prog_.setVec4("uColor2", job_.background_);
                }
                prog_.setVec4("uParams", textureParams_);
                prog_.setSampler("uSampler", 0);
            }

            var vertexPositionAttribute_ = prog_.getAttribute("aPosition");
            var vertexNormalAttribute_ = prog_.getAttribute("aNormal");

            //bind vetex positions
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);
            gl_.vertexAttribPointer(vertexPositionAttribute_, job_.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //bind vetex normals
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexNormalBuffer_);
            gl_.vertexAttribPointer(vertexNormalAttribute_, job_.vertexNormalBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //draw polygons
            gl_.drawArrays(gl_.TRIANGLES, 0, job_.vertexPositionBuffer_.numItems);

            break;

        case "line-label":

            var texture_ = hitmapRender_ ? renderer_.whiteTexture_ : renderer_.font_.texture_;

            var yaw_ = Vadstena.radians(renderer_.orientation_[0]);
            var forward_ = [-Math.sin(yaw_), Math.cos(yaw_), 0, 0];

            gpu_.setState(Vadstena.LineLabelState_, renderer_.getZoffsetFactor(job_.zbufferOffset_));
            var prog_ = renderer_.progText_;

            gpu_.bindTexture(texture_);

            gpu_.useProgram(prog_, "aPosition", "aTexCoord", null, null);
            prog_.setSampler("uSampler", 0);
            prog_.setMat4("uMVP", mvp_);
            prog_.setVec4("uVec", forward_);
            prog_.setVec4("uColor", color_);
            //prog_.setVec2("uScale", screenPixelSize_);

            var vertexPositionAttribute_ = prog_.getAttribute("aPosition");
            var vertexTexcoordAttribute_ = prog_.getAttribute("aTexCoord");

            //bind vetex positions
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);
            gl_.vertexAttribPointer(vertexPositionAttribute_, job_.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //bind vetex texcoords
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexTexcoordBuffer_);
            gl_.vertexAttribPointer(vertexTexcoordAttribute_, job_.vertexTexcoordBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //draw polygons
            gl_.drawArrays(gl_.TRIANGLES, 0, job_.vertexPositionBuffer_.numItems);

            break;

        case "icon":
        case "label":

            var texture_ = hitmapRender_ ? renderer_.whiteTexture_ : job_.texture_;

            if (texture_.loaded_ == false) {
                return;
            }

            //value larger then 0 means that visibility is tested
            //if (job_.visibility_ != 0) {
                //job_.visibility_
            //}

            gpu_.setState(Vadstena.LineLabelState_, renderer_.getZoffsetFactor(job_.zbufferOffset_));
            var prog_ = renderer_.progIcon_;

            gpu_.bindTexture(texture_);

            gpu_.useProgram(prog_, "aPosition", "aTexCoord", null, "aOrigin");
            prog_.setSampler("uSampler", 0);
            prog_.setMat4("uMVP", mvp_);
            prog_.setVec4("uScale", [screenPixelSize_[0], screenPixelSize_[1], (job_.type_ == "label" ? 1.0 : 1.0 / texture_.width_), 0]);
            prog_.setVec4("uColor", color_);
            //prog_.setVec2("uScale", screenPixelSize_);

            var vertexPositionAttribute_ = prog_.getAttribute("aPosition");
            var vertexTexcoordAttribute_ = prog_.getAttribute("aTexCoord");
            var vertexOriginAttribute_ = prog_.getAttribute("aOrigin");

            //bind vetex positions
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexPositionBuffer_);
            gl_.vertexAttribPointer(vertexPositionAttribute_, job_.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //bind vetex texcoordds
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexTexcoordBuffer_);
            gl_.vertexAttribPointer(vertexTexcoordAttribute_, job_.vertexTexcoordBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //bind vetex origin
            gl_.bindBuffer(gl_.ARRAY_BUFFER, job_.vertexOriginBuffer_);
            gl_.vertexAttribPointer(vertexOriginAttribute_, job_.vertexOriginBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

            //draw polygons
            gl_.drawArrays(gl_.TRIANGLES, 0, job_.vertexPositionBuffer_.numItems);

            break;

    }

};


//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//3D Line, line width is defined in meters

/**
 * @constructor
 */
Vadstena.GpuLine = function(gpu_, browser_)
{
    this.bbox_ = null;
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.browser_ = browser_;

    var timer_ = performance.now();

    var gl_ = this.gl_;

    if (gl_ == null)
        return;

    this.vertices_ = [];
    this.vertexPositionBuffer_ = null;

};

//destructor
Vadstena.GpuLine.prototype.kill = function()
{
    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxMesh_[1][0] ++;
        this.browser_.renderer_.statsFluxMesh_[1][1] += this.size_;
    }
*/
};

//add line to vertices buffer
Vadstena.GpuLine.prototype.addLine = function(p1, p2, size_)
{
    //get direction vector
    var v = [p2[0] - p1[0], p2[1] - p1[1], 0];

    //normalize vector
    var n = [0,0,0];
    Vadstena.vec3.normalize(v, n);
    n = [-n[1],n[0],0];

    n[0] *= size_;
    n[1] *= size_;
    n[2] *= size_;

    var index_ = this.vertices_.length;

    //first polygon
    this.vertices_[index_] = p1[0] + n[0];
    this.vertices_[index_+1] = p1[1] + n[1];
    this.vertices_[index_+2] = p1[2] + n[2];

    this.vertices_[index_+3] = p1[0] - n[0];
    this.vertices_[index_+4] = p1[1] - n[1];
    this.vertices_[index_+5] = p1[2] - n[2];

    this.vertices_[index_+6] = p2[0] + n[0];
    this.vertices_[index_+7] = p2[1] + n[1];
    this.vertices_[index_+8] = p2[2] + n[2];


    //next polygon
    this.vertices_[index_+9] = p1[0] - n[0];
    this.vertices_[index_+10] = p1[1] - n[1];
    this.vertices_[index_+11] = p1[2] - n[2];

    this.vertices_[index_+12] = p2[0] - n[0];
    this.vertices_[index_+13] = p2[1] - n[1];
    this.vertices_[index_+14] = p2[2] - n[2];

    this.vertices_[index_+15] = p2[0] + n[0];
    this.vertices_[index_+16] = p2[1] + n[1];
    this.vertices_[index_+17] = p2[2] + n[2];

    this.polygons_ += 2;
};

//add circle to vertices buffer
Vadstena.GpuLine.prototype.addCircle = function(p1, size_, sides_)
{
    var i;

    if (this.circleBuffer_ == null) {

        this.circleBuffer_ = [];
        var buffer_ = this.circleBuffer_;

        var angle_ = 0, step_ = (2.0*Math.PI) / sides_;

        for (i = 0; i < sides_; i++) {
            buffer_[i] = [-Math.sin(angle_), Math.cos(angle_)];
            angle_ += step_;
        }

        buffer_[sides_] = [0, 1.0];
    }

    var buffer_ = this.circleBuffer_;
    var index_ = this.vertices_.length;

    for (i = 0; i < sides_; i++) {

        this.vertices_[index_] = p1[0];
        this.vertices_[index_+1] = p1[1];
        this.vertices_[index_+2] = p1[2];

        this.vertices_[index_+3] = p1[0] + buffer_[i][0] * size_;
        this.vertices_[index_+4] = p1[1] + buffer_[i][1] * size_;
        this.vertices_[index_+5] = p1[2];

        this.vertices_[index_+6] = p1[0] + buffer_[i+1][0] * size_;
        this.vertices_[index_+7] = p1[1] + buffer_[i+1][1] * size_;
        this.vertices_[index_+8] = p1[2];

        index_ += 9;
    }

    this.polygons_ += sides_;
};

//compile content of vertices buffer into gpu buffer
Vadstena.GpuLine.prototype.compile = function()
{
    var gl_ = this.gl_;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = this.vertices_.length / 3;

    this.size_ = this.vertexPositionBuffer_.numItems * 3 * 4;
    this.polygons_ = this.vertexPositionBuffer_.numItems / 3;

/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsCreateGpuMeshTime_ += performance.now() - timer_;
        this.browser_.renderer_.statsFluxMesh_[0][0] ++;
        this.browser_.renderer_.statsFluxMesh_[0][1] += this.size_;
    }
*/

};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuLine.prototype.draw = function(program_, attrPosition_, attrTexCoord_, attrBarycenteric_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.vertexPositionBuffer_ == null){
        return;
    }

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //draw polygons
    gl_.drawArrays(gl_.TRIANGLES, 0, this.vertexPositionBuffer_.numItems);
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuLine.prototype.size = function(){ return this.size_; };

Vadstena.GpuLine.prototype.bbox = function(){ return this.bbox_; };

Vadstena.GpuLine.prototype.getPolygons = function(){ return this.polygons_; };

//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//3D Line, line width is defined in pixels

/**
 * @constructor
 */
Vadstena.GpuPixelLine = function(gpu_, browser_)
{
    this.bbox_ = null;
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.browser_ = browser_;

    var timer_ = performance.now();

    var gl_ = this.gl_;

    if (gl_ == null)
        return;

    this.vertices_ = [];
    this.normals_ = [];
    this.vertexPositionBuffer_ = null;
    this.vertexNormalBuffer_ = null;
};

//destructor
Vadstena.GpuPixelLine.prototype.kill = function()
{
    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
    this.gl_.deleteBuffer(this.vertexNormalBuffer_);
/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxMesh_[1][0] ++;
        this.browser_.renderer_.statsFluxMesh_[1][1] += this.size_;
    }
*/
};

//add line to vertices buffer
Vadstena.GpuPixelLine.prototype.addLine = function(p1, p2, size_)
{
    //get direction vector
    var v = [p2[0] - p1[0], p2[1] - p1[1], 0];

    //normalize vector
    var n = [0,0,0];
    Vadstena.vec3.normalize(v, n);
    n = [-n[1],n[0],0];

    n[0] *= size_;
    n[1] *= size_;
    n[2] *= size_;

    size_ *= 0.5;

    var index_ = this.vertices_.length;
    var index2_ = this.normals_.length;

    //first polygon
    this.vertices_[index_] = p1[0];
    this.vertices_[index_+1] = p1[1];
    this.vertices_[index_+2] = p1[2];
    this.normals_[index2_] = p2[0];
    this.normals_[index2_+1] = p2[1];
    this.normals_[index2_+2] = p2[2];
    this.normals_[index2_+3] = size_;

    this.vertices_[index_+3] = p1[0];
    this.vertices_[index_+4] = p1[1];
    this.vertices_[index_+5] = p1[2];
    this.normals_[index2_+4] = p2[0];
    this.normals_[index2_+5] = p2[1];
    this.normals_[index2_+6] = p2[2];
    this.normals_[index2_+7] = -size_;

    this.vertices_[index_+6] = p2[0];
    this.vertices_[index_+7] = p2[1];
    this.vertices_[index_+8] = p2[2];
    this.normals_[index2_+8] = p1[0];
    this.normals_[index2_+9] = p1[1];
    this.normals_[index2_+10] = p1[2];
    this.normals_[index2_+11] = size_;

    //next polygon
    this.vertices_[index_+9] = p1[0];
    this.vertices_[index_+10] = p1[1];
    this.vertices_[index_+11] = p1[2];
    this.normals_[index2_+12] = p2[0];
    this.normals_[index2_+13] = p2[1];
    this.normals_[index2_+14] = p2[2];
    this.normals_[index2_+15] = size_;

    this.vertices_[index_+12] = p2[0];
    this.vertices_[index_+13] = p2[1];
    this.vertices_[index_+14] = p2[2];
    this.normals_[index2_+16] = p1[0];
    this.normals_[index2_+17] = p1[1];
    this.normals_[index2_+18] = p1[2];
    this.normals_[index2_+19] = size_;

    this.vertices_[index_+15] = p2[0];
    this.vertices_[index_+16] = p2[1];
    this.vertices_[index_+17] = p2[2];
    this.normals_[index2_+20] = p1[0];
    this.normals_[index2_+21] = p1[1];
    this.normals_[index2_+22] = p1[2];
    this.normals_[index2_+23] = -size_;

    this.polygons_ += 2;
};

//add circle to vertices buffer
Vadstena.GpuPixelLine.prototype.addCircle = function(p1, size_, sides_)
{
    //return;

    size_ *= 0.5;

    var i;

    if (this.circleBuffer_ == null) {

        this.circleBuffer_ = [];
        var buffer_ = this.circleBuffer_;

        var angle_ = 0, step_ = (2.0*Math.PI) / sides_;

        for (i = 0; i < sides_; i++) {
            buffer_[i] = [-Math.sin(angle_), Math.cos(angle_)];
            angle_ += step_;
        }

        buffer_[sides_] = [0, 1.0];
    }

    var buffer_ = this.circleBuffer_;
    var index_ = this.vertices_.length;
    var index2_ = this.normals_.length;

    for (i = 0; i < sides_; i++) {

        this.vertices_[index_] = p1[0];
        this.vertices_[index_+1] = p1[1];
        this.vertices_[index_+2] = p1[2];
        this.normals_[index2_] = 0;
        this.normals_[index2_+1] = 0;
        this.normals_[index2_+2] = 0;
        this.normals_[index2_+3] = 0;

        this.vertices_[index_+3] = p1[0];
        this.vertices_[index_+4] = p1[1];
        this.vertices_[index_+5] = p1[2];
        this.normals_[index2_+4] = buffer_[i][0] * size_;
        this.normals_[index2_+5] = buffer_[i][1] * size_;
        this.normals_[index2_+6] = 0;
        this.normals_[index2_+7] = 0;

        this.vertices_[index_+6] = p1[0];
        this.vertices_[index_+7] = p1[1];
        this.vertices_[index_+8] = p1[2];
        this.normals_[index2_+8] = buffer_[i+1][0] * size_;
        this.normals_[index2_+9] = buffer_[i+1][1] * size_;
        this.normals_[index2_+10] = 0;
        this.normals_[index2_+11] = 0;

        index_ += 9;
        index2_ += 12;
    }

    this.polygons_ += sides_;
};

//compile content of vertices buffer into gpu buffer
Vadstena.GpuPixelLine.prototype.compile = function()
{
    var gl_ = this.gl_;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = this.vertices_.length / 3;

    //create normal buffer
    this.vertexNormalBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexNormalBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.normals_), gl_.STATIC_DRAW);
    this.vertexNormalBuffer_.itemSize = 4;
    this.vertexNormalBuffer_.numItems = this.normals_.length / 4;

    this.size_ = this.vertexPositionBuffer_.numItems * 3 * 4 * 2;
    this.polygons_ = this.vertexPositionBuffer_.numItems / 3;

/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsCreateGpuMeshTime_ += performance.now() - timer_;
        this.browser_.renderer_.statsFluxMesh_[0][0] ++;
        this.browser_.renderer_.statsFluxMesh_[0][1] += this.size_;
    }
*/

};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuPixelLine.prototype.draw = function(program_, attrPosition_, attrNormal_, attrTexCoord_, attrBarycenteric_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.vertexPositionBuffer_ == null || this.vertexNormalBuffer_ == null){
        return;
    }

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);
    var vertexNormalAttribute_ = program_.getAttribute(attrNormal_);

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //bind vetex normals
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexNormalBuffer_);
    gl_.vertexAttribPointer(vertexNormalAttribute_, this.vertexNormalBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //draw polygons
    gl_.drawArrays(gl_.TRIANGLES, 0, this.vertexPositionBuffer_.numItems);
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuPixelLine.prototype.size = function(){ return this.size_; };

Vadstena.GpuPixelLine.prototype.bbox = function(){ return this.bbox_; };

Vadstena.GpuPixelLine.prototype.getPolygons = function(){ return this.polygons_; };

//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.GpuPolygon = function(gpu_, browser_)
{
    this.bbox_ = null;
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.browser_ = browser_;

    var timer_ = performance.now();

    var gl_ = this.gl_;

    if (gl_ == null)
        return;

    this.vertices_ = [];
    this.normals_ = [];
    this.vertexPositionBuffer_ = null;
    this.vertexNormalBuffer_ = null;
};

//destructor
Vadstena.GpuPolygon.prototype.kill = function()
{
    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
    this.gl_.deleteBuffer(this.vertexNormalBuffer_);
/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxMesh_[1][0] ++;
        this.browser_.renderer_.statsFluxMesh_[1][1] += this.size_;
    }
*/
};

//add face
Vadstena.GpuPolygon.prototype.addFace = function(p1, p2, p3, n)
{
    var index_ = this.vertices_.length;

    if (n == null) {
        var n = [0,0,0];
        Vadstena.vec3.cross([p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]], [p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2]], n);
    }

    this.vertices_[index_] = p1[0];
    this.vertices_[index_+1] = p1[1];
    this.vertices_[index_+2] = p1[2];
    this.normals_[index_] = n[0];
    this.normals_[index_+1] = n[1];
    this.normals_[index_+2] = n[2];

    this.vertices_[index_+3] = p2[0];
    this.vertices_[index_+4] = p2[1];
    this.vertices_[index_+5] = p2[2];
    this.normals_[index_+3] = n[0];
    this.normals_[index_+4] = n[1];
    this.normals_[index_+5] = n[2];

    this.vertices_[index_+6] = p3[0];
    this.vertices_[index_+7] = p3[1];
    this.vertices_[index_+8] = p3[2];
    this.normals_[index_+6] = n[0];
    this.normals_[index_+7] = n[1];
    this.normals_[index_+8] = n[2];

    this.polygons_++;
};

//add quad
Vadstena.GpuPolygon.prototype.addQuad = function(p1, p2, p3, p4, n)
{
    var index_ = this.vertices_.length;

    if (n == null) {
        var n = [0,0,0];
        Vadstena.vec3.cross([p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]], [p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2]], n);
        Vadstena.vec3.normalize(n);
    }

    //first polygon
    this.vertices_[index_] = p1[0];
    this.vertices_[index_+1] = p1[1];
    this.vertices_[index_+2] = p1[2];
    this.normals_[index_] = n[0];
    this.normals_[index_+1] = n[1];
    this.normals_[index_+2] = n[2];

    this.vertices_[index_+3] = p2[0];
    this.vertices_[index_+4] = p2[1];
    this.vertices_[index_+5] = p2[2];
    this.normals_[index_+3] = n[0];
    this.normals_[index_+4] = n[1];
    this.normals_[index_+5] = n[2];

    this.vertices_[index_+6] = p3[0];
    this.vertices_[index_+7] = p3[1];
    this.vertices_[index_+8] = p3[2];
    this.normals_[index_+6] = n[0];
    this.normals_[index_+7] = n[1];
    this.normals_[index_+8] = n[2];


    //next polygon
    this.vertices_[index_+9] = p1[0];
    this.vertices_[index_+10] = p1[1];
    this.vertices_[index_+11] = p1[2];
    this.normals_[index_+9] = n[0];
    this.normals_[index_+10] = n[1];
    this.normals_[index_+11] = n[2];

    this.vertices_[index_+12] = p3[0];
    this.vertices_[index_+13] = p3[1];
    this.vertices_[index_+14] = p3[2];
    this.normals_[index_+12] = n[0];
    this.normals_[index_+13] = n[1];
    this.normals_[index_+14] = n[2];

    this.vertices_[index_+15] = p4[0];
    this.vertices_[index_+16] = p4[1];
    this.vertices_[index_+17] = p4[2];
    this.normals_[index_+15] = n[0];
    this.normals_[index_+16] = n[1];
    this.normals_[index_+17] = n[2];

    this.polygons_ += 2;
};

Vadstena.GpuPolygon.prototype.addPolygon = function(outerRing_, innerRings_) {
    var contour_ = [];

    for (var i = 0, li = outerRing_.length; i < li; i++) {
        contour_.push({x: outerRing_[i][0], y: outerRing_[i][1]});
    }

    var swctx_ = new poly2tri.SweepContext(contour_);


    for (var j = 0, lj = outerRing_.length; j < lj; j++) {
        var hole_ = [];

        for (var i = 0, li = outerRing_.length; i < li; i++) {
            contour_.push({x: innerRings_[j][i][0], y: innerRings_[j][i][1]});
        }

        swctx_.addHole(hole_);
    }

    swctx_.triangulate();
    var triangles_ = swctx_.getTriangles();

    var height_ = 0;

    for (var i = 0, li = triangles_.length; i < li; i++) {
        var points_ = triangles_[i].getPoints();
        this.addFace([points_[0].x, points_[0].y, height_], [points_[1].x, points_[1].y, height_], [points_[2].x, points_[2].y, height_]);
    }
};


Vadstena.GpuPolygon.prototype.addWall = function(points_, points2_, closed_) {
    for (var i = 0, li = points_.length - 1; i < li; i++) {
        this.addQuad(points_[i], points_[i+1], points2_[i+1], points2_[i]);
    }

    if (closed_ && points_.length > 2) {
        this.addQuad(points_[points_.length-1], points_[0], points2_[0], points2_[points_.length-1]);
    }
};


//compile content of vertices buffer into gpu buffer
Vadstena.GpuPolygon.prototype.compile = function()
{
    var gl_ = this.gl_;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = this.vertices_.length / 3;

    //create normal buffer
    this.vertexNormalBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexNormalBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(this.normals_), gl_.STATIC_DRAW);
    this.vertexNormalBuffer_.itemSize = 3;
    this.vertexNormalBuffer_.numItems = this.normals_.length / 3;

    this.size_ = this.vertexPositionBuffer_.numItems * 3 * 4 * 2;
    this.polygons_ = this.vertexPositionBuffer_.numItems / 3;

/*
    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsCreateGpuMeshTime_ += performance.now() - timer_;
        this.browser_.renderer_.statsFluxMesh_[0][0] ++;
        this.browser_.renderer_.statsFluxMesh_[0][1] += this.size_;
    }
*/

};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuPolygon.prototype.draw = function(program_, attrPosition_, attrNormal_, attrTexCoord_, attrBarycenteric_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.vertexPositionBuffer_ == null || this.vertexNormalBuffer_ == null){
        return;
    }

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);
    var vertexNormalAttribute_ = program_.getAttribute(attrNormal_);

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //bind vetex normals
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexNormalBuffer_);
    gl_.vertexAttribPointer(vertexNormalAttribute_, this.vertexNormalBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //draw polygons
    gl_.drawArrays(gl_.TRIANGLES, 0, this.vertexPositionBuffer_.numItems);
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuPolygon.prototype.size = function(){ return this.size_; };

Vadstena.GpuPolygon.prototype.bbox = function(){ return this.bbox_; };

Vadstena.GpuPolygon.prototype.getPolygons = function(){ return this.polygons_; };


/**
 * @constructor
 */
Vadstena.GpuDevice = function(div_, size_, keepFrameBuffer_)
{
    this.div_ = div_;
    this.canvas_ =  null;
    this.curSize_ = size_;
    this.currentProgram_ = null;

    this.defaultState_ = this.createState({});
    this.currentState_ = this.defaultState_;
    this.currentOffset_ = 0; //used fot direct offset

    this.keepFrameBuffer_ = (keepFrameBuffer_ == null) ? false : keepFrameBuffer_;
};

Vadstena.GpuDevice.prototype.init = function()
{
    this.canvas_ = document.createElement("canvas");

    if (this.canvas_ == null) {
        //canvas not supported
        return;
    }

    this.canvas_.width = this.curSize_[0];
    this.canvas_.height = this.curSize_[1];
    this.canvas_.style.display = "block";

    if (this.canvas_.getContext == null) {
        //canvas not supported
        return;
    }

    try {
        this.gl_ = this.canvas_.getContext("webgl", {preserveDrawingBuffer: this.keepFrameBuffer_, stencil: true}) || this.canvas_.getContext("experimental-webgl", {preserveDrawingBuffer: this.keepFrameBuffer_});
    } catch(e) {
        //webgl not supported
    }

    if (!this.gl_) {
        //webgl not supported
        return;
    }

    this.gl_.getExtension('OES_standard_derivatives');

    this.div_.appendChild(this.canvas_);

    this.gl_.viewportWidth = this.canvas_.width;
    this.gl_.viewportHeight = this.canvas_.height;

    this.gl_.clearColor(0.0, 0.0, 0.0, 1.0);
    this.gl_.enable(this.gl_.DEPTH_TEST);

    //clear screen
    this.gl_.viewport(0, 0, this.gl_.viewportWidth, this.gl_.viewportHeight);
    this.gl_.clear(this.gl_.COLOR_BUFFER_BIT | this.gl_.DEPTH_BUFFER_BIT);
};

Vadstena.GpuDevice.prototype.resize = function(size_, skipCanvas_) {
    this.curSize_ = size_;

    if (this.canvas_ != null && skipCanvas_ != true)
    {
        this.canvas_.width = this.curSize_[0];
        this.canvas_.height = this.curSize_[1];
    }

    if (this.gl_ != null)
    {
        this.gl_.viewportWidth = this.canvas_.width;
        this.gl_.viewportHeight = this.canvas_.height;
    }
};

Vadstena.GpuDevice.prototype.getCanvas = function() {
    return this.canvas_;
};

Vadstena.GpuDevice.prototype.setViewport = function()
{
    this.gl_.viewport(0, 0, this.gl_.viewportWidth, this.gl_.viewportHeight);
};

Vadstena.GpuDevice.prototype.clear = function(alsoColor_)
{
    //this.gl_.viewport(0, 0, this.gl_.viewportWidth, this.gl_.viewportHeight);
    //this.gl_.viewport(0, 0, this.curSize_[0], this.curSize_[1]);
    if (alsoColor_ == true) {
        this.gl_.clear(this.gl_.COLOR_BUFFER_BIT | this.gl_.DEPTH_BUFFER_BIT);
    } else {
        this.gl_.clear(this.gl_.DEPTH_BUFFER_BIT);
    }

    this.gl_.enable(this.gl_.CULL_FACE);
};

Vadstena.GpuDevice.prototype.useProgram = function(program_, attrPosition_, attrTexCoord_, attrBarycentric_, attrNormal_, attrNormal2_, attrNormal3_)
{
    if (this.currentProgram_ != program_) {
        this.gl_.useProgram(program_.program_);
        this.currentProgram_ = program_;

        program_.setSampler("uSampler", 0);

        var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);
        this.gl_.enableVertexAttribArray(vertexPositionAttribute_);

        if (attrTexCoord_ != null) {
            var textureCoordAttribute_ = program_.getAttribute(attrTexCoord_);
            this.gl_.enableVertexAttribArray(textureCoordAttribute_);
        }

        if (attrBarycentric_ != null) {
            var barycentricAttribute_ = program_.getAttribute(attrBarycentric_);
            this.gl_.enableVertexAttribArray(barycentricAttribute_);
        }

        if (attrNormal_ != null) {
            var normalAttribute_ = program_.getAttribute(attrNormal_);
            this.gl_.enableVertexAttribArray(normalAttribute_);
        }

        if (attrNormal2_ != null) {
            var normal2Attribute_ = program_.getAttribute(attrNormal2_);
            this.gl_.enableVertexAttribArray(normal2Attribute_);
        }

        if (attrNormal3_ != null) {
            //var normal3Attribute_ = program_.getAttribute(attrNormal3_);
            //this.gl_.enableVertexAttribArray(normal3Attribute_);
        }

    }
};

Vadstena.GpuDevice.prototype.bindTexture = function(texture_)
{
    if (texture_.loaded_ == false) {
        return;
    }

    this.gl_.activeTexture(this.gl_.TEXTURE0);
    this.gl_.bindTexture(this.gl_.TEXTURE_2D, texture_.texture_);
};

Vadstena.GpuDeviceSupported = function()
{
    return true;
};

Vadstena.GpuDevice.prototype.setFramebuffer = function(texture_)
{
    if (texture_ != null) {
        this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER, texture_.framebuffer_);
        //utResizeViewport(texture_.framebuffer_.width, texture_.framebuffer_.height, true);
    } else {
        this.gl_.bindTexture(this.gl_.TEXTURE_2D, null);
        this.gl_.bindRenderbuffer(this.gl_.RENDERBUFFER, null);
        this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER, null);
    }

};

Vadstena.GpuDevice.prototype.createState = function(state_)
{
    if (state_.blend_ == null) { state_.blend_ = false; }
    if (state_.stencil_ == null) { state_.stencil_ = false; }
    if (state_.zoffset_ == null) { state_.zoffset_ = 0; }
    if (state_.zwrite_ == null) { state_.zwrite_ = true; }
    if (state_.ztest_ == null) { state_.ztest_ = true; }
    if (state_.culling_ == null) { state_.culling_ = true; }

    return state_;
};

Vadstena.GpuDevice.prototype.setState = function(state_, directOffset_)
{
    if (this.currentState_ == state_) {

        if (directOffset_ != null) {
            if (directOffset_ != this.currentOffset_) {
                this.currentOffset_ = directOffset_;
                this.gl_.polygonOffset(-1.0, directOffset_);
            }
        }

        return;
    }

    var gl_ = this.gl_;
    var currentState_ = this.currentState_;
    directOffset_ = directOffset_ || state_.zoffset_;

    if (currentState_.blend_ != state_.blend_) {
        if (state_.blend_ == true) {
            gl_.blendEquationSeparate(gl_.FUNC_ADD, gl_.FUNC_ADD);
            gl_.blendFuncSeparate(gl_.SRC_ALPHA, gl_.ONE_MINUS_SRC_ALPHA, gl_.ONE, gl_.ONE_MINUS_SRC_ALPHA);
            gl_.enable(gl_.BLEND);
        } else {
            gl_.disable(gl_.BLEND);
        }
    }

    if (currentState_.stencil_ != state_.stencil_) {
        if (state_.stencil_ == true) {
            gl_.enable(gl_.STENCIL_TEST);
        } else {
            gl_.disable(gl_.STENCIL_TEST);
        }
    }

    if (currentState_.zoffset_ != directOffset_) {
        if (directOffset_ != 0) {
            gl_.polygonOffset(-1.0, directOffset_);
            gl_.enable(gl_.POLYGON_OFFSET_FILL);
        } else {
            gl_.disable(gl_.POLYGON_OFFSET_FILL);
        }
        this.currentOffset_ = directOffset_;
    }

    if (currentState_.zwrite_ != state_.zwrite_) {
        if (state_.zwrite_ == true) {
            gl_.depthMask(true);
        } else {
            gl_.depthMask(false);
        }
    }

    if (currentState_.ztest_ != state_.ztest_) {
        if (state_.ztest_ != 0) {
            gl_.enable(gl_.DEPTH_TEST);
        } else {
            gl_.disable(gl_.DEPTH_TEST);
        }
    }

    if (currentState_.culling_ != state_.culling_) {
        if (state_.culling_ == true) {
            gl_.enable(gl_.CULL_FACE);
        } else {
            gl_.disable(gl_.CULL_FACE);
        }
    }

    this.currentState_ = state_;
};





//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.GpuBBox = function(gpu_)
{
    this.gl_ = gpu_.gl_;

    var gl_ = this.gl_;

    if (gl_ == null)
        return;

    this.vertexPositionBuffer_ = null;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    var vertices_ = [0,0,0, 1,0,0,
                     1,0,0, 1,1,0,
                     1,1,0, 0,1,0,
                     0,1,0, 0,0,0,

                     0,0,1, 1,0,1,
                     1,0,1, 1,1,1,
                     1,1,1, 0,1,1,
                     0,1,1, 0,0,1,

                     0,0,0, 0,0,1,
                     1,0,0, 1,0,1,
                     1,1,0, 1,1,1,
                     0,1,0, 0,1,1 ];

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = vertices_.length / 3;

    this.size_ = 4 + 4 * 8;
    this.lines_ = this.vertexPositionBuffer_.numItems / 3;
};

//destructor
Vadstena.GpuBBox.prototype.kill = function()
{
    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuBBox.prototype.draw = function(program_, attrPosition_)
{
    var gl_ = this.gl_;
    if (gl_ == null)
        return;

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //draw lines
    gl_.drawArrays(gl_.LINES, 0, this.vertexPositionBuffer_.numItems);

};

//! Holds a GPU vertex buffer.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.GpuBarycentricVertexBuffer_ = null;

/**
 * @constructor
 */
Vadstena.GpuMesh = function(gpu_, mesh_, fileSize_, browser_)
{
    this.bbox_ = mesh_.bbox_; //!< bbox copy from Mesh
    this.gl_ = gpu_.gl_;
    this.fileSize_ = fileSize_; //used for stats
    this.browser_ = browser_;

    var timer_ = performance.now();

    var gl_ = this.gl_;

    if (gl_ == null)
        return;

    this.vertexPositionBuffer_ = null;
    this.vertexTextureCoordBuffer_ = null;

    //create vertex buffer
    this.vertexPositionBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(mesh_.vertices_), gl_.STATIC_DRAW);
    this.vertexPositionBuffer_.itemSize = 3;
    this.vertexPositionBuffer_.numItems = mesh_.vertices_.length / 3;

    //create texture coords buffer
    this.vertexTextureCoordBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexTextureCoordBuffer_);

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(mesh_.tvertices_), gl_.STATIC_DRAW);
    this.vertexTextureCoordBuffer_.itemSize = 2;
    this.vertexTextureCoordBuffer_.numItems = mesh_.tvertices_.length / 2;

    this.size_ = this.vertexPositionBuffer_.numItems * 3 * 4 + this.vertexTextureCoordBuffer_.numItems * 2 * 4;
    this.polygons_ = this.vertexPositionBuffer_.numItems / 3;


    if (Vadstena.GpuBarycentricVertexBuffer_ == null) {

        var buffer_ = new Array(65535*3);

        for (var i = 0; i < 65535*3; i+=9) {
            buffer_[i] = 1.0;
            buffer_[i+1] = 0;
            buffer_[i+2] = 0;

            buffer_[i+3] = 0;
            buffer_[i+4] = 1.0;
            buffer_[i+5] = 0;

            buffer_[i+6] = 0;
            buffer_[i+7] = 0;
            buffer_[i+8] = 1.0;
        }

        Vadstena.GpuBarycentricVertexBuffer_ = gl_.createBuffer();
        gl_.bindBuffer(gl_.ARRAY_BUFFER, Vadstena.GpuBarycentricVertexBuffer_);

        gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(buffer_), gl_.STATIC_DRAW);
        Vadstena.GpuBarycentricVertexBuffer_.itemSize = 3;
        Vadstena.GpuBarycentricVertexBuffer_.numItems = buffer_.length / 3;
    }

    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsCreateGpuMeshTime_ += performance.now() - timer_;
        this.browser_.renderer_.statsFluxMesh_[0][0] ++;
        this.browser_.renderer_.statsFluxMesh_[0][1] += this.size_;
    }

};

//destructor
Vadstena.GpuMesh.prototype.kill = function()
{
    this.gl_.deleteBuffer(this.vertexPositionBuffer_);
    this.gl_.deleteBuffer(this.vertexTextureCoordBuffer_);

    if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxMesh_[1][0] ++;
        this.browser_.renderer_.statsFluxMesh_[1][1] += this.size_;
    }
};

//! Draws the mesh, given the two vertex shader attributes locations.
Vadstena.GpuMesh.prototype.draw = function(program_, attrPosition_, attrTexCoord_, attrBarycenteric_)
{
    var gl_ = this.gl_;
    if (gl_ == null)
        return;

    var vertexPositionAttribute_ = program_.getAttribute(attrPosition_);
    var textureCoordAttribute_ = program_.getAttribute(attrTexCoord_);

    if (attrBarycenteric_ != null) {
        var barycentericAttribute_ = program_.getAttribute(attrBarycenteric_);
    }

    //bind vetex positions
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexPositionBuffer_);
    gl_.vertexAttribPointer(vertexPositionAttribute_, this.vertexPositionBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    //bind texture coords
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.vertexTextureCoordBuffer_);
    gl_.vertexAttribPointer(textureCoordAttribute_, this.vertexTextureCoordBuffer_.itemSize, gl_.FLOAT, false, 0, 0);

    if (attrBarycenteric_ != null) {
        gl_.bindBuffer(gl_.ARRAY_BUFFER, Vadstena.GpuBarycentricVertexBuffer_);
        gl_.vertexAttribPointer(barycentericAttribute_, Vadstena.GpuBarycentricVertexBuffer_.itemSize, gl_.FLOAT, false, 0, 0);
    }

    //draw polygons
    gl_.drawArrays(gl_.TRIANGLES, 0, this.vertexPositionBuffer_.numItems);
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuMesh.prototype.size = function(){ return this.size_; };

Vadstena.GpuMesh.prototype.bbox = function(){ return this.bbox_; };

Vadstena.GpuMesh.prototype.getPolygons = function(){ return this.polygons_; };


/**
 * @constructor
 */
Vadstena.GpuProgram = function(gpu_, vertex_, fragment_) {
    this.gl_ = gpu_.gl_;
    this.vertex_ = vertex_;
    this.fragment_ = fragment_;
    this.program_ = null;
    this.uniformLocationCache_ = [];
    this.attributeLocationCache_ = [];
    this.createProgram(vertex_, fragment_);
};


Vadstena.GpuProgram.prototype.createShader = function(source_, vertexShader_)
{
    if (!source_) {
        return null;
    }

    var gl_ = this.gl_;

    if (gl_ == null) {
        return;
    }

    var shader_;

    if (vertexShader_ != true) {
        shader_ = gl_.createShader(gl_.FRAGMENT_SHADER);
    } else {
        shader_ = gl_.createShader(gl_.VERTEX_SHADER);
    }

    gl_.shaderSource(shader_, source_);
    gl_.compileShader(shader_);

    if (!gl_.getShaderParameter(shader_, gl_.COMPILE_STATUS)) {
        alert("An error occurred compiling the shaders: " + gl_.getShaderInfoLog(shader_));
        return null;
    }

    return shader_;
};


Vadstena.GpuProgram.prototype.createProgram = function(vertex_, fragment_)
{
    var gl_ = this.gl_;
    if (gl_ == null) return;

    var vertexShader_ = this.createShader(vertex_, true);
    var fragmentShader_ = this.createShader(fragment_, false);

    var program_ = gl_.createProgram();
    gl_.attachShader(program_, vertexShader_);
    gl_.attachShader(program_, fragmentShader_);
    gl_.linkProgram(program_);

    if (!gl_.getProgramParameter(program_, gl_.LINK_STATUS)) {
        alert("Unable to initialize the shader program.");
    }

    gl_.useProgram(program_);

    this.program_ = program_;
};

Vadstena.GpuProgram.prototype.setSampler = function(name_, index_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniform1i(key_, index_);
    }
};

Vadstena.GpuProgram.prototype.setMat4 = function(name_, m_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniformMatrix4fv(key_, false, m_);
    }
};

Vadstena.GpuProgram.prototype.setVec2 = function(name_, m_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniform2fv(key_, m_);
    }
};

Vadstena.GpuProgram.prototype.setVec4 = function(name_, m_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniform4fv(key_, m_);
    }
};

Vadstena.GpuProgram.prototype.setFloat = function(name_, value_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniform1f(key_, value_);
    }
};

Vadstena.GpuProgram.prototype.setFloatArray = function(name_, array_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    var key_ = this.getUniform(name_);
    if (key_ != null) {
        gl_.uniform1fv(key_, array_);
    }
};


Vadstena.GpuProgram.prototype.getAttribute = function(name_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    if (this.attributeLocationCache_[name_] == null) {
        var location_ = gl_.getAttribLocation(this.program_, name_);
        this.attributeLocationCache_[name_] = location_;
        return location_;
    } else {
        return this.attributeLocationCache_[name_];
    }
};

Vadstena.GpuProgram.prototype.getUniform = function(name_)
{
    var gl_ = this.gl_;
    if (gl_ == null || this.program_ == null) return;

    if (this.uniformLocationCache_[name_] == null) {
        var location_ = gl_.getUniformLocation(this.program_, name_);
        this.uniformLocationCache_[name_] = location_;
        return location_;
    } else {
        return this.uniformLocationCache_[name_];
    }
};

Vadstena.bboxVertexShader =
    "attribute vec3 aPosition;\n"+
    "uniform mat4 uMVP;\n"+
    "void main(){ \n"+
        "gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
    "}";

Vadstena.bboxFragmentShader = "precision mediump float;\n"+
    "void main() {\n"+
        "gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n"+
    "}";

Vadstena.lineVertexShader =
    "attribute vec3 aPosition;\n"+
    "uniform mat4 uMVP;\n"+
    "void main(){ \n"+
        "gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
    "}";

Vadstena.lineFragmentShader = "precision mediump float;\n"+
    "uniform vec4 uColor;\n"+
    "void main() {\n"+
        "gl_FragColor = uColor;\n"+
    "}";

Vadstena.line3VertexShader =
    "attribute vec4 aPosition;\n"+
    "attribute vec4 aNormal;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec2 uScale;\n"+
    "void main(){ \n"+
        "vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n"+
        "if (aNormal.w == 0.0) {\n"+
            "gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n"+
        "} else {\n"+
            "vec2 pp1 = pp0.xy / pp0.w;\n"+
            "vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n"+
            "vec2 pp2 = pp3.xy / pp3.w;\n"+
            "vec2 n = normalize(pp2 - pp1);\n"+
            "gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n"+
        "}\n"+
    "}";

Vadstena.line3FragmentShader = "precision mediump float;\n"+
    "uniform vec4 uColor;\n"+
    "void main() {\n"+
        "gl_FragColor = uColor;\n"+
    "}";

Vadstena.tlineVertexShader =
    "attribute vec4 aPosition;\n"+
    "attribute vec4 aNormal;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec2 uScale;\n"+
    "uniform vec4 uParams;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "vec4 p=vec4(aPosition.xyz, 1.0);\n"+
        "p.xy+=aNormal.xy;\n"+
        "if (aNormal.w == 0.0){\n"+
            "float tcy=(uParams[1]+uParams[2])*0.5;\n"+
            "float tdy=uParams[1]-tcy;\n"+
            "float ty=(aNormal.x == 0.0 && aNormal.y == 0.0)?tcy:tcy+tdy*cos(aNormal.z);\n"+
//            "float ty=tcy;\n"+
            "vTexCoord=vec2(abs(aPosition.w)*uParams[0], ty);\n"+
        "} else {\n"+
            "vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n"+
        "}\n"+

        "gl_Position = uMVP * p;\n"+
    "}";

Vadstena.tplineVertexShader =
    "attribute vec4 aPosition;\n"+
    "attribute vec4 aNormal;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec2 uScale;\n"+
    "uniform vec4 uParams;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n"+
        "vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n"+
//        "vTexCoord=vec2((abs(aPosition.w)) / (pp0.z/10.0), aPosition.w < 0.0 ? 0.0001 : 0.9999);\n"+
        "if (aNormal.w == 0.0) {\n"+
            "gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n"+
        "} else {\n"+
            "vec2 pp1 = pp0.xy / pp0.w;\n"+
            "vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n"+
            "vec2 pp2 = pp3.xy / pp3.w;\n"+
            "vec2 n = normalize(pp2 - pp1);\n"+
            "gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n"+
        "}\n"+
    "}";

Vadstena.tlineFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "uniform vec4 uColor;\n"+
    "uniform vec4 uColor2;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main() {\n"+
        "vec4 c=texture2D(uSampler, vTexCoord)*uColor;\n"+
//        "if(c.w < 0.01){ discard; }\n"+
        "gl_FragColor = c;\n"+
    "}";

Vadstena.tblineFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "uniform vec4 uColor;\n"+
    "uniform vec4 uColor2;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main() {\n"+
        "vec4 c=texture2D(uSampler, vTexCoord)*uColor;\n"+
        "vec4 c2=uColor2;\n"+
        "c.xyz*=c.w; c2.xyz*=c2.w;\n"+
        "c=mix(c,c2,1.0-c.w);\n"+
        "c.xyz/=(c.w+0.00001);\n"+
        "gl_FragColor = c;\n"+
    "}";

Vadstena.polygonVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec3 aNormal;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform mat4 uRot;\n"+
    "uniform vec4 uColor;\n"+
    "varying vec4 vColor;\n"+
    "void main(){ \n"+
        "float l = dot((uRot*vec4(aNormal,1.0)).xyz, vec3(0.0,0.0,1.0)) * 0.5;\n"+
        "vec3 c = uColor.xyz;\n"+
        "c = (l > 0.0) ? mix(c,vec3(1.0,1.0,1.0),l) : mix(vec3(0.0,0.0,0.0),c,1.0+l);\n"+
        "vColor = vec4(c, uColor.w);\n"+
        "gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
    "}";

Vadstena.polygonFragmentShader = "precision mediump float;\n"+
    "varying vec4 vColor;\n"+
    "void main() {\n"+
        "gl_FragColor = vColor;\n"+
    "}";

Vadstena.textVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec4 aTexCoord;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec4 uVec;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "vTexCoord = aTexCoord.xy;\n"+
        "if (dot(uVec.xy, aTexCoord.zw) < 0.0) {\n"+
            "gl_Position = uMVP * vec4(2.0, 0.0, 0.0, 1.0);\n"+
        "}else{\n"+
            "gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
        "}\n"+
    "}";

Vadstena.textVertexShader2 =
    "attribute vec3 aPosition;\n"+
    "attribute vec4 aTexCoord;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec4 uPosition;\n"+
    "uniform float uDepth;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "vTexCoord = aTexCoord.xy;\n"+
        //"gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
        "gl_Position = uMVP*vec4(aPosition[0]+uPosition[0],-aPosition[1]+uPosition[1],uPosition[2],1.0);\n"+
    "}";

Vadstena.iconVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec4 aTexCoord;\n"+
    "attribute vec3 aOrigin;\n"+
    "uniform mat4 uMVP;\n"+
    "uniform vec4 uScale;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "vTexCoord = aTexCoord.xy * uScale[2];\n"+
        "vec4 pos = (uMVP * vec4(aOrigin, 1.0));\n"+
        //"pos.xy = pos.xy / pos.w;\n"+
        "gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, aPosition.y*uScale.y*pos.w, 0.0, 0.0);\n"+
    "}";

Vadstena.textFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "uniform vec4 uColor;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main() {\n"+
        "vec4 c=texture2D(uSampler, vTexCoord);\n"+
        "if(c.w < 0.01){ discard; }\n"+
        "gl_FragColor = c*uColor;\n"+
    "}";

Vadstena.skydomeVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "uniform mat4 uMVP;\n"+
    "varying vec2 vTexCoord;\n"+
    "void main(){ \n"+
        "gl_Position = uMVP * vec4(aPosition, 1.0);\n"+
        "vTexCoord = aTexCoord;\n"+
    "}";

Vadstena.skydomeFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "varying vec2 vTexCoord;\n"+
    "const vec4 gray = vec4(0.125, 0.125, 0.125, 1.0);\n"+
//    "const vec4 gray = vec4(1.0, 1.0, 1.0, 1.0);\n"+
    "void main() {\n"+
        //"float fade = smoothstep(0.49, 0.52, vTexCoord.t);\n"+
        "float fade = smoothstep(0.51, 0.55, vTexCoord.t);\n"+
        "gl_FragColor = mix(texture2D(uSampler, vTexCoord), gray, fade);\n"+
        //"gl_FragColor = vec4(0.9, 0.9, 0.9, 1.0);\n"+
        //"gl_FragColor = vec4(vTexCoord.x, vTexCoord.y, 0.9, 1.0);\n"+
    "}";

//heightmap tile
Vadstena.heightmapVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "uniform mat4 uGridMat;\n"+
    "uniform float uGridStep1, uGridStep2;\n"+
    "const int HMSize = 5;\n"+
    "const float HMSize1 = float(HMSize-1);\n"+
    "uniform float uHeight[HMSize*HMSize];\n"+
    "varying vec2 vTexCoord1;\n"+
    "varying vec2 vTexCoord2;\n"+
    "varying float vFogFactor;\n"+
    "float round(float x) { return floor(x + 0.5); }\n"+
    "void main() {\n"+
        "vec3 pos = aPosition;\n"+
        "float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n"+
        "vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vFogFactor = exp(uFogDensity * camDist);\n"+
        "vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n"+
        "vTexCoord1 = aTexCoord;\n"+
        "vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n"+
        "vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n"+
    "}";

Vadstena.heightmapFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "uniform float uGridBlend;\n"+
    "varying vec2 vTexCoord1;\n"+
    "varying vec2 vTexCoord2;\n"+
    "varying float vFogFactor;\n"+
//    "const vec4 fogColor = vec4(1, 1, 1, 1);\n"+
    "const vec4 fogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n"+
    "void main() {\n"+
        "vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\n"+
        "gl_FragColor = mix(fogColor, gridColor, vFogFactor);\n"+
    "}";


//depth encoded heightmap tile
Vadstena.heightmapDepthVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "uniform mat4 uGridMat;\n"+
    "uniform float uGridStep1, uGridStep2;\n"+
    "const int HMSize = 5;\n"+
    "const float HMSize1 = float(HMSize-1);\n"+
    "uniform float uHeight[HMSize*HMSize];\n"+
    "varying vec2 vTexCoord1;\n"+
    "varying vec2 vTexCoord2;\n"+
    "varying float vDepth;\n"+
    "float round(float x) { return floor(x + 0.5); }\n"+
    "void main() {\n"+
        "vec3 pos = aPosition;\n"+
        "float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n"+
        "vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vDepth = camDist;\n"+
        "vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n"+
        "vTexCoord1 = aTexCoord;\n"+
        "vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n"+
        "vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n"+
    "}";

Vadstena.heightmapDepthFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "uniform float uGridBlend;\n"+
    "varying vec2 vTexCoord1;\n"+
    "varying vec2 vTexCoord2;\n"+
    "varying float vDepth;\n"+
//    "const vec4 fogColor = vec4(1, 1, 1, 1);\n"+
    "const vec4 fogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n"+
    "void main() {\n"+
        //"vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\n"+
        "gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n"+

        //"gl_FragColor = mix(fogColor, gridColor, vFogFactor);\n"+
    "}";


//textured tile mesh
Vadstena.tileVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying float vFogFactor;\n"+
    "void main() {\n"+
        "vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vFogFactor = exp(uFogDensity * camDist);\n"+
        "vTexCoord = aTexCoord;\n"+
    "}";

Vadstena.tileFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying float vFogFactor;\n"+
//    "const vec4 fogColor = vec4(0.8274, 0.9137, 0.9725, 1.0);\n"+
    "const vec4 fogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n"+
    "void main() {\n"+
        "gl_FragColor = mix(fogColor, texture2D(uSampler, vTexCoord), vFogFactor);\n"+
    "}";


//flat shade tile mesh
Vadstena.tileFlatShadeVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "attribute vec3 aBarycentric;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying vec3 vBarycentric;\n"+
    "varying float vFogFactor;\n"+
    "void main() {\n"+
        "vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vFogFactor = exp(uFogDensity * camDist);\n"+
        "vTexCoord = aTexCoord;\n"+
        "vBarycentric = camSpacePos.xyz;\n"+
    "}";

Vadstena.tileFlatShadeFragmentShader = "precision mediump float;\n"+
    "#extension GL_OES_standard_derivatives : enable\n"+
    "uniform sampler2D uSampler;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying vec3 vBarycentric;\n"+
    "varying float vFogFactor;\n"+
    "void main() {\n"+
        "#ifdef GL_OES_standard_derivatives\n"+
            "vec3 nx = dFdx(vBarycentric);\n"+
            "vec3 ny = dFdy(vBarycentric);\n"+
            "vec3 normal=normalize(cross(nx,ny));\n"+
            "gl_FragColor = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\n"+
        "#else\n"+
            "gl_FragColor = vec4(1.0,1.0,1.0,1.0);\n"+
        "#endif\n"+
    "}";

//textured wire frame tile mesh
Vadstena.tileWireframeVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "attribute vec3 aBarycentric;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying vec3 vBarycentric;\n"+
    "varying float vFogFactor;\n"+
    "void main() {\n"+
        "vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vFogFactor = exp(uFogDensity * camDist);\n"+
        "vTexCoord = aTexCoord;\n"+
        "vBarycentric = aBarycentric;\n"+
    "}";

Vadstena.tileWireframeFragmentShader = "precision mediump float;\n"+
    "#extension GL_OES_standard_derivatives : enable\n"+
    "uniform sampler2D uSampler;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying vec3 vBarycentric;\n"+
    "varying float vFogFactor;\n"+
//    "const vec4 fogColor = vec4(1, 1, 1, 1);\n"+
    "const vec4 fogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n"+
    "float edgeFactor(){\n"+
        "#ifdef GL_OES_standard_derivatives\n"+
            "vec3 d = fwidth(vBarycentric);\n"+
            "vec3 a3 = smoothstep(vec3(0.0), d*1.0, vBarycentric);\n"+
            "return min(min(a3.x, a3.y), a3.z);\n"+
        "#else\n"+
            "float a = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);\n"+
            "return a > 0.1 ? 1.0 : smoothstep(0.0,1.0,a*10.0);\n"+
        "#endif\n"+
    "}\n"+
    "void main() {\n"+
        //"gl_FragColor = vec4( mix(vec3(0.0), vec3(0.5), edgeFactor()) , 1.0);\n"+
        "gl_FragColor = mix(fogColor, vec4( mix(vec3(0.0), texture2D(uSampler, vTexCoord).rgb, edgeFactor()) , 1.0), vFogFactor);\n"+
        //"gl_FragColor = mix(fogColor, texture2D(uSampler, vTexCoord), vFogFactor);\n"+
    "}";

Vadstena.tileWireframe2FragmentShader = "precision mediump float;\n"+
    "#extension GL_OES_standard_derivatives : enable\n"+
    "uniform sampler2D uSampler;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying vec3 vBarycentric;\n"+
    "varying float vFogFactor;\n"+
//    "const vec4 fogColor = vec4(1, 1, 1, 1);\n"+
    "const vec4 fogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n"+
    "float edgeFactor(){\n"+
        "#ifdef GL_OES_standard_derivatives\n"+
            "vec3 d = fwidth(vBarycentric);\n"+
            "vec3 a3 = smoothstep(vec3(0.0), d*1.0, vBarycentric);\n"+
            "return min(min(a3.x, a3.y), a3.z);\n"+
        "#else\n"+
            "float a = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);\n"+
            "return a > 0.1 ? 1.0 : smoothstep(0.0,1.0,a*10.0);\n"+
        "#endif\n"+
    "}\n"+
    "void main() {\n"+
        "gl_FragColor = vec4( mix(vec3(0.0), vec3(0.5), edgeFactor()) , 1.0);\n"+
    "}";


//depth encoded tile mesh
Vadstena.tileDepthVertexShader =
    "attribute vec3 aPosition;\n"+
    "attribute vec2 aTexCoord;\n"+
    "uniform mat4 uMV, uProj;\n"+
    "uniform float uFogDensity;\n"+
    "varying vec2 vTexCoord;\n"+
    "varying float vDepth;\n"+
    "void main() {\n"+
        "vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n"+
        "gl_Position = uProj * camSpacePos;\n"+
        "float camDist = length(camSpacePos.xyz);\n"+
        "vDepth = camDist;\n"+
        "vTexCoord = aTexCoord;\n"+
    "}";

Vadstena.tileDepthFragmentShader = "precision mediump float;\n"+
    "uniform sampler2D uSampler;\n"+
    "varying float vDepth;\n"+
    "void main() {\n"+

//        "gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n"+
        "gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n"+
        //"gl_FragColor.w=1.0;"+
//        "gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth);\n"+

    "}";

//used for 2d iamges
Vadstena.imageVertexShader = "\n"+
    "attribute vec4 aPosition;\n"+
    "uniform mat4 uProjectionMatrix;\n"+
    "uniform mat4 uData;\n"+
    "uniform vec4 uColor;\n"+
    "uniform float uDepth;\n"+
    "varying vec4 vColor;\n"+
    "varying vec2 vTexcoords;\n"+
    "void main(void){\n"+
        "int i=int(aPosition.x);\n"+
        //"gl_Position=uProjectionMatrix*vec4(floor(uData[i][0]+0.1),floor(uData[i][1]+0.1),0.0,1.0);\n"+
        //IE11 :(

        "if(i==0) gl_Position=uProjectionMatrix*vec4(floor(uData[0][0]+0.1),floor(uData[0][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[0][2], uData[0][3]);\n"+
        "if(i==1) gl_Position=uProjectionMatrix*vec4(floor(uData[1][0]+0.1),floor(uData[1][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[1][2], uData[1][3]);\n"+
        "if(i==2) gl_Position=uProjectionMatrix*vec4(floor(uData[2][0]+0.1),floor(uData[2][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[2][2], uData[2][3]);\n"+
        "if(i==3) gl_Position=uProjectionMatrix*vec4(floor(uData[3][0]+0.1),floor(uData[3][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[3][2], uData[3][3]);\n"+

        "vec4 c=uColor*(1.0/255.0);\n"+
        "c.w*=1.0;\n"+
        "vColor=c;\n"+
    "}";

Vadstena.imageFragmentShader = "precision mediump float;\n"+
    "varying vec4 vColor;\n"+
    "varying vec2 vTexcoords;\n"+
    "uniform sampler2D uSampler;\n"+
    "void main(void){\n"+
        "vec4 c=texture2D(uSampler, vec2(vTexcoords.x, vTexcoords.y) );\n"+
        "c*=vColor;\n"+
//        "gl_FragColor = vec4(1.0,0.0,1.0,1.0);\n"+
        "if(c.w < 0.01){ discard; }\n"+
        "gl_FragColor = c;\n"+
//        "gl_FragColor = vec4(vTexcoords.x, vTexcoords.y, 0.0, 1.0);\n"+
    "}";








if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//! Holds a texture in GPU memory.
/**
 * @constructor
 */
Vadstena.GpuTexture = function(gpu_, path_, browser_, fileSize_, direct_, repeat_, filter_)
{
    this.gpu_ = gpu_;
    this.gl_ = gpu_.gl_;
    this.texture_ = null;
    this.framebuffer_ = null;
    this.size_ = 0;
    this.fileSize_ = fileSize_; //used for stats
    this.width_ = 0;
    this.height_ = 0;
    this.repeat_ = repeat_ || false;
    this.filter_ = filter_ || "linear";

    this.image_ = null;
    this.loaded_ = false;
    this.trilinear_ = false;//true;
    this.browser_ = browser_;

    if (path_ != null) {
        this.load(path_, null, null, direct_);
    }
};

//destructor
Vadstena.GpuTexture.prototype.kill = function()
{
    this.gl_.deleteTexture(this.texture_);

    if (this.browser_ != null && this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsFluxTexture_[1][0] ++;
        this.browser_.renderer_.statsFluxTexture_[1][1] += this.size_;
    }
};

//! Returns GPU RAM used, in bytes.
Vadstena.GpuTexture.prototype.size = function(){ return this.size_; };


Vadstena.GpuTexture.prototype.createFromData = function(lx_, ly_, data_, filter_, repeat_)
{
    var gl_ = this.gl_;

    this.texture_ = gl_.createTexture();
    gl_.bindTexture(gl_.TEXTURE_2D, this.texture_);

    if (repeat_ == true){
        repeat_ = gl_.REPEAT;
        this.repeat_ = true;
    } else {
        repeat_ = gl_.CLAMP_TO_EDGE;
    }

    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_S, repeat_);
    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_T, repeat_);
    var mipmaps_ = false;

    switch (filter_)
    {
    case "linear":
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.LINEAR);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.LINEAR);
        break;
    case "trilinear":
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.LINEAR_MIPMAP_LINEAR);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.LINEAR);
        mipmaps_ = true;
        break;
    default:
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.NEAREST);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.NEAREST);
        break;
    }

    gl_.pixelStorei(gl_.UNPACK_ALIGNMENT, 1);
    //gl_.pixelStorei(gl_.UNPACK_FLIP_Y_WEBGL, true);

    gl_.texImage2D(gl_.TEXTURE_2D, 0, gl_.RGBA, lx_, ly_, 0, gl_.RGBA, gl_.UNSIGNED_BYTE, data_);

    if (mipmaps_ == true) {
        gl_.generateMipmap(gl_.TEXTURE_2D);
    }

    gl_.bindTexture(gl_.TEXTURE_2D, null);

    this.width_ = lx_;
    this.height_ = ly_;
    this.size_ = lx_ * ly_ * 4;
    this.loaded_ = true;
};

Vadstena.GpuTexture.prototype.createFromImage = function(image_, filter_, repeat_)
{
    var gl_ = this.gl_;

    var timer_ = performance.now();

    this.texture_ = gl_.createTexture();
    gl_.bindTexture(gl_.TEXTURE_2D, this.texture_);

    if (repeat_ == true) {
        repeat_ = gl_.REPEAT;
        this.repeat_ = true;
    } else {
        repeat_ = gl_.CLAMP_TO_EDGE;
    }

    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_S, repeat_);
    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_T, repeat_);
    var mipmaps_ = false;
    this.filter_ = filter_;

    switch (filter_)
    {
    case "linear":
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.LINEAR);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.LINEAR);
        break;
    case "trilinear":
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.LINEAR_MIPMAP_LINEAR);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.LINEAR);
        mipmaps_ = true;
        break;
    default:
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.NEAREST);
        gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.NEAREST);
        break;
    }

    //gl_.pixelStorei(gl_.UNPACK_ALIGNMENT, 1);
    //gl_.pixelStorei(gl_.UNPACK_FLIP_Y_WEBGL, true);

    if (Vadstena.noTextures_ != true) {
        gl_.texImage2D(gl_.TEXTURE_2D, 0, gl_.RGBA, gl_.RGBA, gl_.UNSIGNED_BYTE, image_);

        if (mipmaps_ == true) {
            gl_.generateMipmap(gl_.TEXTURE_2D);
        }
    }

    gl_.bindTexture(gl_.TEXTURE_2D, null);

    this.width_ = image_.naturalWidth;
    this.height_ = image_.naturalHeight;
    this.size_ = image_.naturalWidth * image_.naturalHeight * 4;
    this.loaded_ = true;

    if (this.browser_ != null && this.browser_.renderer_!= null) {
        this.browser_.renderer_.dirty_ = true;
        this.browser_.renderer_.statsCreateTextureTime_ += performance.now() - timer_;
        this.browser_.renderer_.statsFluxTexture_[0][0] ++;
        this.browser_.renderer_.statsFluxTexture_[0][1] += this.size_;
    }
};

Vadstena.GpuTexture.prototype.load = function(path_, onLoaded_, onError_, direct_)
{
    this.image_ = new Image();

    if (direct_ != true) { //this is for firefox compatibility
        this.image_.crossOrigin = "anonymous";
    }

    this.image_.onload = (function () {

        if (this.browser_ != null && this.browser_.killed_ == true) {
            return;
        }

        this.createFromImage(this.image_, this.filter_, this.repeat_);
        this.image_ = null;

    }).bind(this);

    this.image_.onerror = (function () {

        if (this.browser_ != null && this.browser_.killed_ == true) {
            return;
        }

        if (onError_ != null) {
            onError_();
        }

    }).bind(this);

    this.image_.src = path_;
};

Vadstena.GpuTexture.prototype.createFramebufferFromData = function(lx_, ly_, data_)
{
    var gl_ = this.gl_;

    var framebuffer_ = gl_.createFramebuffer();
    gl_.bindFramebuffer(gl_.FRAMEBUFFER, framebuffer_);
    framebuffer_.width = lx_;
    framebuffer_.height = ly_;

    var texture_ = gl_.createTexture();
    gl_.bindTexture(gl_.TEXTURE_2D, texture_);
    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_S, gl_.CLAMP_TO_EDGE);
    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_WRAP_T, gl_.CLAMP_TO_EDGE);

    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MIN_FILTER, gl_.NEAREST);
    gl_.texParameteri(gl_.TEXTURE_2D, gl_.TEXTURE_MAG_FILTER, gl_.NEAREST);

    gl_.pixelStorei(gl_.UNPACK_ALIGNMENT, 1);

    gl_.texImage2D(gl_.TEXTURE_2D, 0, gl_.RGBA, lx_, ly_, 0, gl_.RGBA, gl_.UNSIGNED_BYTE, data_);



    var renderbuffer_ = gl_.createRenderbuffer();
    gl_.bindRenderbuffer(gl_.RENDERBUFFER, renderbuffer_);
    gl_.renderbufferStorage(gl_.RENDERBUFFER, gl_.DEPTH_COMPONENT16, lx_, ly_);

    //gl_.framebufferTexture2D(gl_.FRAMEBUFFER, gl_.COLOR_ATTACHMENT0, gl_.TEXTURE_2D, this.texture_.texture_, 0);
    gl_.framebufferTexture2D(gl_.FRAMEBUFFER, gl_.COLOR_ATTACHMENT0, gl_.TEXTURE_2D, texture_, 0);

    gl_.framebufferRenderbuffer(gl_.FRAMEBUFFER, gl_.DEPTH_ATTACHMENT, gl_.RENDERBUFFER, renderbuffer_);

    this.width_ = lx_;
    this.height_ = ly_;
    this.size_ = lx_ * ly_ * 4;

    this.texture_ = texture_;
    this.renderbuffer_ = renderbuffer_;
    this.framebuffer_ = framebuffer_;

    //gl_.generateMipmap(gl_.TEXTURE_2D);
/*
    gl_.clearColor(0.0, 1.0, 0.0, 1.0);
    //gl_.enable(gl_.DEPTH_TEST);

    //clear screen
    gl_.viewport(0, 0, lx_, ly_);
    gl_.clear(gl_.COLOR_BUFFER_BIT);// | gl_.DEPTH_BUFFER_BIT);
*/
    gl_.bindTexture(gl_.TEXTURE_2D, null);
    gl_.bindRenderbuffer(gl_.RENDERBUFFER, null);
    gl_.bindFramebuffer(gl_.FRAMEBUFFER, null);
};

Vadstena.GpuTexture.prototype.createFramebuffer = function(lx_, ly_)
{
    if (this.texture_ == null){
        return;
    }

    var gl_ = this.gl_;

    var framebuffer_ = gl_.createFramebuffer();
    gl_.bindFramebuffer(gl_.FRAMEBUFFER, framebuffer_);
    framebuffer_.width = lx_;
    framebuffer_.height = ly_;

    gl_.bindTexture(gl_.TEXTURE_2D, this.texture_);

    var renderbuffer_ = gl_.createRenderbuffer();
    gl_.bindRenderbuffer(gl_.RENDERBUFFER, renderbuffer_);
    gl_.renderbufferStorage(gl_.RENDERBUFFER, gl_.DEPTH_COMPONENT16, lx_, ly_);

    gl_.framebufferTexture2D(gl_.FRAMEBUFFER, gl_.COLOR_ATTACHMENT0, gl_.TEXTURE_2D, this.texture_, 0);
    gl_.framebufferRenderbuffer(gl_.FRAMEBUFFER, gl_.DEPTH_ATTACHMENT, gl_.RENDERBUFFER, renderbuffer_);

/*
    gl_.clearColor(0.0, 1.0, 0.0, 1.0);
    //gl_.enable(gl_.DEPTH_TEST);

    //clear screen
    gl_.viewport(0, 0, lx_, ly_);
//    gl_.clear(gl_.COLOR_BUFFER_BIT | gl_.DEPTH_BUFFER_BIT);
    gl_.clear(gl_.COLOR_BUFFER_BIT);
*/

    gl_.bindTexture(gl_.TEXTURE_2D, null);
    gl_.bindRenderbuffer(gl_.RENDERBUFFER, null);
    gl_.bindFramebuffer(gl_.FRAMEBUFFER, null);

    this.framebuffer_ = framebuffer_;
    this.renderbuffer_ = renderbuffer_;

};


Vadstena.GpuTexture.prototype.readFramebufferPixels = function(x_, y_, lx_, ly_)
{
    if (this.texture_ == null) {
        return;
    }

    this.gpu_.bindTexture(this);
    this.gpu_.setFramebuffer(this);

    var gl_ = this.gl_;

    // Read the contents of the framebuffer (data stores the pixel data)
    var data_ = new Uint8Array(lx_ * ly_ * 4);
    gl_.readPixels(x_, y_, lx_, ly_, gl_.RGBA, gl_.UNSIGNED_BYTE, data_);

    this.gpu_.setFramebuffer(null);

    return data_;
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//! Holds the GPU data for a tile.
/**
 * @constructor
 */
Vadstena.GpuTile = function(gpu_, browser_, tile_)
{
    this.gpu_ = gpu_;
    this.type_ = tile_.type_;
    this.ready_ = false;

    switch(this.type_){
        case "terrain":
            this.mesh_ = new Vadstena.GpuMesh(gpu_, tile_.mesh_, null, browser_);
            this.texture_ = new Vadstena.GpuTexture(gpu_, null, browser_);
            this.texture_.createFromImage(tile_.image_, "linear");
            this.meshFileSize_ = tile_.meshFileSize_;
            this.imageFileSize_ = tile_.imageFileSize_;
            this.ready_ = true;
            break;

        case "geodata":

            this.geodata_ = new Vadstena.GpuGeodata(gpu_, tile_, tile_.layer_);
            this.geodataFileSize_ += tile_.size();
            //this.ready_ = true;
            break;
    }

};

Vadstena.GpuTile.prototype.kill = function() {

    switch(this.type_){
        case "terrain":
            this.mesh_.kill();
            this.texture_.kill();
            break;

        case "geodata":
            this.geodata_.kill();
            break;
    }
};

Vadstena.GpuTile.prototype.isReady = function() {

    if (this.ready_ == false) {
        switch(this.type_){
            case "geodata":
                this.ready_ = this.geodata_.isReady();
                break;
        }
    }

    return this.ready_;
};

Vadstena.GpuTile.prototype.draw = function(mv_, mvp_, applyOrigin_) {

    if (this.ready_ == true) {
        switch(this.type_){
            case "geodata":
                this.geodata_.draw(mv_, mvp_, applyOrigin_);
                break;
        }
    }

    return this.ready_;
};

Vadstena.GpuTile.prototype.size = function() {

    switch(this.type_){
        case "terrain": return this.mesh_.size() + this.texture_.size();
        case "geodata": this.geodata_.size();
    }

};


//! Manages GPU memory -- uploads/releases GpuTiles
/**
 * @constructor
 */
Vadstena.GpuCache = function(gpu_, browser_, size_)
{
    //QCache<TileId, GpuTile> cache; cache(size)
    //this.cache_ = [];
    this.gpu_ = gpu_;
    this.browser_ = browser_;
    this.cache_ = new Vadstena.QCache(size_);
};

Vadstena.GpuCache.prototype.get = function(id_, tile_)
{
    if (tile_ == null){
        id_ = id_;
    }

    if (tile_.layer_ != null) {
        id_.layerId_ = tile_.layer_.innerId_;
    }

    if (tile_.type_ == "geodata") {
        tile_ = tile_;
        //return null;
    }

    var gpuTile_ = this.cache_.find(id_);
    if (gpuTile_) return gpuTile_;

    var gpuTile_ = new Vadstena.GpuTile(this.gpu_, this.browser_, tile_); // upload the tile to GPU RAM
    this.cache_.insert(id_, gpuTile_, gpuTile_.size());

    return gpuTile_;
};

Vadstena.GpuCache.prototype.size = function()
{
    return this.cache_.totalCost_;
};

Vadstena.GpuCache.prototype.reset = function()
{
    return this.cache_.clear();
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.Layer = function(planet_, id_, type_, sourceGeodata_, minLod_, maxLod_, tilePixels_, generateLods_, style_, tags_, visible_)
{
    this.planet_ = planet_;
    this.type_ = "geolayer";
    this.gpu_ = planet_.gpu_;
    this.browser_ = planet_.browser_;
    this.renderer_ = planet_.renderer_;
    this.camera_ = this.renderer_.camera_;
    this.innerId_ = planet_.layerCounter_;
    this.id_ = id_;
    this.type_ = type_;
    this.sourceGeodata_ = sourceGeodata_;
    this.tags_ = tags_;
    this.visible_ = (visible_ != null) ? visible_ : true;
    this.style_ = style_;
    this.tilePixels_ = tilePixels_ || 256;
    this.maxTileLod_ = maxLod_ || 20;
    this.minTileLod_ = minLod_ || 2;
    this.generateLods_ = generateLods_ || false;
    this.autoLods_ = !this.generateLods_;
    this.currentLod_ = 0;
    this.processedLod_ = 0;
    this.ready_ = false;

    //reduce garbage collection
    this.drawTileMatrix_ = Vadstena.mat4.create();
    this.drawTileMatrix2_ = Vadstena.mat4.create();
    this.drawTileVec_ = [0,0,0];
    this.drawTileWorldMatrix_ = Vadstena.mat4.create();
    this.pixelTileSizeMatrix_ = Vadstena.mat4.create();
    this.recurseToChildrenVec_ = [0,0,0];
    this.recurseToChildrenOrdering_ = [
        [ 3, 1, 2, 0 ], [ 3, 2, 1, 0 ],
        [ 2, 3, 0, 1 ], [ 2, 0, 3, 1 ],
        [ 0, 2, 1, 3 ], [ 0, 1, 2, 3 ],
        [ 1, 0, 3, 2 ], [ 1, 3, 0, 2 ]
    ];

    this.geodata_ = null;
    this.geodataList_ = [];

    if (this.renderer_.font_ == null) {
        this.renderer_.font_ = new Vadstena.GpuFont(this.gpu_, this.browser_);
    }

    if (this.generateLods_ == true) {
        //this.geodataList_[this.minTileLod_] = this.generateLod(this.minTileLod_);
        //this.geodataList_[this.minTileLod_].isReady(this.minTileLod_);
        this.ready_ = true;
        this.isReady(this.minTileLod_);
    } else {
        this.geodata_ = this.generateLod(11);
        this.geodata_.isReady();
    }

};

//destructor
Vadstena.Layer.prototype.kill = function() {
    this.geodataProcessor_.kill();

    if (this.generateLods_ == true) {
        for (var i = this.minTileLod_; i <= this.maxTileLod_; i++) {
            if (this.geodataList_[i] != null) {
                this.geodataList_[i].kill();
            }
        }
    } else {
        this.geodata_.kill();
    }
};

Vadstena.Layer.prototype.getId = function() {
    return this.id_;
};

Vadstena.Layer.prototype.isVisible = function() {
    return this.visible_;
};

Vadstena.Layer.prototype.setVisible = function(state_) {
    if (this.visible_ != state_) {
        this.visible_ = state_;
        this.renderer_.dirty_ = true;
    }
};

Vadstena.Layer.prototype.generateLod = function(lod_) {
    this.geodataProcessor_ = new Vadstena.geodataProcessor(this, this.onGeodataProcessorMessage.bind(this));
    this.geodataProcessor_.sendCommand("setStyles", this.style_);
    this.geodataProcessor_.sendCommand("setFont", {"chars" : this.renderer_.font_.chars_, "space" : this.renderer_.font_.space_, "size" : this.renderer_.font_.size_});

    var falseTile_ = {};
    falseTile_.browser_ = this.browser_;
    falseTile_.id_ = new Vadstena.TileId(this.browser_, lod_, 0, 0, this.id_);
    falseTile_.type_ = "geodata";
    falseTile_.geodata_ = this.sourceGeodata_;
    falseTile_.layer_ = this;//{};

    return new Vadstena.GpuGeodata(this.gpu_, falseTile_);
};

Vadstena.Layer.prototype.isReady = function(lod_) {

    if (this.generateLods_ == true) {

        if (lod_ < this.minTileLod_ || lod_ > this.maxTileLod_) {
            return false;
        }

        if (this.ready_ == true) { //is geodata processor free?
            switch(this.type_){
                case "geodata":

                    if (this.geodataList_[lod_] == null) { //do we need start new geodata processor?
                        this.geodataList_[lod_] = this.generateLod(lod_); //start new one
                        this.processedLod_ = lod_;
                        this.ready_ = this.geodataList_[lod_].isReady();
                    }

                    break;
            }
        } else {
            this.ready_ = this.geodataList_[this.processedLod_].isReady(); //is current gedata processor finished

            if (this.ready_ == true) { //kill geodata processor if not needed
                this.geodataProcessor_.kill();
            }
        }

        //check if geodata are ready
        switch(this.type_){
            case "geodata":

                if (this.geodataList_[lod_] != null) {
                    return this.geodataList_[lod_].isReady();
                } else{
                    return false;
                }

                break;
        }

    } else {

        if (this.ready_ == false) {
            switch(this.type_){
                case "geodata":
                    this.ready_ = this.geodata_.isReady();

                    if (this.ready_ == true) {
                        this.geodataProcessor_.kill();
                    }

                    break;
            }
        }
    }

    return this.ready_;
};

Vadstena.Layer.prototype.setGeodataProcessorListener = function(listener_) {
};

Vadstena.Layer.prototype.onGeodataProcessorMessage = function(message_) {

    switch(message_["command"]) {
        case "loadBitmaps":
            var bitmaps_ = message_["bitmaps"];
            if (bitmaps_ != null) {
                for (var key_ in bitmaps_) {
                    this.renderer_.getBitmap(bitmaps_[key_]["url"], bitmaps_[key_]["filter"] || "linear", bitmaps_[key_]["tiled"] || false);
                }
            }
            break;

        case "allProcessed":
            this.geodataProcessor_.kill();
            break;
    }

};


Vadstena.Layer.prototype.draw = function() {

    if (this.visible_ == false) {
        return;
    }

    if (this.generateLods_ == true) {
        this.updateCurrentLod();
    }

    if (this.isReady(this.currentLod_) == false) {
        return;
    }

    var mvp_ = this.camera_.getProjectionMatrix();
    var mv_ = this.camera_.getModelviewMatrix();

    if (this.generateLods_ == true) {
        this.geodataList_[this.currentLod_].draw(mv_, mvp_, true);
    } else {
        this.geodata_.draw(mv_, mvp_, true);
    }
};

Vadstena.Layer.prototype.updateCurrentLod = function() {

    var renderer_ = this.renderer_;

    //get lod for non-tiled geolayers
    var ndcToScreenPixel_ = (renderer_.curSize_[0] / 2.0);

    for (var i = 0; i < 30; i++) {
        this.currentLod_ = i;

        var tileSize_ = this.browser_.mapConfig_.tileSize(i);
        var tilePixelSize_ = tileSize_ / 256;
        var factor_ = this.camera_.projection_[0] / renderer_.position_[2];

        var pixelSize_ = factor_ * tilePixelSize_ * ndcToScreenPixel_;

        if (pixelSize_ <= 1.1) {
            break;
        }
    }

    //console.log("LOD: " + this.currentLod_);

};

Vadstena.Layer.prototype.update = function() {

    this.isReady(this.currentLod_);
};
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.LayerOld = function(planet_, id_, lod_, group_, visible_)
{
    this.planet_ = planet_;
    this.gpu_ = planet_.gpu_;
    this.browser_ = planet_.browser_;
    this.renderer_ = planet_.renderer_;
    this.innerId_ = planet_.layerCounter_;
    this.primitives_ = [];
    this.bbox_ = null;
    this.origin_ = null;
    this.optimize_ = false;
    this.gpuStencilLines_ = null;
    this.gpuPathTexts_ = null;
    this.id_ = id_;
    this.lod_ = lod_;
    this.group_ = group_;
    this.visible_ = (visible_ != null) ? visible_ : true;

    if (this.renderer_.font_ == null) {
        this.renderer_.font_ = new Vadstena.GpuFont(this.gpu_, this.browser_);
    }

    if (this.renderer_.placemarkTexture_ == null) {
        var placemark_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAKTSURBVHjavNfPS1RBAAfwL6nbocMebDe79UMFQyG3Tit2EjatLhZkmluYGwZlJoJZUuy2BUGuSCAWFkgnCRIrfxyk3ZMtHpT+gbq8UgLrtGD43ny7vKnJLH2zu29gLnv4fj/zdnbeLEjCyQRwBsAUgI8AvtvzE4BZAM2O8xwUhwG8B0A5PUVF3OnxUP0MwCKASE4BAO7IAr/Px7v9/UzPz/OzYfCLYXAhnea9aJQlJSUq5EFOAACuytCL4TB/rK1RCMGNQwhBc32dlyMRFdGTFQDAPhl2vbOTlmVxq2FZFvt6e1VEVTaAhwB4rLZ2W+Uq4ngopCIKHQMAnJQBszMzdDpSyaQKaNIBJACwrLSUuqOqslICnugAJgGwualp00231RBC8FJbmwS80QHMAOCVjg5twI2uLgmY1gG8BsDzLS3agEh7uwS81QE8BsBDFRXaeyBQXS0Bz3QAZ+UuTiWTjssX0mn1VxDWARTKgBP1DY7OAdM0ebqxUQXs0j2IqmRIPBbbFsI0TQ4mEmp5MNt3wS0Z9nRk5L8Iy7L4YmxMLY/m6m34SIa+m5v7J2BpcYkFOwpk+VCu7wPDAFheVsZMJrPp6mtramT5cD4uJLvtywbvx+N/nQ3PR0fVR1+ec4CNiADgHr+f31ZX/9h4RwIBWd6XlyuZglgAwMTAwC/A9NSUuvrifAOuAWBNMEjLsiiE4IXWVsfffTaA/XK1K8vLJMm9v++CDXkH2IgUAE5OTPDryor6+D1uAaIAODQ4yJfj47L8lVaWJuAcAPZ0dzMei0nATTcBRwEwVFfHU/X1EtDoJuAAABZ7vSz2eiXgsJsA/4a/YwRw0E2AZxOAzzWAjfiglBvaOVkAOmyEAeC2bs7PAQBlCgrhBHN4PQAAAABJRU5ErkJggg==";
        this.renderer_.placemarkTexture_ = new Vadstena.GpuTexture(this.gpu_, placemark_, this.browser_, null, true);
    }
};

//destructor
Vadstena.LayerOld.prototype.kill = function() {

};

Vadstena.LayerOld.prototype.getId = function() {
    return this.id_;
};

Vadstena.LayerOld.prototype.getLod = function() {
    return this.lod_;
};

Vadstena.LayerOld.prototype.isVisible = function() {
    return this.visible_;
};

Vadstena.LayerOld.prototype.setVisible = function(state_) {
    this.visible_ = state_;
};


Vadstena.LayerOld.prototype.add = function(id_, primitive_, data_) {

    this.primitives_.push({ id_ : id_, type_ : primitive_, data_ : data_ });

};

Vadstena.LayerOld.prototype.remove = function(id_) {
};

Vadstena.LayerOld.prototype.compile = function() {


    for (var i = 0, li = this.primitives_.length; i < li; i++) {

        var primitive_ = this.primitives_[i];
        var pdata_ = primitive_.data_;

        switch (primitive_.type_) {
            case "bbox":

                var bbox_ = pdata_.bbox_;
                var min_ = bbox_[0];
                var max_ = bbox_[1];

                this.bbox_ = new Vadstena.BBox(min_[0], min_[1], min_[2], max_[0], max_[1], max_[2]);
                break;

            case "origin":
                this.origin_ = pdata_.origin_;
                break;

            case "optimize":
                this.optimize_ = pdata_.optimize_;

                this.gpuStencilLines_ = null;
                this.gpuPathTexts_ = null;

                break;
        }

        //center points
        switch (primitive_.type_) {
            case "stencil-line":
            case "pixel-line":
            case "pixel-line2":
            case "pixel-wall":
            case "polygon-wall":
            case "path-text":

                if (this.origin_ == null) {
                    var points_ = pdata_.points_;

                    var center_ = [0,0,0];
                    var totalPoints_ = points_.length;

                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        var p = points_[j];
                        center_[0] += p[0];
                        center_[1] += p[1];
                        center_[2] += p[2];
                    }

                    if (primitive_.type_ == "pixel-wall" || primitive_.type_ == "polygon-wall") {
                        var points2_ = pdata_.points2_;
                        totalPoints_ += points2_.length;

                        for (var j = 0, lj = points2_.length; j < lj; j++) {
                            var p = points2_[j];
                            center_[0] += p[0];
                            center_[1] += p[1];
                            center_[2] += p[2];
                        }
                    }

                    center_[0] /= totalPoints_;
                    center_[1] /= totalPoints_;
                    center_[2] /= totalPoints_;

                    pdata_.center_ = center_;
                } else {
                    pdata_.center_ = this.origin_;
                }

                break;
        }

        switch (primitive_.type_) {
            case "stencil-line":
            case "pixel-line":
            case "pixel-line2":

                var points_ = pdata_.points_;
                var size_ = pdata_.size_;
                var center_ = pdata_.center_;

                if (points_ == null || size_ == null) {
                    break;
                }

                var lines_ = null;

                if (primitive_.type_ == "stencil-line") {
                    if (this.optimize_ == true) {
                        if (this.gpuStencilLines_ == null) {
                            this.gpuStencilLines_ = new Vadstena.GpuLine(this.gpu_, this.browser_);
                        }
                        lines_ = this.gpuStencilLines_;
                    } else {
                        lines_ = new Vadstena.GpuLine(this.gpu_, this.browser_);
                    }
                } else {
                    lines_ = new Vadstena.GpuPixelLine(this.gpu_, this.browser_);
                }

                if (primitive_.type_ == "stencil-line" || size_ > 2.0) {

                    if (this.origin_ == null) {
                        for (var j = 0, lj = points_.length; j < lj; j++) {
                            var p = points_[j];
                            lines_.addCircle([p[0]-center_[0], p[1]-center_[1], p[2]-center_[2]], size_, 8);
                        }
                    } else {
                        for (var j = 0, lj = points_.length; j < lj; j++) {
                            lines_.addCircle(points_[j], size_, 8);
                        }
                    }
                }

                var step_ = (primitive_.type_ != "pixel-line2") ? 1 : 2;

                if (this.origin_ == null) {
                    for (var j = 0, lj = points_.length - 1; j < lj; j+=step_) {
                        var p = points_[j];
                        var p2 = points_[j+1];
                        lines_.addLine([p[0]-center_[0], p[1]-center_[1], p[2]-center_[2]],
                                       [p2[0]-center_[0], p2[1]-center_[1], p2[2]-center_[2]], size_);
                    }
                } else {
                    for (var j = 0, lj = points_.length - 1; j < lj; j+=step_) {
                        lines_.addLine(points_[j], points_[j+1], size_);
                    }
                }

                if (this.optimize_ != true || primitive_.type_ != "stencil-line") {
                    lines_.compile();
                }

                if (primitive_.type_ == "stencil-line") {
                    pdata_.gpuLine_ = lines_;
                } else {
                    pdata_.gpuLine3_ = lines_;
                }
                break;

            case "pixel-wall":

                var points_ = pdata_.points_;
                var points2_ = pdata_.points2_;
                var center_ = pdata_.center_;
                var size_ = pdata_.size_;

                if (points_ == null || points2_ == null || size_ == null) {
                    break;
                }

                var lines_ = new Vadstena.GpuPixelLine(this.gpu_, this.browser_);

                if (this.origin_ == null) {
                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        var p = points_[j];
                        var p2 = points2_[j];
                        lines_.addLine( [p[0]-center_[0], p[1]-center_[1], p[2]-center_[2]],
                                        [p2[0]-center_[0], p2[1]-center_[1], p2[2]-center_[2]], size_ );
                    }
                } else {
                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        lines_.addLine(points_[j], points2_[j], size_ );
                    }
                }

                lines_.compile();
                pdata_.gpuLine3_ = lines_;
                pdata_.center_ = center_;
                break;

            case "polygon-wall":

                var points_ = pdata_.points_;
                var points2_ = pdata_.points2_;
                var center_ = pdata_.center_;

                if (points_ == null || points2_ == null) {
                    break;
                }

                var polygons_ = new Vadstena.GpuPolygon(this.gpu_, this.browser_);

                if (this.origin_ == null) {
                    var newPoints_ = [];
                    var newPoints2_ = [];

                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        var p = points_[j];
                        var p2 = points2_[j];
                        newPoints_[j] = [p[0]-center_[0], p[1]-center_[1], p[2]-center_[2]];
                        newPoints2_[j] = [p2[0]-center_[0], p2[1]-center_[1], p2[2]-center_[2]];
                    }

                    //polygons_.addWall(points_, points2_);
                    polygons_.addWall(newPoints_, newPoints2_);

                } else {
                    polygons_.addWall(points_, points2_);
                }


                polygons_.compile();
                pdata_.gpuPolygon_ = polygons_;
                pdata_.center_ = center_;
                break;

            //case "flat-place":
            case "flat-image":
                //var imageData_ = (primitive_.type_ == "flat-image") ? pdata_ : pdata_.image_;
                var icon_ = pdata_.icon_;
                if (this.renderer_.layerIcons_[icon_] == null) {
                    this.renderer_.layerIcons_[icon_] = new Vadstena.GpuTexture(this.gpu_, icon_);
                }

                if (this.origin_ != null) {
                    var p = pdata_.point_;
                    pdata_.point_ = [p[0] + this.origin_[0], p[1] + this.origin_[1], p[2] + this.origin_[2]];
                }

                pdata_.texture_ = this.renderer_.layerIcons_[icon_];
                break;

            case "flat-text":
                var image_ = pdata_.image_;

                if (image_ != null && image_.icon_ != "none" && image_.icon_ != "default") {
                    var icon_ = image_.icon_;
                    if (this.renderer_.layerIcons_[icon_] == null) {
                        this.renderer_.layerIcons_[icon_] = new Vadstena.GpuTexture(this.gpu_, icon_);
                    }

                    pdata_.texture_ = this.renderer_.layerIcons_[icon_];
                }

                if (this.origin_ != null) {
                    var p = pdata_.point_;
                    pdata_.point_ = [p[0] + this.origin_[0], p[1] + this.origin_[1], p[2] + this.origin_[2]];
                }

                //this.font_ = new Vadstena.GpuFont(this.gpu_, this.browser_);
                var text_ = new Vadstena.GpuText(this.gpu_, this.browser_, this.renderer_.font_);
                var size_ = 10*pdata_.scale_;
                var textLenght_ = text_.getTextLength(pdata_.text_, text_.getFontFactor (size_));

                text_.addText([0,0,0], [1,0,0], pdata_.text_, size_);
                text_.compile();

                pdata_.gpuText_ = text_;
                pdata_.textOffset_ = [-textLenght_*0.5, 0];
                pdata_.textSize_ = [textLenght_, 13*pdata_.scale_];
                break;


            case "path-text":

                var points_ = pdata_.points_;
                var center_ = pdata_.center_;

                if (points_ == null || points_.length < 2) {
                    break;
                }


                var newPoints_ = new Array(points_.length);
                var newPoints2_ = new Array(points_.length);

                if (this.origin_ == null) {
                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        var p = points_[j];
                        var p2 = points_[lj-j-1];
                        newPoints_[j] = [p[0]-center_[0], p[1]-center_[1], (p[2]-center_[2]) + 0.5];
                        newPoints2_[j] = [p2[0]-center_[0], p2[1]-center_[1], (p2[2]-center_[2]) + 0.5];
                    }
                } else {
                    for (var j = 0, lj = points_.length; j < lj; j++) {
                        var p = points_[j];
                        var p2 = points_[lj-j-1];
                        newPoints_[j] = [p[0], p[1], p[2] + 0.5];
                        newPoints2_[j] = [p2[0], p2[1], p2[2] + 0.5];
                    }
                }

                var text_ = null;

                if (this.optimize_ == true) {
                    if (this.gpuPathTexts_ == null) {
                        this.gpuPathTexts_ = new Vadstena.GpuText(this.gpu_, this.browser_, this.renderer_.font_);
                    }
                    text_ = this.gpuPathTexts_;
                } else {
                    text_ = new Vadstena.GpuText(this.gpu_, this.browser_, this.renderer_.font_);
                }

                text_.addStreetTextOnPath(newPoints_, pdata_.text_, pdata_.size_);
                text_.addStreetTextOnPath(newPoints2_, pdata_.text_, pdata_.size_);

                if (this.optimize_ != true) {
                    text_.compile();
                }

                pdata_.gpuText_ = text_;
                break;
        }
    }

    if (this.optimize_ == true) {
        if (this.gpuPathTexts_ != null) {
            this.gpuPathTexts_.compile();
        }

        if (this.gpuStencilLines_ != null) {
            this.gpuStencilLines_.compile();
        }
    }

};

Vadstena.LayerOld.prototype.draw = function(offsetFactor_) {

    var gl_ = this.gpu_.gl_;
    var gpu_ = this.gpu_;
    var renderer_ = this.renderer_;

    //check if layer is visible
    if (this.bbox_ != null) {
        if (!renderer_.camera_.boxVisible(this.bbox_.translateXY(renderer_.position_))) {
            return;
        }

        if (renderer_.camera_.distance([(this.bbox_.max_[0] + this.bbox_.min_[0])*0.5-renderer_.position_[0],
                                        (this.bbox_.max_[1] + this.bbox_.min_[1])*0.5-renderer_.position_[1],
                                        (this.bbox_.max_[2] + this.bbox_.min_[2])*0.5-renderer_.position_[2]]) > 100000) {
            return;
        }
    }

    var cameraPos2_ = renderer_.camera_.getPosition();
    var cameraPos_ = renderer_.cameraPosition();

    var rotationview_ = renderer_.camera_.getRotationviewMatrix();
    var primitiveMat_ = Vadstena.mat4.create();
    var mvp_ = Vadstena.mat4.create();
    var color_ = [0,0,0,255];
    var pixelSize_ = [1.0/renderer_.curSize_[0], 1.0/renderer_.curSize_[1]];

    var yaw_ = Vadstena.radians(renderer_.orientation_[0]);
    var forward_ = [-Math.sin(yaw_), Math.cos(yaw_), 0, 0];

    var zoffset_ = -Math.round(2000 * offsetFactor_);

    var stencilLineState_ = gpu_.createState({blend_:true, stencil_:true, zoffset_:zoffset_, culling_: false});
    var pixelLineState_ = gpu_.createState({zoffset_:zoffset_});
    var pixelWallState_ = gpu_.createState({zoffset_:-1});
    var polygonWallState_ = gpu_.createState({culling_:false});
    var pathTextState_ = gpu_.createState({blend_:true, zoffset_:zoffset_});
    var flatTextState_ = pathTextState_;
    var flatImageState_ = pathTextState_;

    if (this.gpuStencilLines_ != null || this.gpuPathTexts_ != null) {

        var position_ = this.origin_;
        var pos_ = [position_[0] - cameraPos_[0] + cameraPos2_[0], position_[1] - cameraPos_[1] + cameraPos2_[1], position_[2] - cameraPos_[2] + cameraPos2_[2] ];

        Vadstena.mat4.multiply(Vadstena.translationMatrix(pos_[0], pos_[1], pos_[2]), Vadstena.scaleMatrixf(1.0), primitiveMat_);
        Vadstena.mat4.multiply(renderer_.camera_.getMvpMatrix(), primitiveMat_, mvp_);

        if (this.gpuStencilLines_ != null) {
            color_ = [1,1,1,90/255];

            gpu_.setState(stencilLineState_);

            gpu_.useProgram(renderer_.progLine_, "aPosition", null, null, null);
            renderer_.progLine_.setVec4("uColor", color_);
            renderer_.progLine_.setMat4("uMVP", mvp_);
            this.gpuStencilLines_.draw(renderer_.progLine_, "aPosition");
        }

        if (this.gpuPathTexts_ != null) {
            color_ = [1,1,1,1];

            gpu_.setState(pathTextState_);

            gpu_.useProgram(renderer_.progText_, "aPosition", "aTexCoord");
            gpu_.bindTexture(renderer_.font_.texture_);

            renderer_.progText_.setSampler("uSampler", 0);
            renderer_.progText_.setMat4("uMVP", mvp_);
            renderer_.progText_.setVec4("uVec", forward_);
            renderer_.progText_.setVec4("uColor", [1,1,1,1]);

            this.gpuPathTexts_.draw(renderer_.progText_, "aPosition", "aTexCoord");
        }
    }


    for (var i = 0, li = this.primitives_.length; i < li; i++) {

        var primitive_ = this.primitives_[i];
        var pdata_ = primitive_.data_;

        if (this.optimize_ == true) {
            switch (primitive_.type_) {
                case "stencil-line":
                case "path-text":
                    continue;
                    break;
            }
        }

        switch (primitive_.type_) {
            case "pixel-line":
            case "pixel-line2":
            case "stencil-line":
            case "pixel-wall":
            case "polygon-wall":
            case "path-text":

                var position_ = pdata_.center_;
                var pos_ = [position_[0] - cameraPos_[0] + cameraPos2_[0], position_[1] - cameraPos_[1] + cameraPos2_[1], position_[2] - cameraPos_[2] + cameraPos2_[2] ];

                Vadstena.mat4.multiply(Vadstena.translationMatrix(pos_[0], pos_[1], pos_[2]), Vadstena.scaleMatrixf(1.0), primitiveMat_);
                Vadstena.mat4.multiply(renderer_.camera_.getMvpMatrix(), primitiveMat_, mvp_);

                var c = pdata_.color_;
                color_ = [c[0]/255, c[1]/255, c[2]/255, c[3]/255];
                break;
        }

        switch (primitive_.type_) {
            case "stencil-line":

                gpu_.setState(stencilLineState_);

                gpu_.useProgram(renderer_.progLine_, "aPosition", null, null, null);
                renderer_.progLine_.setVec4("uColor", color_);
                renderer_.progLine_.setMat4("uMVP", mvp_);
                pdata_.gpuLine_.draw(renderer_.progLine_, "aPosition");
                break;

            case "pixel-line":
            case "pixel-line2":
            case "pixel-wall":

                if (primitive_.type_ != "pixel-wall") {
                    gpu_.setState(pixelLineState_);
                } else {
                    gpu_.setState(pixelWallState_);
                }

                gpu_.useProgram(renderer_.progLine3_, "aPosition", null, null, "aNormal");
                renderer_.progLine3_.setMat4("uMVP", mvp_);
                renderer_.progLine3_.setVec4("uColor", color_);
                renderer_.progLine3_.setVec2("uScale", pixelSize_);
                pdata_.gpuLine3_.draw(renderer_.progLine3_, "aPosition", "aNormal");
                break;

            case "polygon-wall":

                gpu_.setState(polygonWallState_);

                gpu_.useProgram(renderer_.progPolygon_, "aPosition", null, null, "aNormal");
                renderer_.progPolygon_.setMat4("uMVP", mvp_);
                renderer_.progPolygon_.setMat4("uRot", rotationview_);
                renderer_.progPolygon_.setVec4("uColor", color_);
                pdata_.gpuPolygon_.draw(renderer_.progPolygon_, "aPosition", "aNormal");
                break;

            case "flat-image":

                gpu_.setState(flatImageState_);

                var p = pdata_.point_;
                var pp = renderer_.project(p);
                var scale_ = pdata_.scale_ * 0.5;
                var icon_ = pdata_.icon_;
                var texture_ = renderer_.placemarkTexture_;

                if (pdata_.texture_ != null && pdata_.texture_.loaded_ == true) {
                    texture_ = pdata_.texture_;
                }

                var newWidth_ = texture_.width_ * scale_;
                var newHeight_ = texture_.height_ * scale_;

                var offset_ = this.getIconOffset(texture_, pdata_);
                var posX_ = pp[0]-offset_[0];
                var posY_ = pp[1]-newHeight_+offset_[1];

                if (pdata_.html_ != null && pdata_.html_ != "") {
                    this.renderer_.layerPlaces_.push({"rect":[posX_, posY_, posX_+newWidth_, posY_+newHeight_],
                                                      "pos":pp, "html": pdata_.html_});
                }

                renderer_.drawFlatImage(posX_, posY_, newWidth_, newHeight_, texture_, pdata_.color_, pp[2], true, true);
                break;

            case "flat-text":

                gpu_.setState(flatTextState_);

                var p = pdata_.point_;

                if (pdata_.minDistance_ != null) {
                    if (Vadstena.vec3.squareDistance(cameraPos_, p) > pdata_.minDistance_){
                        break;
                    }
                }

                var pp = renderer_.project(p);

                var pos_ = [-renderer_.position_[0], -renderer_.position_[1], 0];

                var domeMat_ = Vadstena.mat4.create();
                Vadstena.mat4.multiply(Vadstena.translationMatrix(pos_[0], pos_[1], pos_[2]), Vadstena.scaleMatrixf(1.0), domeMat_);

                var mvp2_ = Vadstena.mat4.create();
                Vadstena.mat4.multiply(renderer_.camera_.getMvpMatrix(), domeMat_, mvp2_);

                var offset_ = [0, 0];

                var image_ = pdata_.image_;

                if (image_ != null && image_["icon"] != "none") {

                    var texture_ = renderer_.placemarkTexture_;

                    if (pdata_.texture_ != null && pdata_.texture_.loaded_ == true) {
                        texture_ = pdata_.texture_;
                    }

                    offset_ = this.getIconOffset(texture_, pdata_, true);
                    offset_[0] += 3;
                    offset_[1] -= 13;

                } else {
                    offset_[0] = pdata_.textOffset_[0];
                    offset_[1] = pdata_.textOffset_[1] - 13;
                }

                var posX_ = pp[0]+offset_[0];
                var posY_ = pp[1]+offset_[1];

                if (pdata_.html_ != null && pdata_.html_ != "") {
                    this.renderer_.layerPlaces_.push({"rect":[posX_, posY_, posX_+pdata_.textSize_[0], posY_+pdata_.textSize_[1]],
                                                      "pos":pp, "html": pdata_.html_});
                }

                gpu_.useProgram(renderer_.progText2_, "aPosition", "aTexCoord");
                gpu_.bindTexture(renderer_.font_.texture_);

                renderer_.progText2_.setSampler("uSampler", 0);
                renderer_.progText2_.setMat4("uMVP", renderer_.imageProjectionMatrix_);
                renderer_.progText2_.setVec4("uPosition", [Math.round(posX_), Math.round(posY_), pp[2], 0]);
                renderer_.progText2_.setVec4("uColor", [1,1,1,1]);
                pdata_.gpuText_.draw(renderer_.progText2_, "aPosition", "aTexCoord");

                break;


            case "path-text":

                gpu_.setState(pathTextState_);

                gpu_.useProgram(renderer_.progText_, "aPosition", "aTexCoord");
                gpu_.bindTexture(renderer_.font_.texture_);

                renderer_.progText_.setSampler("uSampler", 0);
                renderer_.progText_.setMat4("uMVP", mvp_);
                renderer_.progText_.setVec4("uVec", forward_);
                renderer_.progText_.setVec4("uColor", [1,1,1,1]);

                pdata_.gpuText_.draw(renderer_.progText_, "aPosition", "aTexCoord");
                break;

        }
    }

    gpu_.setState(gpu_.defaultState_);
};

Vadstena.LayerOld.prototype.getIconOffset = function(texture_, data_, label_) {
    var offset_ = [0,0];

    if (texture_ == null || data_ == null) {
        return offset_;
    }

    var scale_ = data_.scale_ * 0.5;
    var newWidth_ = texture_.width_ * scale_;
    var newHeight_ = texture_.height_ * scale_;

    switch (data_.xunits_) {
        case "pixels":      offset_[0] = data_.x_ * scale_; break;
        case "fraction":    offset_[0] = newWidth_ * data_.x_; break;
        case "insetPixels": offset_[0] = (texture_.width_ - 1 - data_.x_) * scale_; break;
    }

    switch (data_.yunits_) {
        case "pixels":      offset_[1] = data_.y_ * scale_; break;
        case "fraction":    offset_[1] = newHeight_ * data_.y_; break;
        case "insetPixels": offset_[1] = (texture_.height_ - 1 - data_.y_) * scale_; break;
    }

    if (label_ == true) {
        offset_[0] += newWidth_ * 0.5;
        offset_[1] -= newHeight_ * 0.5;
    }

    return offset_;
};



if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.LayerTilled = function(planet_, id_, type_, urlTemplate_, minLod_, maxLod_, tilePixels_, style_, tags_, visible_)
{
    this.planet_ = planet_;
    this.type_ = "tiled-geolayer";
    this.gpu_ = planet_.gpu_;
    this.browser_ = planet_.browser_;
    this.renderer_ = planet_.renderer_;
    this.camera_ = this.renderer_.camera_;
    this.innerId_ = planet_.layerCounter_;
    this.urlTemplate_ = urlTemplate_;
    this.id_ = id_;
    this.type_ = type_;
    this.tags_ = tags_;
    this.visible_ = (visible_ != null) ? visible_ : true;
    this.tilePixels_ = tilePixels_ || 256;
    this.maxTileLod_ = maxLod_;
    this.minTileLod_ = minLod_;
    this.style_ = style_;

    //reduce garbage collection
    this.drawTileMatrix_ = Vadstena.mat4.create();
    this.drawTileMatrix2_ = Vadstena.mat4.create();
    this.drawTileVec_ = [0,0,0];
    this.drawTileWorldMatrix_ = Vadstena.mat4.create();
    this.pixelTileSizeMatrix_ = Vadstena.mat4.create();
    this.recurseToChildrenVec_ = [0,0,0];
    this.recurseToChildrenOrdering_ = [
        [ 3, 1, 2, 0 ], [ 3, 2, 1, 0 ],
        [ 2, 3, 0, 1 ], [ 2, 0, 3, 1 ],
        [ 0, 2, 1, 3 ], [ 0, 1, 2, 3 ],
        [ 1, 0, 3, 2 ], [ 1, 3, 0, 2 ]
    ];

    if (this.renderer_.font_ == null) {
        this.renderer_.font_ = new Vadstena.GpuFont(this.gpu_, this.browser_);
    }

    this.geodataProcessor_ = new Vadstena.geodataProcessor(this, this.onGeodataProcessorMessage.bind(this));
    this.geodataProcessor_.sendCommand("setStyles", this.style_);
    this.geodataProcessor_.sendCommand("setFont", {"chars" : this.renderer_.font_.chars_, "space" : this.renderer_.font_.space_, "size" : this.renderer_.font_.size_});

    this.geodataCache_ = new Vadstena.TileGeodataCache(this.browser_, Number.MAX_VALUE, // unlimited, we trim the cache manually
              (function(){ this.renderer_.dirty_ = true; }).bind(this),
              this.browser_.browserConfig_.numThreads_, Vadstena.TileGeodataDownload, this);

    this.gpuCache_ = this.renderer_.gpuCache_;
};

//destructor
Vadstena.LayerTilled.prototype.kill = function() {
    this.geodataCache_.reset();
    this.geodataProcessor_.kill();
};

Vadstena.LayerTilled.prototype.getId = function() {
    return this.id_;
};

Vadstena.LayerTilled.prototype.isVisible = function() {
    return this.visible_;
};

Vadstena.LayerTilled.prototype.setVisible = function(state_) {
    if (this.visible_ != state_) {
        this.visible_ = state_;
        this.renderer_.dirty_ = true;
    }
};

Vadstena.LayerTilled.prototype.setGeodataProcessorListener = function(listener_) {
};

Vadstena.LayerTilled.prototype.onGeodataProcessorMessage = function(message_) {

    switch(message_["command"]) {
        case "loadBitmaps":
            var bitmaps_ = message_["bitmaps"];
            if (bitmaps_ != null) {
                for (var key_ in bitmaps_) {
                    this.renderer_.getBitmap(bitmaps_[key_]["url"], bitmaps_[key_]["filter"] || "linear", bitmaps_[key_]["tiled"] || false);
                }
            }
            break;
    }

};

Vadstena.LayerTilled.prototype.update = function() {
    this.curSize_ = this.renderer_.curSize_;
    this.position_ = this.renderer_.position_;
    this.orientation_ = this.renderer_.orientation_;

    this.terrainId_ = this.planet_.getMainTerrain().innerId_;
    this.metaCache_ =  this.planet_.getMainTerrain().metaCache_;

    // we don't want QCache to delete items randomly in the download threads
    // so we explicitly trim the caches here, in the main thread
    this.geodataCache_.trim(this.browser_.browserConfig_.cacheSize_);

    this.geodataCache_.update();
};


//! Calculates how large is the tile's texel when drawn on the screen, measured
//! in screen pixels.
//!
Vadstena.LayerTilled.prototype.tilePixelSize = function(node_, returnDistance_, pixelSize_) {

    var ndcToScreenPixel_ = (this.curSize_[0] / 2.0);

    var cameraPos_ = this.renderer_.cameraPosition(); //get global camera pos

    var tileSize_ = node_.bbox_.max_[0]-node_.bbox_.min_[0]; //get tile size
    var tilePos_ = [node_.bbox_.min_[0], node_.bbox_.min_[1], node_.bbox_.min_[2]]; //get global pos
    var tilePos2_ = [tilePos_[0] + tileSize_, tilePos_[1], tilePos_[2]];
    var tilePos3_ = [tilePos_[0] + tileSize_, tilePos_[1] + tileSize_, tilePos_[2]];
    var tilePos4_ = [tilePos_[0], tilePos_[1] + tileSize_, tilePos_[2]];

    var h1_ = node_.bbox_.min_[2];
    var h2_ = node_.bbox_.max_[2];

    var factor_ = 0;

    //find bbox sector
    if (cameraPos_[1] < tilePos_[1]) { //top row

        if (cameraPos_[0] < tilePos_[0]) { // left top corner

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos2_[0]) { // right top corner

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }


        } else { //top side

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        }

    } else if (cameraPos_[1] > tilePos4_[1]) { //bottom row

        if (cameraPos_[0] < tilePos4_[0]) { // left bottom corner

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos3_[0]) { // right bottom corner

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else { //bottom side

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        }

    } else { //middle row

        if (cameraPos_[0] < tilePos4_[0]) { // left side

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos3_[0]) { // right side

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else { //center

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }
        }
    }

    //console.log("new: " + (factor_ * pixelSize_ * ndcToScreenPixel_) + " old:" + this.tilePixelSize2(node_) );

    if (returnDistance_ == true) {
        return [(factor_[0] * pixelSize_ * ndcToScreenPixel_), factor_[1]];
    }

    return (factor_ * pixelSize_ * ndcToScreenPixel_);
};

//! Checks for the special case of an insufficient resolution tile being
//! available while some of its (correct resolution) children are unavailable.
//! The insufficient resolution tile can then be drawn temporarily until its
//! children are ready.
//!
Vadstena.LayerTilled.prototype.canDrawCoarserLod = function(tileId_, node_, virtual_)
{
    if (!this.geodataCache_.contains(tileId_) /*|| !node_.hasGeometry()*/) {
        return false;
    }

    if (tileId_.lod_ >= this.maxTileLod_) {
        return true;
    }

    // check for availability of the children, note that this actually schedules
    // them for download if they are not available
    for (var i = 0; i < 4; i++) {
        if (virtual_ || node_.childFlags_ & (1 << i)) {
            var child_ = tileId_.child(i);

            var haveTile_ = this.geodataCache_.get(child_);

            if (virtual_ == true) {
                if (!haveTile_) {
                    return true;
                }
            } else {
                var haveMeta_ = this.metaCache_.get(child_); // schedule the metatile too

                if (!haveTile_ || !haveMeta_) {
                    return true;
                }
            }
        }
    }
    return false;
};


//! Returns true if at least one child of a tile is present in the cache.
//! The children are checked silently, no scheduling for download.
//!
Vadstena.LayerTilled.prototype.childrenAvailable = function(tileId_, node_)
{
    if (tileId_.lod_ >= this.maxTileLod_) {
        return false;
    }

    for (var i = 0; i < 4; i++) {
        if (this.geodataCache_.contains(tileId_.child(i))) {
            return true;
        }
    }

    return false;
};

//! Main drawing function, called recursively. Returns the maximum projected
//! texel size.
Vadstena.LayerTilled.prototype.drawSurface = function(tileId_, virtual_)
{
    var node_ = (this.metaCache_.get(tileId_, virtual_, this.terrainId_));

    // skip the node if metadata is not available yet or if it is not visible
    if (!node_ || !this.camera_.boxVisible(node_.bbox_.translateXY(this.position_))) {
        return 0;
    }

    var mapConfig_ = this.browser_.mapConfig_;

    //if (!node_.hasGeometry()) {
        //return this.recurseToChildren(tileId_, node_, virtual_);
    //}

    // calculate projected pixel size of the tile texture
    var pixelSize_ = (this.tilePixelSize(node_, null, node_.bbox_.side(0) / this.tilePixels_));

    // draw the tile if we can't go deeper or if the resolution is OK already
    if (tileId_.lod_ >= this.maxTileLod_ || (pixelSize_ < Vadstena.resolutionThreshold_ && this.drawMaxLod_ != true))
    {
        var tile_ = (this.geodataCache_.get(tileId_));
        if (tile_ || !this.childrenAvailable(tileId_, node_)) {

            if (tile_ == null) {
                pixelSize_ = pixelSize_;
            }

            if (tile_ != null) {
                this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Geodata, tileId_, tile_, node_];
            }
        } else {
            // the correct tile is not available yet but we have finer tiles
            this.recurseToChildren(tileId_, node_, virtual_);
        }

        //this.maxPixelSize_ = Math.max(this.maxPixelSize_, pixelSize_);
        return pixelSize_;
    }
    // also draw the tile if the finer tiles are not ready yet but the
    // resolution is still reasonable
    else if (pixelSize_ < mapConfig_.lowRes_ && this.canDrawCoarserLod(tileId_, node_, virtual_))
    {
        var tile_ = (this.geodataCache_.get(tileId_));

        if (tile_ == null) {
            pixelSize_ = pixelSize_;
        }

        this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Geodata, tileId_, tile_, node_];
        return 0;
    }
    else  // we need to go deeper in the hierarchy...
    {
        return this.recurseToChildren(tileId_, node_, virtual_);
    }
};


//! Draws children of the specified node, in a front to back order.
//!
Vadstena.LayerTilled.prototype.recurseToChildren = function(tileId_, node_, virtual_)
{
    var ordering_ = this.recurseToChildrenOrdering_;

    // determine where the camera is relative to the node center and
    // select a front to back ordering of the child nodes
    var center_ = node_.bbox_.center(this.recurseToChildrenVec_);
    var cameraPos_ = this.camera_.position_;

    var angle_ = Math.atan2(this.position_[1] + cameraPos_[1] - center_[1], this.position_[0] + cameraPos_[0] - center_[0]);
    var idx_ = (Math.floor((angle_ + Math.PI) / Math.PI * 4));
    idx_ = Vadstena.clamp(idx_, 0, 7);

    // recurse to child nodes
    var childMax_ = 0;
    for (var i = 0; i < 4; i++)
    {
        var childIdx_ = ordering_[idx_][i];
        var useVirtual_ = virtual_ || !(node_.childFlags_ & (1 << childIdx_));

        var child_ = tileId_.child(childIdx_);

        if (useVirtual_) {
            this.generateChildNode(child_, node_);
        }

        childMax_ = Math.max(childMax_, this.drawSurface(child_, useVirtual_));
    }

    return childMax_;
};


Vadstena.LayerTilled.prototype.getNodeHeight = function(tileInfo_, index_) {
    //TODO:
};

Vadstena.LayerTilled.prototype.generateChildNode = function(tileId_, parentNode_) {
    var node_ = new Vadstena.MetaNode(this.browser_, tileId_, null, null, parentNode_);

    tileId2_ = new Vadstena.TileId(this.browser_, tileId_.lod_, tileId_.easting_, tileId_.northing_, this.terrainId_);

    this.metaCache_.insert(tileId2_, node_, node_.size());
};

Vadstena.LayerTilled.prototype.draw = function() {

    if (this.visible_ == false) {
        return;
    }

    var tileId_ = this.browser_.mapConfig_.foat_.clone();
    tileId_.layerId_ = this.innerId_;

    var maxPixelSize_ = this.drawSurface(tileId_);

    // we don't want QCache to delete items randomly in the download threads
    // so we explicitly trim the caches here, in the main thread
    this.geodataCache_.trim(this.browser_.browserConfig_.cacheSize_);

    return maxPixelSize_;
};

//not used
Vadstena.LayerTilled.prototype.processTile = function(tileInfo_, terrain_) {

    var children_ = false;

    for (var i = 0; i < 0; i++) {
        var childInfo_ = this.getChild(i);
        var childNode_ = childInfo_[3];

        var childPixelSize_ = this.tilePixelSize(childNode_, false, pixelSize_);

        if (childPixelSize_ < Vadstena.resolutionThreshold_ /* && this.drawMaxLod_ != true*/ ) {
            this.processTile(childInfo_, terrain_);
            children_ = true;
        }
    }

    //draw tile
    if (children_ == false) {

        var tileId_ = tileInfo_[1].clone();
        tileId_.layerInnerId_ = this.innerId_;

        var tile_ = this.geodataCache_.get(tileId_);

        if (tile_ != null) {
            this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Geodata, tileId_, tile_, tileInfo_[3]];
        }

        //this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Geodata, tileInfo_[1], tileInfo_[2], tileInfo_[3]];
    }

};


if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.LayerTerrain = function(planet_, id_, tags_, visible_)
{
    this.planet_ = planet_;
    this.type_ = "terrain";
    this.gpu_ = planet_.gpu_;
    this.browser_ = planet_.browser_;
    this.renderer_ = planet_.renderer_;
    this.camera_ = this.renderer_.camera_;
    this.innerId_ = planet_.layerCounter_;
    this.id_ = id_;
    this.tags_ = tags_;
    this.visible_ = visible_ || true;
    this.position_ = [0,0,0];
    this.orientation_ = [0,0,0];
    this.curSize_ = [1,1]; //QSize

    this.recurseToChildrenVec_ = [0,0,0];
    this.recurseToChildrenOrdering_ = [
        [ 3, 1, 2, 0 ], [ 3, 2, 1, 0 ],
        [ 2, 3, 0, 1 ], [ 2, 0, 3, 1 ],
        [ 0, 2, 1, 3 ], [ 0, 1, 2, 3 ],
        [ 1, 0, 3, 2 ], [ 1, 3, 0, 2 ]
    ];

    this.metaCache_ = new Vadstena.MetaCache(this.browser_, Number.MAX_VALUE, // unlimited, we trim the cache manually
              (function(){ this.renderer_.dirty_ = true; }).bind(this),  //null,//this.update.bind(this),
              this.browser_.browserConfig_.numThreads_, Vadstena.MetaTileDownload);
    this.tileCache_ = new Vadstena.TileTerrainCache(this.browser_, Number.MAX_VALUE, // unlimited, we trim the cache manually
              (function(){ this.renderer_.dirty_ = true; }).bind(this), //null,//this.update.bind(this),
              this.browser_.browserConfig_.numThreads_, Vadstena.TileTerrainDownload);
};

//destructor
Vadstena.LayerTerrain.prototype.kill = function() {
    this.tileCache_.reset();
    this.metaCache_.reset();
};

Vadstena.LayerTerrain.prototype.getId = function() {
    return this.id_;
};

Vadstena.LayerTerrain.prototype.isVisible = function() {
    return this.visible_;
};

Vadstena.LayerTerrain.prototype.setVisible = function(state_) {
    this.visible_ = state_;
};

//! A version of drawSurface that draws nothing and only calculates the maximum
//! pixel size of the visible tiles.
//!
Vadstena.LayerTerrain.prototype.calculateResolution = function(tileId_)
{
   var node_ = this.metaCache_.get(tileId_);

   if (!node_ || !this.camera_.boxVisible(node_.bbox_.translateXY(this.position_))) {
       return 0;
   }

   if (node_.hasGeometry()) {

       var pixelSize_ = this.tilePixelSize(node_);

       if (!node_.childFlags_ || pixelSize_ < Vadstena.resolutionThreshold_) {
           return pixelSize_;
       }
   }

    //recurse to childern
    var childMax_ = 0;
    for (var i = 0; i < 4; i++) {
        if (node_.childFlags_ & (1 << i)) {
            childMax_ = Math.max(childMax_, this.calculateResolution(tileId_.child(i)));
        }
    }
   return childMax_;
};


Vadstena.LayerTerrain.prototype.calculateMinDistance = function(tileId_, camera_)
{
   var node_ = this.metaCache_.get(tileId_);

   if (!node_ || !camera_.boxVisible(node_.bbox_.translateXY(this.position_))) {
       return 9999999;
   }

   if (node_.hasGeometry()) {

       var pixelSize_ = this.tilePixelSize(node_, true);

       if (!node_.childFlags_ || pixelSize_[0] < Vadstena.resolutionThreshold_) {
           return pixelSize_[1];
       }
   }

    //recurse to childern
    var childMax_ = 9999999;
    for (var i = 0; i < 4; i++) {
        if (node_.childFlags_ & (1 << i)) {
            childMax_ = Math.min(childMax_, this.calculateMinDistance(tileId_.child(i), camera_));
        }
    }
   return childMax_;
};


Vadstena.LayerTerrain.prototype.update = function() {
    this.curSize_ = this.renderer_.curSize_;
    this.position_ = this.renderer_.position_;
    this.orientation_ = this.renderer_.orientation_;

    this.metaCache_.update();
    this.tileCache_.update();
};




//! Calculates how large is the tile's texel when drawn on the screen, measured
//! in screen pixels.
//!
Vadstena.LayerTerrain.prototype.tilePixelSize = function(node_, returnDistance_) {

    var ndcToScreenPixel_ = (this.curSize_[0] / 2.0);

    var cameraPos_ = this.renderer_.cameraPosition(); //get global camera pos

    var tileSize_ = node_.bbox_.max_[0]-node_.bbox_.min_[0]; //get tile size
    var tilePos_ = [node_.bbox_.min_[0], node_.bbox_.min_[1], node_.bbox_.min_[2]]; //get global pos
    var tilePos2_ = [tilePos_[0] + tileSize_, tilePos_[1], tilePos_[2]];
    var tilePos3_ = [tilePos_[0] + tileSize_, tilePos_[1] + tileSize_, tilePos_[2]];
    var tilePos4_ = [tilePos_[0], tilePos_[1] + tileSize_, tilePos_[2]];

    var h1_ = node_.bbox_.min_[2];
    var h2_ = node_.bbox_.max_[2];

    var factor_ = 0;
    var pixelSize_ = 0;

    //find bbox sector
    if (cameraPos_[1] < tilePos_[1]) { //top row

        if (cameraPos_[0] < tilePos_[0]) { // left top corner

            pixelSize_ = node_.pixelSize_[0][0];

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], tilePos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos2_[0]) { // right top corner

            pixelSize_ = node_.pixelSize_[0][1];

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], tilePos2_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }


        } else { //top side

            //blend top left and top right corners
            pixelSize_ = node_.pixelSize_[0][0] + (node_.pixelSize_[0][1] - node_.pixelSize_[0][0]) * ((cameraPos_[0] - tilePos_[0]) / tileSize_) ;

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos2_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        }

    } else if (cameraPos_[1] > tilePos4_[1]) { //bottom row

        if (cameraPos_[0] < tilePos4_[0]) { // left bottom corner

            pixelSize_ = node_.pixelSize_[1][0];

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos4_[0]-this.position_[0], tilePos4_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos3_[0]) { // right bottom corner

            pixelSize_ = node_.pixelSize_[1][1];

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos3_[0]-this.position_[0], tilePos3_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else { //bottom side

            //blend bottom left and bottom right corners
            pixelSize_ = node_.pixelSize_[1][0] + (node_.pixelSize_[1][1] - node_.pixelSize_[0][1]) * ((cameraPos_[0] - tilePos4_[0]) / tileSize_) ;

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], tilePos3_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        }

    } else { //middle row

        if (cameraPos_[0] < tilePos4_[0]) { // left side

            //blend top left and bottom left corners
            pixelSize_ = node_.pixelSize_[0][0] + (node_.pixelSize_[1][0] - node_.pixelSize_[0][0]) * ((cameraPos_[1] - tilePos_[1]) / tileSize_) ;

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else if (cameraPos_[0] > tilePos3_[0]) { // right side

            //blend top right and bottom right corners
            pixelSize_ = node_.pixelSize_[0][1] + (node_.pixelSize_[1][1] - node_.pixelSize_[0][1]) * ((cameraPos_[1] - tilePos2_[1]) / tileSize_) ;

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([tilePos2_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }

        } else { //center

            //blend all corners
            var fx_ = ((cameraPos_[0] - tilePos_[0]) / tileSize_);
            var fy_ = ((cameraPos_[1] - tilePos_[1]) / tileSize_);
            var w1_ = node_.pixelSize_[0][0] + (node_.pixelSize_[0][1] - node_.pixelSize_[0][0]) * fx_;
            var w2_ = node_.pixelSize_[1][0] + (node_.pixelSize_[1][1] - node_.pixelSize_[1][0]) * fx_;
            pixelSize_ = w1_ + (w2_ - w1_) * fy_;

            if (cameraPos_[2] > h2_) { // hi
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h2_], returnDistance_);
            } else if (cameraPos_[2] < h1_) { // low
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], h1_], returnDistance_);
            } else { // middle
                factor_ = this.camera_.scaleFactor([cameraPos_[0]-this.position_[0], cameraPos_[1]-this.position_[1], cameraPos_[2]], returnDistance_);
            }
        }
    }

    //console.log("new: " + (factor_ * pixelSize_ * ndcToScreenPixel_) + " old:" + this.tilePixelSize2(node_) );

    if (returnDistance_ == true) {
        return [(factor_[0] * pixelSize_ * ndcToScreenPixel_), factor_[1]];
    }

    return (factor_ * pixelSize_ * ndcToScreenPixel_);
};


//! Checks for the special case of an insufficient resolution tile being
//! available while some of its (correct resolution) children are unavailable.
//! The insufficient resolution tile can then be drawn temporarily until its
//! children are ready.
//!
Vadstena.LayerTerrain.prototype.canDrawCoarserLod = function(tileId_, node_)
{
    //if (!this.tileCache_.get(tileId_) || !node_.hasGeometry()) {
    if (!this.tileCache_.contains(tileId_) || !node_.hasGeometry()) {
        return false;
    }

    // check for availability of the children, note that this actually schedules
    // them for download if they are not available
    for (var i = 0; i < 4; i++) {
        if (node_.childFlags_ & (1 << i)) {
            var child_ = tileId_.child(i);

            var haveTile_ = this.tileCache_.get(child_);
            var haveMeta_ = this.metaCache_.get(child_); // schedule the metatile too

            if (!haveTile_ || !haveMeta_){
                return true;
            }
        }
    }
    return false;
};


//! Returns true if at least one child of a tile is present in the cache.
//! The children are checked silently, no scheduling for download.
//!
Vadstena.LayerTerrain.prototype.childrenAvailable = function(tileId_, node_)
{
    if (!node_.childFlags_) {
        return false;
    }

    for (var i = 0; i < 4; i++) {
        if (node_.childFlags_ & (1 << i)) {
            if (this.tileCache_.contains(tileId_.child(i))) {
                return true;
            }
        }
    }
    return false;
};

//! Main drawing function, called recursively. Returns the maximum projected
//! texel size.
Vadstena.LayerTerrain.prototype.drawSurface = function(tileId_, treeBuffer_)
{
    //return 0;

    var node_ = (this.metaCache_.get(tileId_));

    // skip the node if metadata is not available yet or if it is not visible
    if (!node_ || !this.camera_.boxVisible(node_.bbox_.translateXY(this.position_))) {
        return 0;
    }

    if (!node_.hasGeometry()) {
        return this.recurseToChildren(tileId_, node_);
    }

    // calculate projected pixel size of the tile texture
    //var pixelSize_ = (this.tilePixelSize(node_));
    var mapConfig_ = this.browser_.mapConfig_;
    var degdradeHorizon_ = mapConfig_.degdradeHorizon_;

    var result_ = (this.tilePixelSize(node_, true));
    var pixelSize_ = result_[0];
    var distance_ = result_[1];

    var degradeFadeStart_ = degdradeHorizon_[1];
    var degradeFadeEnd_ = degdradeHorizon_[2];

    var degardeFactor_ = 200.0 * degdradeHorizon_[0];

    if (degardeFactor_ > 1.0) {

        //reduce degrade factor by tilt
        degardeFactor_ *= 0.5*(1.0+Math.cos(Vadstena.radians(Math.min(180,Math.abs(this.renderer_.orientation_[1]*2*3)))));

        //apply degrade factor smoothly from specified tile distance
        if (distance_ < degradeFadeStart_) {
            degardeFactor_ = 1.0;
        } else if (distance_ > degradeFadeStart_ && distance_ < degradeFadeEnd_) {
            degardeFactor_ = 1.0 + (degardeFactor_-1.0) * ((distance_ - degradeFadeStart_) / (degradeFadeEnd_ - degradeFadeStart_));
        }

        degardeFactor_ = Math.max(degardeFactor_, 1.0);

        //reduce degrade factor by observed distance
        var observerDistance_ = this.renderer_.position_[2];
        var distanceFade_ = degdradeHorizon_[3];

        if (observerDistance_ > distanceFade_) {
            degardeFactor_ = 1.0;
        } else if (observerDistance_ < distanceFade_ && degardeFactor_ > 1.0) {
            degardeFactor_ = 1.0 + ((degardeFactor_ - 1.0) * (1.0-(observerDistance_ / distanceFade_)));
        }

        //console.log("degrade: " + degardeFactor_);

        pixelSize_ /= degardeFactor_;
    }

    // draw the tile if we can't go deeper or if the resolution is OK already
    if (!node_.childFlags_ || (pixelSize_ < Vadstena.resolutionThreshold_ && this.drawMaxLod_ != true))
    {
        var tile_ = (this.tileCache_.get(tileId_));
        if (tile_ || !this.childrenAvailable(tileId_, node_)) {
            //this.drawTile(tileId_, tile_, node_);
            this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Terrain, tileId_, tile_, node_];
        } else {
            // the correct tile is not available yet but we have finer tiles
            this.recurseToChildren(tileId_, node_);
        }

        //this.maxPixelSize_ = Math.max(this.maxPixelSize_, pixelSize_);
        return pixelSize_;
    }
    // also draw the tile if the finer tiles are not ready yet but the
    // resolution is still reasonable
    else if (pixelSize_ < mapConfig_.lowRes_ && this.canDrawCoarserLod(tileId_, node_))
    {
        var tile_ = (this.tileCache_.get(tileId_));
        //this.drawTile(tileId_, tile_, node_);
        this.planet_.terrainTileBuffer_[this.planet_.terrainTileBufferSize_++] = [Vadstena.TileType.Terrain, tileId_, tile_, node_];
        return 0;
    }
    else  // we need to go deeper in the hierarchy...
    {
        return this.recurseToChildren(tileId_, node_);
    }
};


//! Draws children of the specified node, in a front to back order.
//!
Vadstena.LayerTerrain.prototype.recurseToChildren = function(tileId_, node_)
{
    var ordering_ = this.recurseToChildrenOrdering_;

    // determine where the camera is relative to the node center and
    // select a front to back ordering of the child nodes
    var center_ = node_.bbox_.center(this.recurseToChildrenVec_);
    var cameraPos_ = this.camera_.position_;
    //var vec_ = Vadstena.vec2.create([this.position_[0] - center_[0], this.position_[1] - center_[1]]);
    //var vec_ = Vadstena.vec3.create([this.position_[0] + cameraPos_[0] - center_[0], this.position_[1] + cameraPos_[1] - center_[1], this.position_[2] + cameraPos_[2] - center_[2]]);

    var angle_ = Math.atan2(this.position_[1] + cameraPos_[1] - center_[1], this.position_[0] + cameraPos_[0] - center_[0]);
    var idx_ = (Math.floor((angle_ + Math.PI) / Math.PI * 4));
    idx_ = Vadstena.clamp(idx_, 0, 7);

    // recurse to child nodes
    var childMax_ = 0;
    for (var i = 0; i < 4; i++)
    {
        var childIdx_ = ordering_[idx_][i];
        if (node_.childFlags_ & (1 << childIdx_))
        {
            childMax_ = Math.max(childMax_, this.drawSurface(tileId_.child(childIdx_)));
        }
    }

    //TODO: treeBuffer_

    return childMax_;
};

Vadstena.LayerTerrain.prototype.draw = function() {

    var maxPixelSize_ = this.drawSurface(this.browser_.mapConfig_.foat_);

    // we don't want QCache to delete items randomly in the download threads
    // so we explicitly trim the caches here, in the main thread
    this.metaCache_.trim(this.browser_.browserConfig_.cacheSize_ / 10);
    this.tileCache_.trim(this.browser_.browserConfig_.cacheSize_);

    return maxPixelSize_;
};


if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.LayerTerrain.prototype.surfaceHeightRecursive = function(geoPos_, tileId_, parentHeight_, metaCache_, maxLOD_)
{
    var node_ = (metaCache_.get(tileId_));

    // return the parent value if the metanode is not ready yet
    if (!node_) return [parentHeight_, tileId_.lod_ >= maxLOD_];

    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((geoPos_[0] - tileId_.easting_ ) / tileSize_);
    var y = ((geoPos_[1] - tileId_.northing_) / tileSize_);

    // do bilinear interpolation of the heightmap values
    var eps_ = 1e-4;
    x = Vadstena.clamp(x, 0.0, 1.0 - eps_);
    y = Vadstena.clamp(y, 0.0, 1.0 - eps_);

    var metaNodeHMSize_ = Vadstena.MetaNodeHMSize_;

    var hx = (x * (metaNodeHMSize_-1));
    var hy = (y * (metaNodeHMSize_-1));
    var ix = (Math.floor(hx)), iy = (Math.floor(hy));

    var v00 = (node_.heightmap_[iy*metaNodeHMSize_ + ix]);
    var v01 = (node_.heightmap_[iy*metaNodeHMSize_ + ix+1]);
    var v10 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix]);
    var v11 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix+1]);

    var fx = (hx - ix), fy = (hy - iy);
    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);
    var height_ = (w0 + (w1 - w0)*fy);

    // determine which child we need to go to next
    var childIdx_ = 0;
    if (y < 0.5) {
        childIdx_ = (x < 0.5) ? 0 : 1;
    } else {
        childIdx_ = (x < 0.5) ? 2 : 3;
    }

    // can't go deeper? this is the final value
    if (!(node_.childFlags_ & (1 << childIdx_)) || (tileId_.lod_ >= maxLOD_ && node_.hasGeometry() == true)) {
        return [height_, true];
    }

    // recurse to one of the children
    return this.surfaceHeightRecursive(geoPos_, tileId_.child(childIdx_), height_, metaCache_, maxLOD_);
};


Vadstena.LayerTerrain.prototype.surfaceHeight = function(geoPos_, metaCache_, maxLOD_)
{
    if (maxLOD_ == null) maxLOD_ = Number.MAX_VALUE;

    return this.surfaceHeightRecursive(geoPos_, this.browser_.mapConfig_.foat_, 0, metaCache_, maxLOD_);
};


Vadstena.LayerTerrain.prototype.surfaceHeightByPixelSizeRecursive = function(geoPos_, tileId_, parentHeight_, parentPixelSize_, metaCache_, maxPixelSize_, scalefactor_)
{
    var node_ = (metaCache_.get(tileId_));

    // return the parent value if the metanode is not ready yet
    if (!node_) return [parentHeight_, tileId_.lod_, false];

    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((geoPos_[0] - tileId_.easting_ ) / tileSize_);
    var y = ((geoPos_[1] - tileId_.northing_) / tileSize_);

    // do bilinear interpolation of the heightmap values
    var eps_ = 1e-4;
    x = Vadstena.clamp(x, 0.0, 1.0 - eps_);
    y = Vadstena.clamp(y, 0.0, 1.0 - eps_);

    var metaNodeHMSize_ = Vadstena.MetaNodeHMSize_;

    var hx = (x * (metaNodeHMSize_-1));
    var hy = (y * (metaNodeHMSize_-1));
    var ix = (Math.floor(hx)), iy = (Math.floor(hy));

    var v00 = (node_.heightmap_[iy*metaNodeHMSize_ + ix]);
    var v01 = (node_.heightmap_[iy*metaNodeHMSize_ + ix+1]);
    var v10 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix]);
    var v11 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix+1]);

    var fx = (hx - ix), fy = (hy - iy);
    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);
    var height_ = (w0 + (w1 - w0)*fy);

    // determine which child we need to go to next
    var childIdx_ = 0;
    if (y < 0.5) {
        childIdx_ = (x < 0.5) ? 0 : 1;
    } else {
        childIdx_ = (x < 0.5) ? 2 : 3;
    }

    var ndcToScreenPixel_ = (this.browser_.renderer_.curSize_[0] / 2.0);

    var pixelSize_ = (scalefactor_ * node_.pixelSize_[0][0] * ndcToScreenPixel_);


    // can't go deeper? this is the final value
    if (!(node_.childFlags_ & (1 << childIdx_)) || pixelSize_ <= maxPixelSize_) {

        var blendFactor_ = (maxPixelSize_ - pixelSize_) / (parentPixelSize_ - pixelSize_);
        var blendedHeight_ = (parentHeight_*(blendFactor_)) + (height_ * (1.0-blendFactor_));

        console.log("height-lod" + (tileId_.lod_-1) + " " + blendFactor_ + "  " + blendedHeight_);

        return [blendedHeight_, (tileId_.lod_-1), true];
    }

    // recurse to one of the children
    return this.surfaceHeightByPixelSizeRecursive(geoPos_, tileId_.child(childIdx_), height_, pixelSize_, metaCache_, maxPixelSize_, scalefactor_);
};


Vadstena.LayerTerrain.prototype.surfaceHeightByPixelSize = function(geoPos_, metaCache_, maxPixelSize_, camera_, distance_)
{
    var scalefactor_ = camera_.getProjectionMatrix()[0] / distance_;

    return this.surfaceHeightByPixelSizeRecursive(geoPos_, this.browser_.mapConfig_.foat_, 0, Number.MAX_VALUE, metaCache_, maxPixelSize_, scalefactor_);
};


Vadstena.LayerTerrain.prototype.surfacePixelSizeRecursive = function(geoPos_, tileId_, parentResult_, metaCache_, maxLOD_)
{
    var node_ = (metaCache_.get(tileId_));

    // return the parent value if the metanode is not ready yet
    if (!node_) return [parentResult_, tileId_.lod_ >= maxLOD_];

    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((geoPos_[0] - tileId_.easting_ ) / tileSize_);
    var y = ((geoPos_[1] - tileId_.northing_) / tileSize_);

    var renderer_ = this.browser_.renderer_;

    var worldMat_ = node_.getWorldMatrix(renderer_.position_, renderer_.pixelTileSizeMatrix_);
    var ndcToScreenPixel_ = (renderer_.curSize_[0] / 2.0);

    var result_ = 0;
    var hmw_ = Vadstena.MetaNodeHMSize_;
    var hms_ = Vadstena.MetaNodeHMSize_-1;

    for (var i = 0; i <= 1; i++) {
        for (var j = 0; j <= 1; j++) {
            //var pos_ = Vadstena.vec4.create([j, i, node_.heightmap_[i*hms_*hmw_+j*hms_], 1]);
            //var pos2_ = Vadstena.vec4.create();

            var pos_ = [j, i, node_.heightmap_[i*hms_*hmw_+j*hms_]];//, 1];
            var pos2_ = [];

            //Vadstena.mat4.multiplyVec4(worldMat_, pos_, pos2_);
            Vadstena.mat4.multiplyVec3(worldMat_, pos_, pos2_);

            var factor_ = renderer_.camera_.scaleFactor(pos2_);
            //var pixelSize_ = (factor_ * node_.pixelSize_[i][j] * ndcToScreenPixel_);
            var pixelSize_ = node_.pixelSize_[i][j];

            if (pixelSize_ > result_) result_ = pixelSize_;
        }
    }

    // determine which child we need to go to next
    var childIdx_ = 0;
    if (y < 0.5) {
        childIdx_ = (x < 0.5) ? 0 : 1;
    } else {
        childIdx_ = (x < 0.5) ? 2 : 3;
    }

    // can't go deeper? this is the final value
    if (!(node_.childFlags_ & (1 << childIdx_)) || tileId_.lod_ >= maxLOD_) {
        return [result_, true];
    }

    // recurse to one of the children
    return this.surfacePixelSizeRecursive(geoPos_, tileId_.child(childIdx_), result_, metaCache_, maxLOD_);
};


Vadstena.LayerTerrain.prototype.surfacePixelSize = function(geoPos_, metaCache_, maxLOD_)
{
    if (maxLOD_ == null) maxLOD_ = Number.MAX_VALUE;

    return this.surfacePixelSizeRecursive(geoPos_, this.browser_.mapConfig_.foat_, 0, metaCache_, maxLOD_);
};



Vadstena.LayerTerrain.prototype.surfaceTileRecursive = function(geoPos_, tileId_, parentResult_, metaCache_, maxLOD_)
{
    var node_ = (metaCache_.get(tileId_));

    // return the parent value if the metanode is not ready yet
    if (!node_) return [parentResult_, tileId_.lod_ >= maxLOD_];

    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((geoPos_[0] - tileId_.easting_ ) / tileSize_);
    var y = ((geoPos_[1] - tileId_.northing_) / tileSize_);

    // determine which child we need to go to next
    var childIdx_ = 0;
    if (y < 0.5) {
        childIdx_ = (x < 0.5) ? 0 : 1;
    } else {
        childIdx_ = (x < 0.5) ? 2 : 3;
    }

    // can't go deeper? this is the final value
    if (!(node_.childFlags_ & (1 << childIdx_)) || tileId_.lod_ >= maxLOD_) {
        return [{tileId_:tileId_, node_:node_}, true];
    }

    // recurse to one of the children
    return this.surfaceTileRecursive(geoPos_, tileId_.child(childIdx_), {tileId_:tileId_, node_:node_}, metaCache_, maxLOD_);
};


Vadstena.LayerTerrain.prototype.surfaceTile = function(geoPos_, metaCache_, maxLOD_)
{
    if (maxLOD_ == null) maxLOD_ = Number.MAX_VALUE;

    return this.surfaceTileRecursive(geoPos_, this.browser_.mapConfig_.foat_, {}, metaCache_, maxLOD_);
};


//TODO: remove duplicit ? same function is in metanode
Vadstena.LayerTerrain.prototype.surfaceTileHeight = function(geoPos_, tileId_, node_)
{
    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((geoPos_[0] - tileId_.easting_ ) / tileSize_);
    var y = ((geoPos_[1] - tileId_.northing_) / tileSize_);

    // do bilinear interpolation of the heightmap values
    var eps_ = 1e-4;
    x = Vadstena.clamp(x, 0.0, 1.0 - eps_);
    y = Vadstena.clamp(y, 0.0, 1.0 - eps_);

    var metaNodeHMSize_ = Vadstena.MetaNodeHMSize_;

    var hx = (x * (metaNodeHMSize_-1));
    var hy = (y * (metaNodeHMSize_-1));
    var ix = (Math.floor(hx)), iy = (Math.floor(hy));

    var v00 = (node_.heightmap_[iy*metaNodeHMSize_ + ix]);
    var v01 = (node_.heightmap_[iy*metaNodeHMSize_ + ix+1]);
    var v10 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix]);
    var v11 = (node_.heightmap_[(iy+1)*metaNodeHMSize_ + ix+1]);

    var fx = (hx - ix), fy = (hy - iy);
    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);
    var height_ = (w0 + (w1 - w0)*fy);

    return height_;
};


//! An index-less mesh. Each triangle has three items in the array 'vertices'.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.Mesh = function(browser_)
{
    this.vertices_ = [];
    this.tvertices_ = [];
    this.generateLines_ = true;
    this.browser_ = browser_;

    this.bbox_ = new Vadstena.BBox();
    this.size_ = 0;
    this.fileSize_ = 0;
};

Vadstena.Mesh.prototype.kill = function () {
    this.vertices_ = [];
    this.tvertices_ = [];
    this.bbox_ = null;
};

//! Reads the mesh from the binary representation.
Vadstena.Mesh.prototype.load = function (path_, onLoaded_, onError_) {

    var onLoadedLocal_ = (function(data_) {

        var timer_ = performance.now();

        this.fileSize_= data_.byteLength;

        var index_ = 0;

        // check header and version
        var USHRT_MAX = 65535;
        var factor_ = 1.0/65535;
        var magic_ = "";

        //read magic
        for (var i = 0; i < 8; i++) {
            magic_ += String.fromCharCode(data_.getUint8(index_, true)); index_ += 1;
        }


        if (magic_ != "BIN.MESH") {
            // "Bad binary mesh data_.";
            return;
        }

        //read version
        var version_ = data_.getUint32(index_, true); index_ += 4;

        if (version_ > 1) {
            //"Unsupported binary mesh format (" << version << ").";
            return;
        }

        // load bounding box
        for (var i = 0; i < 3; i++) {
            this.bbox_.min_[i] = data_.getFloat64(index_, true); index_ += 8;
        }
        for (var i = 0; i < 3; i++) {
            this.bbox_.max_[i] = data_.getFloat64(index_, true); index_ += 8;
        }

        // load vertices
        var count_ = data_.getUint16(index_, true); index_ += 2;
        var vtmp = new Array(count_ * 3);//[];

        for (var k = 0; k < count_; k++) {
            var kk = k * 3;
            vtmp[kk] = data_.getUint16(index_, true); index_ += 2;
            vtmp[kk+1] = data_.getUint16(index_, true); index_ += 2;
            vtmp[kk+2] = data_.getUint16(index_, true); index_ += 2;
        }

        // load texcoords
        count_ = data_.getUint16(index_, true); index_ += 2;
        var ttmp = new Array(count_ * 2);//[];

        for (var k = 0; k < count_; k++) {
            var kk = k * 2;
            ttmp[kk] = data_.getUint16(index_, true); index_ += 2;
            ttmp[kk+1] = USHRT_MAX - data_.getUint16(index_, true); index_ += 2;
        }

        // load faces
        count_ = data_.getUint16(index_, true); index_ += 2;
        this.vertices_ = new Array(count_*3*3);//[];
        this.tvertices_ = new Array(count_*3*2);//[];

        for (var k = 0; k < count_; k++) {
            for (var i = 0; i < 3; i++) {
                var vindex_ = 3*data_.getUint16(index_, true); index_ += 2;
                var tvIndex = 3*3*k+i*3;
                this.vertices_[tvIndex] = vtmp[vindex_]*factor_;
                this.vertices_[tvIndex+1] = vtmp[vindex_+1]*factor_;
                this.vertices_[tvIndex+2] = vtmp[vindex_+2]*factor_;
            }
            for (var i = 0; i < 3; i++) {
                var vindex_ = 2*data_.getUint16(index_, true); index_ += 2;
                var tvIndex = 3*2*k+i*2;
                this.tvertices_[tvIndex] = ttmp[vindex_]*factor_;
                this.tvertices_[tvIndex+1] = ttmp[vindex_+1]*factor_;
            }
        }

        this.size_ = (this.vertices_.length + this.tvertices_.length) * 8 + 7 * 8;

        //if (this.browser_.renderer_ != null) {
        this.browser_.renderer_.statsCreateMeshTime_ += performance.now() - timer_;
        //}

        if (onLoaded_ != null) {
            onLoaded_();
        }

    }).bind(this);

    var onErrorLocal_ = (function() {
        if (onError_ != null) {
            onError_();
        }
    }).bind(this);

    Vadstena.loadBinary(path_, onLoadedLocal_, onErrorLocal_);
};

//! Returns RAM usage in bytes.
Vadstena.Mesh.prototype.size = function () {
    return this.size_;
};

Vadstena.Mesh.prototype.fileSize = function () {
    return this.fileSize_;
};

//! Procedural mesh representing a heightmap block
//! Creates a grid of size x size vertices, all coords are [0..1].
Vadstena.Mesh.prototype.buildHeightmap = function(size_)
{
    size_--;

    var USHRT_MAX = 65535;

    for (var i = 0; i < size_; i++)
    {
        for (var j = 0; j < size_; j++)
        {
            var x1 = ((j) / size_);
            var x2 = ((j+1) / size_);

            var y1 = ((i) / size_);
            var y2 = ((i+1) / size_);

            this.vertices_.push(x1, y1, 0);
            this.vertices_.push(x2, y1, 0);
            this.vertices_.push(x2, y2, 0);
            this.tvertices_.push(x1, y1);
            this.tvertices_.push(x2, y1);
            this.tvertices_.push(x2, y2);

            this.vertices_.push(x2, y2, 0);
            this.vertices_.push(x1, y2, 0);
            this.vertices_.push(x1, y1, 0);
            this.tvertices_.push(x2, y2);
            this.tvertices_.push(x1, y2);
            this.tvertices_.push(x1, y1);
        }
    }

    this.bbox_.min_[0] = this.bbox_.min_[1] = this.bbox_.min_[2] = 0.0;
    this.bbox_.max_[0] = this.bbox_.max_[1] = this.bbox_.max_[2] = 1.0;


    this.size_ = (this.vertices_.length + this.tvertices_.length) * 8 + 7 * 8;
};


Vadstena.spherePos = function(lon_, lat_)
{
    lat_ *= Math.PI;
    lon_ *= 2*Math.PI;

    return [Math.cos(lon_)*Math.sin(lat_)*0.5 + 0.5,
                Math.sin(lon_)*Math.sin(lat_)*0.5 + 0.5,
                Math.cos(lat_) * 0.5 + 0.5];
};


//! Creates an approximation of a unit sphere, note that all coords are
//! in the range [0..1] and the center is in (0.5, 0.5). Triangle "normals"
//! are oriented inwards.
Vadstena.Mesh.prototype.buildSkydome = function(latitudeBands_, longitudeBands_) {

    for (var lat_ = 0; lat_ < latitudeBands_; lat_++) {
        for (var lon_ = 0; lon_ < longitudeBands_; lon_++)
        {
            var lon1_ = ((lon_) / longitudeBands_);
            var lon2_ = ((lon_+1) / longitudeBands_);

            var lat1_ = ((lat_) / latitudeBands_);
            var lat2_ = ((lat_+1) / latitudeBands_);

            this.makeQuad(lon1_, lat1_, lon2_, lat2_);
        }
    }

    this.bbox_.min_[0] = this.bbox_.min_[1] = this.bbox_.min_[2] = 0.0;
    this.bbox_.max_[0] = this.bbox_.max_[1] = this.bbox_.max_[2] = 1.0;
};

Vadstena.Mesh.prototype.makeQuad = function(lon1_, lat1_, lon2_, lat2_) {
    var a = Vadstena.spherePos(lon1_, lat1_), ta = [lon1_, lat1_];
    var b = Vadstena.spherePos(lon1_, lat2_), tb = [lon1_, lat2_];
    var c = Vadstena.spherePos(lon2_, lat1_), tc = [lon2_, lat1_];
    var d = Vadstena.spherePos(lon2_, lat2_), td = [lon2_, lat2_];

    this.vertices_.push(b[0], b[1], b[2]);
    this.vertices_.push(a[0], a[1], a[2]);
    this.vertices_.push(c[0], c[1], c[2]);
    this.tvertices_.push(tb[0], tb[1]);
    this.tvertices_.push(ta[0], ta[1]);
    this.tvertices_.push(tc[0], tc[1]);

    this.vertices_.push(c[0], c[1], c[2]);
    this.vertices_.push(d[0], d[1], d[2]);
    this.vertices_.push(b[0], b[1], b[2]);
    this.tvertices_.push(tc[0], tc[1]);
    this.tvertices_.push(td[0], td[1]);
    this.tvertices_.push(tb[0], tb[1]);

    this.size_ = (this.vertices_.length + this.tvertices_.length) * 8 + 7 * 8;
};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.TileType = {
    Terrain : 0,
    Heightmap : 1,
    TerrainTexture : 2,
    HeightmapTexture : 3,
    Geodata : 4
};


/**
 * @constructor
 */
Vadstena.Planet = function(renderer_)
{
    this.gpu_ = renderer_.gpu_;
    this.gl_ = this.gpu_.gl_;
    this.browser_ = renderer_.browser_;
    this.renderer_ = renderer_;
    this.layerCounter_ = 0;

    this.tiledLayers_ = [];
    this.terrainLayers_ = [];
    this.layers_ = [];

    this.jobZBuffer_ = new Array(512);
    this.jobZBufferSize_ = new Array(512);

    this.terrainTileBuffer_ = new Array(4000);
    this.terrainTileBufferSize_ = 0;
    this.terrainTileBufferLastSize_ = 0;

    this.terrainTiles_ = 0;


    for (var i = 0, li = this.jobZBuffer_.length; i < li; i++) {
        this.jobZBuffer_[i] = [];
        this.jobZBufferSize_[i] = 0;
    }

/*
    this.terrainTreeBuffer_ = new Array(4000);
    this.terrainTreeBufferSize_ = 0;
    this.terrainTreeBufferLastSize_ = 0;
*/
    //initialize buffer
    //for (var i = 0, li = this.terrainTileBuffer_.length; i < li; i++) {
      //  this.terrainTileBuffer_[i] = [null, null, null];
    //}

};

Vadstena.Planet.prototype.kill = function()
{
    for (var i = 0, li = this.layers_.length; i < li; i++) {
        this.layers_[i].kill();
    }

    for (var i = 0, li = this.tiledLayers_.length; i < li; i++) {
        this.tiledLayers_[i].kill();
    }

    for (var i = 0, li = this.terrainLayers_.length; i < li; i++) {
        this.terrainLayers_[i].kill();
    }
};

Vadstena.Planet.prototype.addTiledTerrainLayer = function(id_, group_, visible_)
{
    this.terrainLayers_.push(new Vadstena.LayerTerrain(this, id_, group_, visible_));
    this.layerCounter_++;
};

Vadstena.Planet.prototype.addTiledLayer = function(id_, type_, urlTemplate_, minLod_, maxLod_, tilePixels_, style_, tags_, visible_)
{
    this.tiledLayers_.push(new Vadstena.LayerTilled(this, id_, type_, urlTemplate_, minLod_, maxLod_, tilePixels_, style_, tags_, visible_));
    this.layerCounter_++;
};

Vadstena.Planet.prototype.addLayer = function(id_, tags_, geodata_, minLod_, maxLod_, tilePixels_, generateLods_, style_, visible_)
{
    this.layers_.push(new Vadstena.Layer(this, id_, "geodata", geodata_, minLod_, maxLod_, tilePixels_, generateLods_, style_, tags_, visible_));
    this.layerCounter_++;
};

Vadstena.Planet.prototype.removeTiledTerrainLayer = function(id_)
{
    for (var i = 0; i < this.terrainLayers_.length; i++) {
        if (this.terrainLayers_[i].id_ == id_) {
            this.terrainLayers_.splice(i, 1);
            this.renderer_.dirty_ = true;
            i--;
        }
    }
};

Vadstena.Planet.prototype.removeTiledLayer = function(id_)
{
    for (var i = 0; i < this.tiledLayers_.length; i++) {
        if (this.tiledLayers_[i].id_ == id_) {
            this.tiledLayers_.splice(i, 1);
            this.renderer_.dirty_ = true;
            i--;
        }
    }
};

Vadstena.Planet.prototype.removeLayer = function(id_)
{
    for (var i = 0; i < this.layers_.length; i++) {
        if (this.layers_[i].id_ == id_) {
            this.layers_.splice(i, 1);
            this.renderer_.dirty_ = true;
            i--;
        }
    }
};

Vadstena.Planet.prototype.showTiledLayer = function(id_, state_)
{
    for (var i = 0, li = this.tiledLayers_.length; i < li; i++) {
        if (this.tiledLayers_[i].id_ == id_) {
            this.tiledLayers_[i].setVisible(state_);
        }
    }
};

Vadstena.Planet.prototype.showLayer = function(id_, state_)
{
    for (var i = 0, li = this.layers_.length; i < li; i++) {
        if (this.layers_[i].id_ == id_) {
            this.layers_[i].setVisible(state_);
        }
    }
};

Vadstena.Planet.prototype.showTiledLayerGroup = function(id_, state_)
{
    if (this.renderer_.layerGroupVisible_[id_] != state_) {
        this.renderer_.layerGroupVisible_[id_] = state_;
        this.renderer_.dirty_ = true;
    }
};

Vadstena.Planet.prototype.showLayerGroup = function(id_, state_)
{
    if (this.renderer_.layerGroupVisible_[id_] != state_) {
        this.renderer_.layerGroupVisible_[id_] = state_;
        this.renderer_.dirty_ = true;
    }
};

Vadstena.Planet.prototype.showTiledLayerGroupsByTag = function(tag_, state_)
{
    this.renderer_.layerGroupTagVisible_[tag_] = state_;
};

Vadstena.Planet.prototype.showLayerGroupsByTag = function(tag_, state_)
{
    this.renderer_.layerGroupTagVisible_[tag_] = state_;
};

Vadstena.Planet.prototype.setLayerGroupTransform = function(id_, position_, yaw_, scale_)
{
    var o = this.renderer_.layerGroupTransform_[id_];

    if (o == null || o[0] != position_[0] || o[1] != position_[1] || o[2] != position_[2]) {
        var mv_ = Vadstena.mat4.create();
        Vadstena.mat4.multiply(Vadstena.rotationMatrix(2, Vadstena.radians(yaw_)), Vadstena.scaleMatrix(scale_, scale_, 1), mv_);
        this.renderer_.layerGroupTransform_[id_] = [mv_, [position_[0], position_[1], position_[2]]];
        this.renderer_.dirty_ = true;
    }
};

Vadstena.Planet.prototype.setTiledLayerGroupOrigin = function(id_, positon_)
{
    this.setLayerGroupOrigin(id_, position_);
};

Vadstena.Planet.prototype.getMainTerrain = function() {
    return this.terrainLayers_[0];
};

Vadstena.Planet.prototype.getTileBuffer = function() {
    return this.terrainTileBuffer_;
};

Vadstena.Planet.prototype.getTileBufferSize = function() {
    return this.terrainTileBufferSize_;
};

Vadstena.Planet.prototype.surfaceHeight = function(geoPos_, maxLOD_)
{
    var terrain_ = this.getMainTerrain();
    return terrain_.surfaceHeight(geoPos_, terrain_.metaCache_, maxLOD_);
};

Vadstena.Planet.prototype.calculateMinDistance = function(tileId_, camera_)
{
    return this.getMainTerrain().calculateMinDistance(tileId_, camera_);
};

Vadstena.Planet.prototype.calculateResolution = function(tileId_)
{
    return this.getMainTerrain().calculateResolution(tileId_);
};

Vadstena.Planet.prototype.update = function()
{
    for (var i = 0, li = this.terrainLayers_.length; i < li; i++) {
        this.terrainLayers_[i].update();
    }

    for (var i = 0, li = this.tiledLayers_.length; i < li; i++) {
        this.tiledLayers_[i].update();
    }

    for (var i = 0, li = this.layers_.length; i < li; i++) {
        this.layers_[i].update();
    }
};

Vadstena.Planet.prototype.draw = function()
{
    this.update();

    this.terrainTileBufferSize_  = 0;

    var maxPixelSize_ =  99;

    //draw terrain layers
    for (var i = 0, li = this.terrainLayers_.length; i < li; i++) {
        maxPixelSize_ = this.terrainLayers_[i].draw();
    }

    this.terrainTiles_ = this.terrainTileBufferSize_;

    //draw geo layers
    for (var j = 0, lj = this.tiledLayers_.length; j < lj; j++) {
        this.tiledLayers_[j].draw();
    }

    //remove old tiles from tile buffer
    if (this.terrainTileBufferLastSize_ > this.terrainTileBufferSize_) {
        for (var i = this.terrainTileBufferSize_; i < this.terrainTileBufferLastSize_; i++) {
            this.terrainTileBuffer_[i] = null;
        }
    }

    this.terrainTileBufferLastSize_ = this.terrainTileBufferSize_;

    return maxPixelSize_;
};












if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

//! maximum allowed projected texel size (affects LOD selection, i.e., display
//! quality, and also control constraints)
Vadstena.resolutionThreshold_ = 1.1;
Vadstena.texelSizeFactor_ = 1.0;
Vadstena.noTextures_ = false;

Vadstena.StencilLineState_ = null;

/**
 * @constructor
 */
Vadstena.Renderer = function(browser_, div_, onUpdate_, keepFrameBuffer_)
{
    this.browser_ = browser_;
    this.progTile_ = null;
    this.progHeightmap_ = null;
    this.progSkydome_ = null;
    this.progWireframeTile_ = null;
    this.progWireframeTile2_ = null;
    this.progText_ = null;
    this.div_ = div_;
    this.onUpdate_ = onUpdate_;
    this.killed_ = false;
    this.onlyDepth_ = false;
    this.onlyLayers_ = false;
    this.onlyHitLayers_ = false;
    this.hoverFeature_ = null;
    this.hoverFeatureId_ = null;
    this.lastHoverFeature_ = null;
    this.lastHoverFeatureId_ = null;
    this.hoverFeatureCounter_ = 0;
    this.hoverFeatureList_ = [];
    this.renderCounter_ = 1;
    this.hitmapCounter_ = 0;
    this.geoHitmapCounter_ = 0;
    this.clearStencilPasses_ = [];

    this.clickEvent_ = null;
    this.hoverEvent_ = null;
    this.touchSurfaceEvent_ = [];

    var rect_ = this.div_.getBoundingClientRect();

    this.winSize_ = [rect_.width, rect_.height]; //QSize
    this.curSize_ = [rect_.width, rect_.height]; //QSize
    this.lastPos_ = [0,0]; //QPoint
    this.tilting_ = false;
    this.heightInitialized_ = true;
    this.dirty_ = true;
    this.motion_ = 1.0;
    this.minHeight_ = -1000.0;
    this.cameraMinDistance_ = this.browser_.browserConfig_.cameraMinDistance_;
    this.cameraMinDesiredDistance_ = this.cameraMinDistance_;
    this.cameraConstrainDistance_ = this.browser_.browserConfig_.cameraConstrainDistance_ * 0.5;
    this.cameraHeightOffset_ = 0;
    this.cameraHeightOffset2_ = 0;
    this.cameraHeightCorrection_ = 0;
    this.cameraVector_ = [0,1,0];
    this.texelSizeLimit_ = this.browser_.mapConfig_.texelSize_ * Vadstena.texelSizeFactor_;
    this.gsd_ = 0.02;
    this.noForwardMovement_ = true;
    this.heightLod_ = this.browser_.browserConfig_.heightLod_;

    this.gpu_ = new Vadstena.GpuDevice(div_, this.curSize_, keepFrameBuffer_);

    this.camera_ = new Vadstena.Camera(this, this.browser_.browserConfig_.cameraFOV_, 2, this.browser_.browserConfig_.cameraVisibility_);
    this.position_ = [this.browser_.mapConfig_.defaultPosition_[0], this.browser_.mapConfig_.defaultPosition_[1], this.browser_.mapConfig_.defaultPosition_[2]];
    this.orientation_ = [this.browser_.mapConfig_.defaultOrientation_[0], this.browser_.mapConfig_.defaultOrientation_[1], this.browser_.mapConfig_.defaultOrientation_[2]];
    this.lastHeight_ = 0;
    this.lastLod_ = 0;
    this.heightCorrection_ = 0;

    this.edgesX_ = [];
    this.edgesY_ = [];
    this.previousEdgesX_ = [];
    this.previousEdgesY_ = [];

    //reduce garbage collection
    this.drawTileMatrix_ = Vadstena.mat4.create();
    this.drawTileMatrix2_ = Vadstena.mat4.create();
    this.drawTileVec_ = [0,0,0];
    this.drawTileWorldMatrix_ = Vadstena.mat4.create();
    this.pixelTileSizeMatrix_ = Vadstena.mat4.create();

    this.gpuCache_ = new Vadstena.GpuCache(this.gpu_, this.browser_, this.browser_.browserConfig_.gpuCacheSize_);

    this.heightmapMesh_ = null;
    this.heightmapTexture_ = null;

    this.skydomeMesh_ = null;
    this.skydomeTexture_ = null;

    this.hitmapTexture_ = null;
    this.geoHitmapTexture_ = null;
    this.hitmapSize_ = this.browser_.browserConfig_.hitTextureSize_;
    this.updateHitmap_ = true;
    this.updateGeoHitmap_ = true;

    this.redTexture_ = null;

    this.rectVerticesBuffer_ = null;
    this.rectIndicesBuffer_ = null;
    this.imageProjectionMatrix_ = null;

    //debug switchs
    this.heightmapOnly_ = false;
    this.blendHeightmap_ = true;
    this.drawBBoxes_ = false;
    this.drawLods_ = false;
    this.drawPositions_ = false;
    this.drawTexelSize_ = false;
    this.drawWireframe_ = 0;
    this.drawFaceCount_ = false;
    this.drawDistance_ = false;
    this.drawMaxLod_ = false;
    this.drawTextureSize_ = false;
    this.drawLayers_ = true;
    this.ignoreTexelSize_ = false;
    this.drawFog_ = true;

    this.displayDrawTest_ = false;

    //stats
    this.updateStats_ = true;
    this.statsElement_ = document.getElementById("vadstena-engine-render-stats");
    this.statsCycle_ = 0;
    this.statsCycle2_ = 0;
    this.renderedTiles_ = 0;
    this.renderedHTiles_ = 0;
    this.renderedPolygons_ = 0;
    this.renderTime_ = 0;
    this.renderTimeTmp_ = 0;
    this.renderTimeTmp2_ = 0;
    this.renderLODs_ = [];
    this.renderMeshFileSize_ = 0;
    this.renderImageFileSize_ = 0;
    this.lastTimer_ = null;
    this.fps_ = 0;
    this.gpuMemoryUsed_ = 0;
    this.gpuMemoryTextures_ = 0;
    this.gpuMemoryMeshes_ = 0;

    this.recordStats_ = false;
    this.statsCanvasRender_ = document.getElementById("vadstena-engine-stats-render");
    this.statsCanvasCache_ = document.getElementById("vadstena-engine-stats-cache");
    this.statsTimeIndex_ = 0;
    this.statsLastTimeIndex_ = 0;
    this.statsTimeSamples_ = 500;
    this.statsRenderTimes_ = new Array(this.statsTimeSamples_);
    this.statsCreateMeshTimes_ = new Array(this.statsTimeSamples_);
    this.statsCreateGpuMeshTimes_ = new Array(this.statsTimeSamples_);
    this.statsCreateTextureTimes_ = new Array(this.statsTimeSamples_);
    this.statsFrameGapTimes_ = new Array(this.statsTimeSamples_);
    this.statsGpuMemory_ = new Array(this.statsTimeSamples_);
    this.statsGpuMemoryUsed_ = new Array(this.statsTimeSamples_);
    this.statsGpuMemoryTextures_ = new Array(this.statsTimeSamples_);
    this.statsGpuMemoryMeshes_ = new Array(this.statsTimeSamples_);
    this.statsPolygons_ = new Array(this.statsTimeSamples_);
    this.statsLODs_ = new Array(this.statsTimeSamples_);
    this.statsFluxTextures_ = new Array(this.statsTimeSamples_);
    this.statsFluxMeshes_ = new Array(this.statsTimeSamples_);
    this.statsFluxTexture_ = [[0,0],[0,0]];
    this.statsFluxMesh_ = [[0,0],[0,0]];
    this.statsCreateTextureTime_ = 0;
    this.statsCreateGpuMeshTime_ = 0;
    this.statsCreateMeshTime_ = 0;
    this.resetStats();

    this.layers_ = [];
    this.layerIcons_ = [];
    this.layerPlaces_ = [];
    this.bitmaps_ = [];
    this.font_ = null;
    this.placemarkTexture_ = null;
    this.layerGroupVisible_ = [];
    this.layerGroupTransform_ = [];
    this.gpuTilesWaiting_ = [];
    this.gpuTilesWaitingSize_ = 0;

    //hack for melown maps
    //this.melownHack_ = true;
    //this.melownHack_ = false;

    //reduce garbage collection
    this.updateCameraMatrix_ = Vadstena.mat4.create();

    //debug
    this.lastHitPosition_ = [0,0,100];
    this.logTilePos_ = null;

    window.addEventListener("resize", (this.onResize).bind(this), false);

    this.initializeGL();

    if (window["VadstenaMobile_"] == true && this.gpu_.canvas_ != null) {
        this.gpu_.canvas_.style.width = "100%";
        this.gpu_.canvas_.style.height = "100%";
    }

    var factor_ = window["VadstenaScreenScaleFactor_"];
    this.resizeGL(Math.floor(this.curSize_[0]*factor_), Math.floor(this.curSize_[1]*factor_));

    this.planet_ = new Vadstena.Planet(this);
    this.planet_.addTiledTerrainLayer("terrain");


    //start heartbeat
    window.requestAnimFrame(this.update.bind(this));
};

Vadstena.Renderer.prototype.onResize = function()
{
    if (this.killed_ == true){
        return;
    }

    var rect_ = this.div_.getBoundingClientRect();
    var factor_ = window["VadstenaScreenScaleFactor_"];
    this.resizeGL(Math.floor(rect_.width*factor_), Math.floor(rect_.height*factor_));
};

Vadstena.Renderer.prototype.kill = function()
{
    if (this.killed_ == true){
        return;
    }

    this.killed_ = true;

    if (this.planet_ != null) {
        this.planet_.kill();
    }

    this.gpuCache_.reset();

    if (this.heightmapMesh_ != null) this.heightmapMesh_.kill();
    if (this.heightmapTexture_ != null) this.heightmapTexture_.kill();
    if (this.skydomeMesh_ != null) this.skydomeMesh_.kill();
    if (this.skydomeTexture_ != null) this.skydomeTexture_.kill();
    if (this.hitmapTexture_ != null) this.hitmapTexture_.kill();
    if (this.geoHitmapTexture_ != null) this.geoHitmapTexture_.kill();

    this.div_.removeChild(this.gpu_.getCanvas());
};


Vadstena.Renderer.prototype.getPlanet = function()
{
    return this.planet_;
};

Vadstena.Renderer.prototype.resizeGL = function(width_, height_, skipCanvas_, skipPaint_)
{
    this.camera_.setAspect(width_ / height_);
    this.curSize_ = [width_, height_];
    this.gpu_.resize(this.curSize_, skipCanvas_);

    if (skipPaint_ != true) {
        this.paintGL();
    }

    var m = [];
    m[0] = 2.0/width_; m[1] = 0; m[2] = 0; m[3] = 0;
    m[4] = 0; m[5] = -2.0/height_; m[6] = 0; m[7] = 0;
    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
    m[12] = -width_*0.5*m[0]; m[13] = -height_*0.5*m[5]; m[14] = 0; m[15] = 1;

    this.imageProjectionMatrix_ = m;
};


Vadstena.Renderer.prototype.update = function()
{
    if (this.killed_ == true){
        return;
    }

    if (this.div_ != null && this.div_.style.visibility == "hidden"){

        //loop heartbeat
        window.requestAnimFrame(this.update.bind(this));
        return;
    }

    var rect_ = this.div_.getBoundingClientRect();

    if (this.curSize_[0] != rect_.width || this.curSize_[1] != rect_.height) {
        this.onResize();
    }

    if (this.onUpdate_ != null) { // && this.dirty_ == true) {
        this.onUpdate_();
    }

    this.planet_.update();

    if (this.updateStats_ == true) {
        this.renderedTiles_ = 0;
        this.renderedHTiles_ = 0;
        this.renderedPolygons_ = 0;
        this.renderLODs_ = [];
        this.renderMeshFileSize_ = 0;
        this.renderImageFileSize_ = 0;
        this.gpuMemoryUsed_ = 0;
        this.gpuMemoryTextures_ = 0;
        this.gpuMemoryMeshes_ = 0;

        this.statsCycle_++;

        var timer_ = performance.now();// Date.now();

        if (this.lastGapTimer_ != null) {

            if (this.recordStats_ == true) {
                this.statsFrameGapTimes_[this.statsTimeIndex_] = (timer_ - this.lastGapTimer_);
            }
        }

        this.lastGapTimer_ = timer_;


        if (this.statsCycle_ >= 10) {

            if (this.lastTimer_ != null) {
                var fps_ = (1000/(timer_ - this.lastTimer_)) * this.statsCycle_;
                this.fps_ = (fps_ + this.fps_) * 0.5;
            }

            this.lastTimer_ = timer_;
        }
    }

    var renderTimer_ = performance.now();

    switch (this.browser_.browserConfig_.cameraConstrainMode_) {

        case "aboveTerrainByPixelSize":
            var ndcToScreenPixel_ = (this.curSize_[0] / 2.0);
            this.cameraMinDistance_ = this.camera_.getProjectionMatrix()[0] * this.texelSizeLimit_ * ndcToScreenPixel_;// * 2;
            this.cameraConstrainDistance_ = this.cameraMinDistance_ * 0.5;
            break;

        case "aboveTerrainByGSD":

            var tile_ = Vadstena.surfaceTile(this.browser_, this.position_, this.metaCache_, null)[0];
            var gsd_ = 0.02;

            if (tile_ != null && tile_.node_ != null && tile_.node_.gsd_ != -1) {
                gsd_ = tile_.node_.gsd_;
            }

            if (gsd_ == 50) {
                gsd_ = 15;
            }

            var update_ = false;

            if (Math.abs(this.gsd_, gsd_) > 0.001) {

                if (this.gsd_ > gsd_) {
                    this.gsd_ = gsd_;
                } else {
                    //slowly fade to new min distance
                    this.gsd_ = Math.min(gsd_, (this.gsd_) * 1.07);
                }

                update_ = true;

            } else {
                this.gsd_ = gsd_;
            }

            var ndcToScreenPixel_ = (this.curSize_[0] / 2.0);
            this.cameraMinDistance_ = this.camera_.getProjectionMatrix()[0] * this.gsd_ * ndcToScreenPixel_;// * 2;
            this.cameraConstrainDistance_ = this.cameraMinDistance_ * 0.5;

            if (update_ == true) {
                this.constrainCamera();
            }

            //console.log("gsd: " + this.gsd_);

            break;

        //console.log("minDist: " + this.cameraMinDistance_);
    }

    if (this.clickEvent_ != null || this.hoverEvent_ != null) {
        if (this.renderCounter_ != this.geoHitmapCounter_) {
            this.dirty_ = true;
        }
    }

    if (this.dirty_ == true) {

        this.renderCounter_++;
        //this.hitmapCounter_ = 0;
        //this.geoHitmapCounter_ = 0;

        //reset gpu waiting tiles buffer
        for (var i = 0; i < this.gpuTilesWaitingSize_; i++) {
            this.gpuTilesWaiting_[i] = null;
        }
        this.gpuTilesWaitingSize_ = 0;


        this.gpu_.setViewport();

        if (this.clickEvent_ != null || this.hoverEvent_ != null) {
            this.updateGeoHitmap_ = true;
            this.geoHitmapCounter_ = this.renderCounter_;
            //console.log("geoRRRRRR");
        }

        this.updateHitmap_ = true;

        this.paintGL();

        if (this.onlyDepth_ != true && this.onlyHitLayers_ != true) {
            //this.drawImage(300, 0, 256, 256, this.hitmapTexture_);
            //this.drawImage(100, 0, 256, 256, this.geoHitmapTexture_);
            //this.drawImage(100, 0, 512, 512, this.geoHitmapTexture_);
        }
    } else {

        //check waiting gpu tiles
        for (var i = 0; i < this.gpuTilesWaitingSize_; i++) {
            this.gpuTilesWaiting_[i].isReady();
        }

    }

    if (this.updateStats_ == true) {
        this.statsCycle2_++;

        var renderTime_ = performance.now() - renderTimer_;

        if (this.recordStats_ == true) {
            this.statsRenderTimes_[this.statsTimeIndex_] = renderTime_;
            this.statsCreateTextureTimes_[this.statsTimeIndex_] = this.statsCreateTextureTime_;
            this.statsCreateMeshTimes_[this.statsTimeIndex_] = this.statsCreateMeshTime_;
            this.statsCreateGpuMeshTimes_[this.statsTimeIndex_] = this.statsCreateGpuMeshTime_;

            if (this.dirty_ == true) {
                this.statsGpuMemory_[this.statsTimeIndex_] = this.gpuCache_.size()/(1024*1024);
                this.statsGpuMemoryUsed_[this.statsTimeIndex_] = this.gpuMemoryUsed_/(1024*1024);
                this.statsGpuMemoryTextures_[this.statsTimeIndex_] = this.gpuMemoryTextures_/(1024*1024);
                this.statsGpuMemoryMeshes_[this.statsTimeIndex_] = this.gpuMemoryMeshes_/(1024*1024);
                this.statsPolygons_[this.statsTimeIndex_] = this.renderedPolygons_;
                this.statsLODs_[this.statsTimeIndex_] = [(this.renderedTiles_ + this.renderedHTiles_), this.renderLODs_];
                this.statsFluxTextures_[this.statsTimeIndex_] = this.statsFluxTexture_;
                this.statsFluxMeshes_[this.statsTimeIndex_] = this.statsFluxMesh_;
            } else {
                this.statsGpuMemory_[this.statsTimeIndex_] = this.statsGpuMemory_[this.statsLastTimeIndex_];
                this.statsGpuMemoryUsed_[this.statsTimeIndex_] = this.statsGpuMemoryUsed_[this.statsLastTimeIndex_];
                this.statsGpuMemoryTextures_[this.statsTimeIndex_] = this.statsGpuMemoryTextures_[this.statsLastTimeIndex_];
                this.statsGpuMemoryMeshes_[this.statsTimeIndex_] = this.statsGpuMemoryMeshes_[this.statsLastTimeIndex_];
                this.statsPolygons_[this.statsTimeIndex_] = this.statsPolygons_[this.statsLastTimeIndex_];
                this.statsLODs_[this.statsTimeIndex_] = this.statsLODs_[this.statsLastTimeIndex_];
                this.statsFluxTextures_[this.statsTimeIndex_] = this.statsFluxTextures_[this.statsLastTimeIndex_];
                this.statsFluxMeshes_[this.statsTimeIndex_] = this.statsFluxMeshes_[this.statsLastTimeIndex_];
            }

            this.statsCreateTextureTime_ = 0;
            this.statsCreateGpuMeshTime_ = 0;
            this.statsCreateMeshTime_ = 0;
            this.statsFluxTexture_ = [[0,0],[0,0]];
            this.statsFluxMesh_ = [[0,0],[0,0]];

            this.statsLastTimeIndex_ = this.statsTimeIndex_;
            this.statsTimeIndex_++;

            if (this.statsTimeIndex_ >= this.statsTimeSamples_) {
                this.statsTimeIndex_ = 0;
            }
        }

        this.renderTimeTmp_ += renderTime_;

        if (this.statsCycle2_ >= 100) {
            this.renderTime_ = this.renderTimeTmp_ / this.statsCycle2_;
            this.renderTimeTmp_ = 0;
            this.statsCycle2_ = 0;
        }

        if (this.statsElement_ != null) {
            if (this.statsCycle_ >= 10) {
                this.statsCycle_ = 0;

                if (this.dirty_ == true) {
                    var text2_ =
                            "FPS: " + Math.round(this.fps_) + "<br/>" +
                            "Render time: " + Math.round(this.renderTime_*1000) + "<br/>" +
                            //"Tile cache: " + Math.round(this.tileCache_.size()/(1024*1024)) + "MB<br/>" +
                            //"Metatile cache: " + Math.round(this.metaCache_.size()/(1024*1024)) + "MB<br/>" +
                            //"GPU cache: " + Math.round(this.gpuCache_.size()/(1024*1024)) + "MB<br/>" +
                            "- used: " + Math.round(this.gpuMemoryUsed_/(1024*1024)) + "MB<br/>" +
                            "- used textures: " + Math.round(this.gpuMemoryTextures_/(1024*1024)) + "MB<br/>" +
                            "- used meshes: " + Math.round(this.gpuMemoryMeshes_/(1024*1024)) + "MB<br/>" +
                            "Polygons: " + (this.renderedPolygons_) + "<br/>";
                            //"Texture files size: " + Math.round(this.renderImageFileSize_/(1024*1024)) + "MB<br/>" +
                            //"Mesh files size: " + Math.round(this.renderMeshFileSize_/(1024*1024)) + "MB<br/>";


                    var text3_ = "Tiles: " + (this.renderedTiles_ + this.renderedHTiles_) +"<br/>";

                    for (var i in this.renderLODs_) {
                        text3_ += "LOD" + i + ": " + this.renderLODs_[i] + "<br/>";
                    }

                    var text_ = "<table style='width:305px'><tr><td>" + text2_ + "</td><td>" + text3_ + "</td></tr></table>";

                    this.statsElement_.innerHTML = text_;
                }
            }
        }
    }

    this.dirty_ = false;

    //hover and click events
    if (this.clickEvent_ != null || this.hoverEvent_ != null) {
        //this.updateGeoHitmap_ = this.dirty_;

        if (this.hoverEvent_ != null) {
            var result_ = this.hitTestGeoLayers(this.hoverEvent_[0], this.hoverEvent_[1], "hover");

            if (result_[1] == true && result_[0] != null) {
                this.browser_.callListener("geo-feature-hover", {"feature": result_[0][0], "screen-pos":this.project(result_[0][1]),
                                                                 "scene-pos":result_[0][1], "state": this.hoverEvent_[3] });
            }

            var relatedEvents_ = result_[2];

            if (relatedEvents_ != null) {
                for(var i = 0, li = relatedEvents_.length; i < li; i++) {
                    var event_ = relatedEvents_[i];

                    switch(event_[0]) {
                        case "enter":
                            this.browser_.callListener("geo-feature-enter", {"feature": event_[0], "screen-pos":this.project(event_[1]),
                                                                             "scene-pos":event_[1], "state": this.hoverEvent_[3] });
                            break;

                        case "leave":
                            this.browser_.callListener("geo-feature-leave", {"feature":event_[0], "screen-pos":this.project(event_[1]),
                                                                             "scene-pos":event_[1], "state": this.hoverEvent_[3] });
                            break;
                    }
                }
            }

            //is it persistent event?
            if (this.hoverEvent_[2] != true) {
                this.hoverEvent_ = null;
            }
        }

        if (this.clickEvent_ != null) {
            var result_ = this.hitTestGeoLayers(this.clickEvent_[0], this.clickEvent_[1], "click");

            if (result_[1] == true && result_[0] != null) {
                this.browser_.callListener("geo-feature-click", {"feature": result_[0][0], "screen-pos":this.project(result_[0][1]),
                                                                "scene-pos":result_[0][1], "state": this.hoverEvent_[3] });
            }

            this.clickEvent_ = null;
        }

    }


    //else {
      //  this.dirty_ = false;
    //}

    //this.clickEvent_ = [screenX, screenY, state_];
    //this.hoverEvent_ = [screenX, screenY, persistent_, state_];

    //loop heartbeat
    window.requestAnimFrame(this.update.bind(this));
};


Vadstena.Renderer.prototype.project = function(point_)
{
    //get mode-view-projection matrix
    var mvp_ = this.camera_.getMvpMatrix();

    //get camera position relative to position
    var cameraPos2_ = this.camera_.getPosition();

    //get global camera position
    var cameraPos_ = this.cameraPosition();

    //get point coords relative to camera
    var p_ = [point_[0] - cameraPos_[0] + cameraPos2_[0], point_[1] - cameraPos_[1] + cameraPos2_[1], point_[2] - cameraPos_[2] + cameraPos2_[2], 1 ];

    //project point coords to screen
    var p2_ = [0, 0, 0, 1];
    p2_ = Vadstena.mat4.multiplyVec4(mvp_, p_);

    if (p2_[3] != 0) {

        var sp_ = [0,0,0];

        //x and y are in screen pixels
        sp_[0] = ((p2_[0]/p2_[3])+1.0)*0.5*this.curSize_[0];
        sp_[1] = (-(p2_[1]/p2_[3])+1.0)*0.5*this.curSize_[1];

        //depth in meters
        sp_[2] = p2_[2]/p2_[3];
        //sp_[2] = p2_[2];
        //sp_[2] =  this.camera_.getNear() + sp_[2] ;//* (this.camera_.getFar() - this.camera_.getNear());

        return sp_;
    } else {
        return [0, 0, 0];
    }
};


Vadstena.Renderer.prototype.getScreenRay = function(screenX_, screenY_)
{
    if (this.camera_ == null) {
        return [0,0,1.0];
    }

    //conver screen coords
    var x_ = (2.0 * screenX_) / this.curSize_[0] - 1.0;
    var y_ = 1.0 - (2.0 * screenY_) / this.curSize_[1];

    var rayNormalizeDeviceSpace_ = [x_, y_, 1.0];

    var rayClipCoords_ = [rayNormalizeDeviceSpace_[0], rayNormalizeDeviceSpace_[1], -1.0, 1.0];

    var invProjection_ = Vadstena.mat4.create();
    invProjection_ = Vadstena.mat4.inverse(this.camera_.getProjectionMatrix());

    var rayEye_ = [0,0,0,0];
    Vadstena.mat4.multiplyVec4(invProjection_, rayClipCoords_, rayEye_); //inverse (projection_matrix) * rayClipCoords_;
    rayEye_[2] = -1.0;
    rayEye_[3] = 0.0;

    var invView_ = Vadstena.mat4.create();
    invView_ = Vadstena.mat4.inverse(this.camera_.getModelviewMatrix());

    var rayWorld_ = [0,0,0,0];
    Vadstena.mat4.multiplyVec4(invView_, rayEye_, rayWorld_); //inverse (projection_matrix) * rayClipCoords_;

    // don't forget to normalise the vector at some point
    rayWorld_ = Vadstena.vec3.normalize([rayWorld_[0], rayWorld_[1], rayWorld_[2]]); //normalise (ray_wor);

    return rayWorld_;
};


Vadstena.Renderer.prototype.hitTestGeoLayers = function(screenX_, screenY_, mode_)
{
    var gl_ = this.gpu_.gl_;

    //conver screen coords to texture coords
    if (gl_.checkFramebufferStatus(gl_.FRAMEBUFFER) != gl_.FRAMEBUFFER_COMPLETE) {
        return [null, false, []];
    }

    var surfaceHit_ = false;

    if (screenX_ >= 0 && screenX_ < this.curSize_[0] &&
        screenY_ >= 0 && screenY_ < this.curSize_[1]) {

        var x_ = 0, y_ = 0;

        //get screen coords
        x_ = Math.floor(screenX_ * (this.hitmapSize_ / this.curSize_[0]));
        y_ = Math.floor(screenY_ * (this.hitmapSize_ / this.curSize_[1]));

        //get pixel value from framebuffer
        var pixel_ = this.geoHitmapTexture_.readFramebufferPixels(x_, this.hitmapSize_ - y_ - 1, 1, 1);

        //convert rgb values into depth
        var id_ = (pixel_[0]) + (pixel_[1]*255.0) + (pixel_[2]*65025.0);// + (pixel_[3]*16581375.0);

        var surfaceHit_ = !(pixel_[0] == 255 && pixel_[1] == 255 && pixel_[2] == 255 && pixel_[3] == 255);

    //    console.log(JSON.stringify([pixel_[0], pixel_[1], pixel_[2], pixel_[3], surfaceHit_]));

    }


    if (surfaceHit_) {
        //console.log(JSON.stringify([id_, JSON.stringify(this.hoverFeatureList_[id_])]));

        if (mode_ == "hover") {
            this.lastHoverFeature_ = this.hoverFeature_;
            this.lastHoverFeatureId_ = this.hoverFeatureId_;
            this.hoverFeature_ = null;
            this.hoverFeatureId_ = null;

            this.hoverFeature_ = this.hoverFeatureList_[id_];
            this.hoverFeatureId_ = (this.hoverFeature_ != null) ? this.hoverFeature_[0]["id"] : null;

            var relatedEvents_ = [];

            if (this.hoverFeatureId_ != this.lastHoverFeatureId_) {

                if (this.lastHoverFeatureId_ != null) {
                    relatedEvents_.push(["leave", this.lastHoverFeature_, this.lastHoverFeatureId_]);
                }

                if (this.hoverFeatureId_ != null) {
                    relatedEvents_.push(["enter", this.hoverFeature_, this.hoverFeatureId_]);
                }

                this.dirty_ = true;
            }

            if (this.hoverFeature_ != null && this.hoverFeature_[3] == true) {
                return [this.hoverFeature_, surfaceHit_, relatedEvents_];
            } else {
                return [null, false, relatedEvents_];
            }
        }

        if (mode_ == "click") {

            var feature_ = this.hoverFeatureList_[id_];
            //this.hoverFeatureId_ = (this.hoverFeature_ != null) ? this.hoverFeature_["id"] : null;

            if (feature_ != null && this.hoverFeature_ != null && this.hoverFeature_[2] == true) {
                return [feature_, surfaceHit_, []];
            } else {
                return [null, false, []];
            }

        }
    } else {

        var relatedEvents_ = [];

        if (mode_ == "hover") {
            this.lastHoverFeature_ = this.hoverFeature_;
            this.lastHoverFeatureId_ = this.hoverFeatureId_;
            this.hoverFeature_ = null;
            this.hoverFeatureId_ = null;

            if (this.lastHoverFeatureId_ != null) {

                if (this.lastHoverFeatureId_ != null) {
                    relatedEvents_.push(["leave", this.lastHoverFeature_, this.lastHoverFeatureId_]);
                }

                this.dirty_ = true;
            }
        }

        return [null, false, relatedEvents_];
    }

};


Vadstena.Renderer.prototype.hitTest = function(screenX_, screenY_, mode_)
{

    //this.browser_.hover(screenX_, screenY_, false, { test:true});
    //return [0,0,0,false];

    this.updateHitmap_ = true;

    var gl_ = this.gpu_.gl_;

    if (this.updateHitmap_ == true) {

        var size_ = this.hitmapSize_;

        //set texture framebuffer
        this.gpu_.setFramebuffer(this.hitmapTexture_);

        var oldSize_ = [ this.curSize_[0], this.curSize_[1] ];

        var width_ = size_;
        var height_ = size_;

        gl_.clearColor(1.0,1.0, 1.0, 1.0);
        //gl_.clearColor(0.0, 0.0, 0.0, 1.0);
        gl_.enable(gl_.DEPTH_TEST);

        //clear screen
        gl_.viewport(0, 0, size_, size_);
        gl_.clear(gl_.COLOR_BUFFER_BIT | gl_.DEPTH_BUFFER_BIT);

        this.curSize_ = [width_, height_];

        //gl_.viewport(0, 0, width_, height_);
        //render scene
        this.onlyDepth_ = true;
        //this.paintGL();

        this.gpu_.clear();

        this.updateCamera();
        //maxPixelSize_ = this.planet_.draw();
        this.drawTiles(this.planet_);

        this.onlyDepth_ = false;

        //return screen framebuffer
        width_ = oldSize_[0];
        height_ = oldSize_[1];

        gl_.clearColor(0.0, 0.0, 0.0, 1.0);

        this.gpu_.setFramebuffer(null);

        this.camera_.setAspect(width_ / height_);
        this.curSize_ = [width_, height_];
        this.gpu_.resize(this.curSize_, true);
        this.camera_.update();
        this.updateCamera();

        this.updateHitmap_ = false;
    }

    //conver screen coords to texture coords
    if (gl_.checkFramebufferStatus(gl_.FRAMEBUFFER) != gl_.FRAMEBUFFER_COMPLETE) {
        return [0,0,0,0];
    }

    var x_ = 0, y_ = 0;

    //get screen coords
    //if (this.curSize_[0] > this.curSize_[1]) {
    x_ = Math.floor(screenX_ * (this.hitmapSize_ / this.curSize_[0]));
    y_ = Math.floor(screenY_ * (this.hitmapSize_ / this.curSize_[1]));

    //console.log("hit screen: " + x_ + " " + y_);

    //get pixel value from framebuffer
    var pixel_ = this.hitmapTexture_.readFramebufferPixels(x_, this.hitmapSize_ - y_ - 1, 1, 1);

    //convert rgb values into depth
    var depth_ = (pixel_[0] * (1.0/255)) + (pixel_[1]) + (pixel_[2]*255.0) + (pixel_[3]*65025.0);// + (pixel_[3]*16581375.0);

    var surfaceHit_ = !(pixel_[0] == 255 && pixel_[1] == 255 && pixel_[2] == 255 && pixel_[3] == 255);

    //get screen ray
    var screenRay_ = this.getScreenRay(screenX_, screenY_);
    var cameraPos_ = this.cameraPosition();

    //compute hit postion
    this.lastHitPosition_ = [cameraPos_[0] + screenRay_[0]*depth_, cameraPos_[1] + screenRay_[1]*depth_, cameraPos_[2] + screenRay_[2]*depth_];


    //this.hitTestGeoLayers(screenX_, screenY_, "hover");
    this.browser_.hover(screenX_, screenY_, false, { test:true});
    //this.browser_.click(screenX_, screenY_, { test2:true});


    return [this.lastHitPosition_[0], this.lastHitPosition_[1], this.lastHitPosition_[2], surfaceHit_];
};


Vadstena.Renderer.prototype.saveScreenshot = function()
{
    //this.updateHitmap_ = true;

    var gl_ = this.gpu_.gl_;

    //get current screen size
    var width_ = this.curSize_[0];
    var height_ = this.curSize_[1];

    //read rgba data from frame buffer
    //works only when webgl context is initialized with preserveDrawingBuffer: true
    var data2_ = new Uint8Array(width_ * height_ * 4);
    gl_.readPixels(0, 0, width_, height_, gl_.RGBA, gl_.UNSIGNED_BYTE, data2_);

    //flip image vertically
    var data_ = new Uint8Array(width_ * height_ * 4);
    var index_ = 0;

    for (var y = 0; y < height_; y++) {

        index2_ = ((height_-1) - y) * width_ * 4;

        for (var x = 0; x < width_; x++) {
            data_[index_] = data2_[index2_];
            data_[index_+1] = data2_[index2_+1];
            data_[index_+2] = data2_[index2_+2];
            data_[index_+3] = data2_[index2_+3];
            index_+=4;
            index2_+=4;
        }
    }

    // Create a 2D canvas to store the result
    var canvas_ = document.createElement('canvas');
    canvas_.width = width_;
    canvas_.height = height_;
    var context_ = canvas_.getContext('2d');

    // Copy the pixels to a 2D canvas
    var imageData_ = context_.createImageData(width_, height_);
    imageData_.data.set(data_);
    context_.putImageData(imageData_, 0, 0);

    //open image in new window
    window.open(canvas_.toDataURL("image/jpeg"));
};

Vadstena.Renderer.prototype.resetStats = function() {
    this.statsTimeIndex_ = 0;

    for (var i = 0; i < this.statsTimeSamples_; i++) {
        this.statsRenderTimes_[i] = 0;
        this.statsCreateMeshTimes_[i] = 0;
        this.statsCreateGpuMeshTimes_[i] = 0;
        this.statsCreateTextureTimes_[i] = 0;
        this.statsFrameGapTimes_[i] = 0;
        this.statsGpuMemory_[i] = 0;
        this.statsGpuMemoryUsed_[i] = 0;
        this.statsGpuMemoryTextures_[i] = 0;
        this.statsGpuMemoryMeshes_[i] = 0;
        this.statsPolygons_[i] = 0;
        this.statsLODs_[i] = [0,[]];
        this.statsFluxTextures_[i] = [[0,0],[0,0]];
        this.statsFluxMeshes_[i] = [[0,0],[0,0]];
    }

};

Vadstena.Renderer.prototype.getBitmap = function(url_, filter_, tiled_) {
    var id_ = url_ + "*" + filter_ + "*" + tiled_;

    var texture_ = this.bitmaps_[id_];
    if (texture_ == null) {
        texture_ = new Vadstena.GpuTexture(this.gpu_, url_, this.browser_, null, null, tiled_, filter_);
        this.bitmaps_[id_] = texture_;
    }

    return texture_;
};


if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file


Vadstena.Renderer.prototype.initShaders = function()
{
    this.progTile_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tileVertexShader, Vadstena.tileFragmentShader);
    this.progWireframeTile_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tileWireframeVertexShader, Vadstena.tileWireframeFragmentShader);
    this.progWireframeTile2_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tileWireframeVertexShader, Vadstena.tileWireframe2FragmentShader);
    this.progFlatShadeTile_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tileFlatShadeVertexShader, Vadstena.tileFlatShadeFragmentShader);
    this.progHeightmap_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.heightmapVertexShader, Vadstena.heightmapFragmentShader);
    this.progSkydome_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.skydomeVertexShader, Vadstena.skydomeFragmentShader);

    this.progDepthTile_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tileDepthVertexShader, Vadstena.tileDepthFragmentShader);
    this.progDepthHeightmap_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.heightmapDepthVertexShader, Vadstena.heightmapDepthFragmentShader);
    //this.progDepthSkydome_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.skydomeVertexShader, Vadstena.skydomeFragmentShader);

    this.progBBox_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.bboxVertexShader, Vadstena.bboxFragmentShader);
    this.progLine_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.lineVertexShader, Vadstena.lineFragmentShader);
    this.progLine3_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.line3VertexShader, Vadstena.line3FragmentShader);
    this.progTLine_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tlineVertexShader, Vadstena.tlineFragmentShader);
    this.progTPLine_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tplineVertexShader, Vadstena.tlineFragmentShader);
    this.progTBLine_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tlineVertexShader, Vadstena.tblineFragmentShader);
    this.progTPBLine_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.tplineVertexShader, Vadstena.tblineFragmentShader);
    this.progPolygon_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.polygonVertexShader, Vadstena.polygonFragmentShader);
    this.progText_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.textVertexShader, Vadstena.textFragmentShader);
    this.progText2_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.textVertexShader2, Vadstena.textFragmentShader);
    this.progImage_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.imageVertexShader, Vadstena.imageFragmentShader);
    this.progIcon_ = new Vadstena.GpuProgram(this.gpu_, Vadstena.iconVertexShader, Vadstena.textFragmentShader);

};


Vadstena.Renderer.prototype.initHeightmap = function()
{
    // initialize heightmap geometry
    var mesh_ = new Vadstena.Mesh();
    mesh_.buildHeightmap(Vadstena.MetaNodeHMSize_);
    this.heightmapMesh_ = new Vadstena.GpuMesh(this.gpu_, mesh_, null, this.browser_);

   // create heightmap texture
    var size_ = 64;
    var halfLineWidth_ = 1;
    var data_ = new Uint8Array( size_ * size_ * 4 );

    for (var i = 0; i < size_; i++) {
        for (var j = 0; j < size_; j++) {

            var index_ =(i*size_+j)*4;

            if (i < halfLineWidth_ || i >= size_-halfLineWidth_ || j < halfLineWidth_ || j >= size_-halfLineWidth_) {
                 data_[index_] = 255;
                 data_[index_ + 1] = 255;
                 data_[index_ + 2] = 255;
             } else {
                 data_[index_] = 32;
                 data_[index_ + 1] = 32;
                 data_[index_ + 2] = 32;
             }

             data_[index_ + 3] = 255;
        }
    }


    this.heightmapTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.heightmapTexture_.createFromData(size_, size_, data_, "trilinear", true);
};


Vadstena.Renderer.prototype.initHitmap = function()
{
    var size_ = this.hitmapSize_;
    var data_ = new Uint8Array( size_ * size_ * 4 );

    this.hitmapTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.hitmapTexture_.createFromData(size_, size_, data_);
    this.hitmapTexture_.createFramebuffer(size_, size_);

    this.geoHitmapTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.geoHitmapTexture_.createFromData(size_, size_, data_);
    this.geoHitmapTexture_.createFramebuffer(size_, size_);
};

Vadstena.Renderer.prototype.initTestMap = function()
{
   // create red texture
    var size_ = 16;
    var data_ = new Uint8Array( size_ * size_ * 4 );

    for (var i = 0; i < size_; i++) {
        for (var j = 0; j < size_; j++) {

            var index_ = (i*size_+j)*4;

             data_[index_] = 255;
             data_[index_ + 1] = 0;
             data_[index_ + 2] = 0;
             data_[index_ + 3] = 255;
        }
    }

    this.redTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.redTexture_.createFromData(size_, size_, data_);

    var data_ = new Uint8Array( size_ * size_ * 4 );

    for (var i = 0; i < size_; i++) {
        for (var j = 0; j < size_; j++) {
            var index_ = (i*size_+j)*4;
             data_[index_] = 255;
             data_[index_ + 1] = 255;
             data_[index_ + 2] = 255;
             data_[index_ + 3] = 255;
        }
    }

    this.whiteTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.whiteTexture_.createFromData(size_, size_, data_);

    var sizeX_ = 64;
    var sizeY_ = 8;
    var data_ = new Uint8Array( sizeX_ * sizeY_ * 4 );

    var chars_ = [
    "............................................................",
    ".....xxxxx.......................xxxxx......................",
    ".....xxxxx.......................xxxxx......................",
    ".....xxxxx.......................xxxxx......................",
    "xxxxxxxxxxxxxxxx............xxxxxxxxxxxxxxxx................",
    "xxxxxxxxxxxxxxxx............xxxxxxxxxxxxxxxx................",
    "............................................................"
    ];


    // create red texture
    var data_ = new Uint8Array( sizeX_ * sizeY_ * 4 );

    //clear texture
    for (var i = 0; i < sizeY_; i++) {
        for (var j = 0; j < sizeX_; j++) {

            var index_ = (i*sizeX_+j)*4;

             data_[index_] = 0;
             data_[index_ + 1] = 0;
             data_[index_ + 2] = 0;
             data_[index_ + 3] = 0;//255;
        }
    }

    for (var i = 0, li = chars_.length; i < li; i++) {

        var string_ = chars_[i];

        for (var j = 0, lj = string_.length; j < lj; j++) {

            var index_ = (i*sizeX_+j)*4;

            if (string_.charAt(j) != '.') {
                 data_[index_] = 255;
                 data_[index_ + 1] = 255;
                 data_[index_ + 2] = 255;
                 data_[index_ + 3] = 255;
            }
        }
    }

    this.lineTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.lineTexture_.createFromData(sizeX_, sizeY_, data_, "linear", true);

};

Vadstena.Renderer.prototype.initTextMap = function()
{
    var sizeX_ = 64;
    var sizeY_ = 8;
    var data_ = new Uint8Array( sizeX_ * sizeY_ * 4 );

    var chars_ = [
    "............................................................",
    "xxx..x..xxx.xxx.x...xxx.xxx.xxx.xxx.xxx.....................",
    "x.x.xx....x...x.x...x...x.....x.x.x.x.x......x..............",
    "x.x..x..xxx.xxx.x...xxx.xxx...x.xxx.xxx.........x.x.xxx.....",
    "x.x..x..x.....x.xxx...x.x.x...x.x.x...x......x...x..........",
    "xxx..x..xxx.xxx..x..xxx.xxx...x.xxx.xxx..x......x.x.........",
    "............................................................"
    ];

    this.textTable_ = {
        "0" : 0,
        "1" : 4,
        "2" : 8,
        "3" : 12,
        "4" : 16,
        "5" : 20,
        "6" : 24,
        "7" : 28,
        "8" : 32,
        "9" : 36,
        "." : 40,
        ":" : 44,
        "x" : 48,
        "-" : 52,
        " " : 56
    };

    // create red texture
    var data_ = new Uint8Array( sizeX_ * sizeY_ * 4 );

    //clear texture
    for (var i = 0; i < sizeY_; i++) {
        for (var j = 0; j < sizeX_; j++) {

            var index_ = (i*sizeX_+j)*4;

             data_[index_] = 0;
             data_[index_ + 1] = 0;
             data_[index_ + 2] = 0;
             data_[index_ + 3] = 255;
        }
    }

    for (var i = 0, li = chars_.length; i < li; i++) {

        var string_ = chars_[i];

        for (var j = 0, lj = string_.length; j < lj; j++) {

            var index_ = (i*sizeX_+j)*4;

            if (string_.charAt(j) != '.') {
                 data_[index_] = 255;
                 data_[index_ + 1] = 255;
                 data_[index_ + 2] = 255;
            }
        }
    }

    this.textTexture_ = new Vadstena.GpuTexture(this.gpu_);
    this.textTexture_.createFromData(sizeX_, sizeY_, data_);
};



Vadstena.Renderer.prototype.initImage = function()
{
    var gl_ = this.gpu_.gl_;

    //create vertices buffer for rect
    this.rectVerticesBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ARRAY_BUFFER, this.rectVerticesBuffer_);

    var vertices_ = [ 0, 0, 0, 1,   1, 0, 0, 1,
                      2, 0, 0, 1,   3, 0, 0, 1 ];

    gl_.bufferData(gl_.ARRAY_BUFFER, new Float32Array(vertices_), gl_.STATIC_DRAW);
    this.rectVerticesBuffer_.itemSize = 4;
    this.rectVerticesBuffer_.numItems = 4;

    //create indices buffer for rect
    this.rectIndicesBuffer_ = gl_.createBuffer();
    gl_.bindBuffer(gl_.ELEMENT_ARRAY_BUFFER, this.rectIndicesBuffer_);

    var indices_ = [ 0, 2, 1,    0, 3, 2 ];

    gl_.bufferData(gl_.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_), gl_.STATIC_DRAW);
    this.rectIndicesBuffer_.itemSize = 1;
    this.rectIndicesBuffer_.numItems = 6;
};


Vadstena.Renderer.prototype.initSkydome = function()
{
    var mesh_ = new Vadstena.Mesh();
    mesh_.buildSkydome(32, 64);
    this.skydomeMesh_ = new Vadstena.GpuMesh(this.gpu_, mesh_, null, this.browser_);
    this.skydomeTexture_ = new Vadstena.GpuTexture(this.gpu_, this.browser_.browserConfig_.skydomeTexture_, this.browser_);
};


Vadstena.Renderer.prototype.initBBox = function()
{
    this.bboxMesh_ = new Vadstena.GpuBBox(this.gpu_);

    if (this.displayDrawTest_ != true) {
        return;
    }
/*
    var x = 464823, y = 5582535, z = 259;

    var d = 400;

    var points_ = [
        [x,y,z],
        [x+d,y,z],
        [x+d,y+d,z],
        [x,y+d,z],
        [x+d*0.5,y,z],
        [x+d*0.5,y+d*2,z],
        [x,y,z+20],
        [x+d*0.5,y,z]
     ];

    this.lineTest_ = new Vadstena.GpuLine3(this.gpu_, this.browser_);

    var s = 20;
   // var s = 1.0;

    this.lineTest_.addLine(points_[0], points_[7], s);
    this.lineTest_.addLine(points_[7], points_[1], s);

    this.lineTest_.addLine(points_[1], points_[2], s);
    this.lineTest_.addLine(points_[2], points_[3], s);
    //this.lineTest_.addLine(points_[3], points_[0], 5);

    this.lineTest_.addLine(points_[3], points_[4], s);
    this.lineTest_.addLine(points_[4], points_[5], s);

    this.lineTest_.addCircle(points_[0], s, 8);
    this.lineTest_.addCircle(points_[1], s, 8);
    this.lineTest_.addCircle(points_[2], s, 8);
    this.lineTest_.addCircle(points_[5], s, 8);

    this.lineTest_.addCircle(points_[3], s*5, 8);

    this.lineTest_.compile();


    this.font_ = new Vadstena.GpuFont(this.gpu_, this.browser_);
    this.textTest_ = new Vadstena.GpuText(this.gpu_, this.browser_, this.font_);

    this.textTest_.addText(points_[6], [1,0,0], "ABCabc", 1000);
    this.textTest_.compile();

    //var placemark_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAAK/INwWK6QAABchJREFUeNrlm39MVWUYxyGSEBUQ/4Coy49hRM1+DCRguhjoNMBEnBKIzFaZm2mT0TTDH9EWQcBMV0MYroDLEEYrc+H1ImBNVgYE+kfookzTtUQRzrnn3HPP/XF639t56PWG6L3Afe+599m+2/3j3PM+7+c8z/vjec/xkiTJyxHZaf5IuUiHkTqQriCxSIws/PsPpG6kz5C2IC20pwGH+zHLAMKQPkH6G/top8aQapEWKxXAQSQ90SFzWGiofkPWOqayrIw5rlYzHRqN4YxWK7Y2NTGHKirYTTk5TMTjKh5da7KBUaUkADh0zxLOG9akpzPffn2CFQ0GAf1XlO5tomQyC11aLbsxez1jA3AAKdzVAYQi/QlOJycmcj+c69Gh6w2S/SZeHBjQrVq5ksPRI98TQ4l1VQAhSNfhqe/fu5dxsOO2ZqgqL8eDpCDfG/9+0tUAzCeevKmpvp5F15ikmTPLqZMncceNRCSEuRKAHtkxsbG+XifNkmna2zkiEi67CoBCGOXfLSpiZvjJ25r5cEXFODFLVNEGEIxkwe0/HRurv88IP1NmTFm+nCdmh8U0AXwMg95gXx8nOcmuX7vGE6mgpgXAG2kEt706bQU7QyP+A0fBq/n5LMBHCqABIBPCUHtK48zOW22w/2eBWB+8QQPAIdx4cEAgbxKNguR8M8RER3MygEYaAE7jxjfn5nJOGvxszfTOrl0wGPbRAPAbbhxtbHiJkn1RVwcAbtAAgFdjUotaraMFoFNzGlKApQFAhxvHW1paAPp7ew0yAI4GAOs01N3ZZaQF4MLAoIlmBFjD75u2L6mlQM/Z7yAFeBoAbuLGa48eFWgB+KqtDVaDt2kA+Ak3vruoCO8BLDQAlJeWQsXoMg0Ajbjx+Oee55y8DJ6oGL2cng4poKEBALbBxivDw3pn935sdFTw8faGWeAjGgBUsBcoOXDA6WlQW11NFkzjaG2HrdXfoIAAvWQ2OzMNxEiVCgD8QrMekCY7YSncsRNPh2YndN5SVVamI3aCm2iXxL6XHREu9PWzs937G1ev4s7DHuCSK9QEH4NcXBS0kOMYZjYHROGJqCiOyP1nXKUq/Ao49eySJZxZFGdjh6hPTUnREZ1/29UORnaCc0lx8WPY4Zksfqxd/dIdovMfuOrR2D5wckPWuvEZWiAZC9/aMQ7VZ6RPXf1wtA5OiN5/r3h8musDS3NDI0OcCGmVcjw+ACdFP/b0ODwe3B65JRDl71tIDykFQDDM08GBgRyKAUcgmF5cdtcByFKlvSCRC0dm27e+ydq7SDrR1qYjQv+IUl+RaYdU+HVoyJ7CiYDL7fJ/R5T8jlAwhPCypCT+AaPAcqSykiWWumuVDABbKcwK5/99W+S+T3/+XP+7NjpKB/CwfH4nJSckYABTFVEtx2pqeGLOX+EOALzklZu1eDLQ2zfVjCBGhYdD7v/uDu8Jgi2AsSA/L0+41+Koq+OMnnj5YYs7AcDWjP2c6+cn6FndZPsEc15ODix6MARfdwOwFIonx2pr/wdA4Hlhwbx5AOBze2+uBADY/sK+ZmZkGGynxOaGBrLKk+yuAKxTop+vr8AxLHmgYt6cmwuD3x1HbqwUAPGQBq3NzWQaGB4NCYG5v9adAUykwfZt2yZK6efRjpEI/wx3B2CtF7wQFyfAoujDkhIIfwwhyN0BbMX+PjJnjsCNj+NjNcv6rCwI/05Hb6okAAnwtM91deOlsSk6MgqOuEo8AYA/fAfQ2tKCUwCXuUUZQLYnAJg4TKmprhaHhy7piM1PjKcAwFOddLC4mD/eqIZa/82pan7uBmA/9vm1ggLdvt17GBlA+3RuqDQAr2OfV6Wm8dmZa8amqve7LIDpSC5zSTEqFftUROSoDGAPFV8oAUjFnfZB216f/yq/BZ4EIHGSDyU3ehKAmEkAZHkSgEXE4geU5EkAvMkPLGVFeBIAbBeJzltrgJ4GQE18Pt85nbl8OvoHhtWMM6/FYLQAAAAASUVORK5CYII=";
    var placemark_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAKTSURBVHjavNfPS1RBAAfwL6nbocMebDe79UMFQyG3Tit2EjatLhZkmluYGwZlJoJZUuy2BUGuSCAWFkgnCRIrfxyk3ZMtHpT+gbq8UgLrtGD43ny7vKnJLH2zu29gLnv4fj/zdnbeLEjCyQRwBsAUgI8AvtvzE4BZAM2O8xwUhwG8B0A5PUVF3OnxUP0MwCKASE4BAO7IAr/Px7v9/UzPz/OzYfCLYXAhnea9aJQlJSUq5EFOAACuytCL4TB/rK1RCMGNQwhBc32dlyMRFdGTFQDAPhl2vbOTlmVxq2FZFvt6e1VEVTaAhwB4rLZ2W+Uq4ngopCIKHQMAnJQBszMzdDpSyaQKaNIBJACwrLSUuqOqslICnugAJgGwualp00231RBC8FJbmwS80QHMAOCVjg5twI2uLgmY1gG8BsDzLS3agEh7uwS81QE8BsBDFRXaeyBQXS0Bz3QAZ+UuTiWTjssX0mn1VxDWARTKgBP1DY7OAdM0ebqxUQXs0j2IqmRIPBbbFsI0TQ4mEmp5MNt3wS0Z9nRk5L8Iy7L4YmxMLY/m6m34SIa+m5v7J2BpcYkFOwpk+VCu7wPDAFheVsZMJrPp6mtramT5cD4uJLvtywbvx+N/nQ3PR0fVR1+ec4CNiADgHr+f31ZX/9h4RwIBWd6XlyuZglgAwMTAwC/A9NSUuvrifAOuAWBNMEjLsiiE4IXWVsfffTaA/XK1K8vLJMm9v++CDXkH2IgUAE5OTPDryor6+D1uAaIAODQ4yJfj47L8lVaWJuAcAPZ0dzMei0nATTcBRwEwVFfHU/X1EtDoJuAAABZ7vSz2eiXgsJsA/4a/YwRw0E2AZxOAzzWAjfiglBvaOVkAOmyEAeC2bs7PAQBlCgrhBHN4PQAAAABJRU5ErkJggg==";
    this.placemarkTexture_ = new Vadstena.GpuTexture(this.gpu_, placemark_, this.browser_, null, true);
    */
};


Vadstena.Renderer.prototype.initializeGL = function()
{
    this.gpu_.init();
    this.initShaders();
    this.initHeightmap();
    this.initSkydome();
    this.initHitmap();
    this.initTextMap();
    this.initImage();
    this.initTestMap();
    this.initBBox();
};
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file


//! Converts the 6-DOF control parameters to camera position and orientation.
//!
Vadstena.Renderer.prototype.updateCamera = function()
{
    switch (this.browser_.browserConfig_.controlMode_)
    {
        case "observer":
            this.orientation_[1] = Vadstena.clamp(this.orientation_[1], -90.0, 10.0);
            this.position_[2] = Vadstena.clamp(this.position_[2], 5, this.camera_.getFar());
            Vadstena.mat4.multiply(Vadstena.rotationMatrix(2, Vadstena.radians(this.orientation_[0])), Vadstena.rotationMatrix(0, Vadstena.radians(this.orientation_[1])), this.updateCameraMatrix_);

            var orbitPos_ = [0, -this.position_[2], 0];
            Vadstena.mat4.multiplyVec3(this.updateCameraMatrix_, orbitPos_);

            this.cameraVector_ = [0, 1, 0];
            Vadstena.mat4.multiplyVec3(this.updateCameraMatrix_, this.cameraVector_);


            var height_ = this.planet_.surfaceHeight(this.position_, this.heightLod_);

            orbitPos_[2] += height_[0] + this.cameraHeightOffset_ + this.cameraHeightOffset2_ + this.cameraHeightCorrection_;

            this.camera_.setPosition(orbitPos_);
            this.camera_.setOrientation(this.orientation_);
            break;

        case "drone":

            this.orientation_[1] = Vadstena.clamp(this.orientation_[1], -90.0, 90.0);
            this.position_[2] = Vadstena.clamp(this.position_[2], 5, this.camera_.getFar());

            Vadstena.mat4.multiply(Vadstena.rotationMatrix(2, Vadstena.radians(this.orientation_[0])), Vadstena.rotationMatrix(0, Vadstena.radians(this.orientation_[1])), this.updateCameraMatrix_);

            this.cameraVector_ = [0, 1, 0];
            Vadstena.mat4.multiplyVec3(this.updateCameraMatrix_, this.cameraVector_);


            var cameraPos_ = this.camera_.position_;
            this.camera_.setPosition([0, 0, this.position_[2] + this.planet_.surfaceHeight([this.position_[0] + cameraPos_[0], this.position_[1] + cameraPos_[1]])[0]]);
            this.camera_.setOrientation(this.orientation_);
            break;

        case "manual":

            Vadstena.mat4.multiply(Vadstena.rotationMatrix(2, Vadstena.radians(this.orientation_[0])), Vadstena.rotationMatrix(0, Vadstena.radians(this.orientation_[1])), this.updateCameraMatrix_);

            this.cameraVector_ = [0, 1, 0];
            Vadstena.mat4.multiplyVec3(this.updateCameraMatrix_, this.cameraVector_);

            this.camera_.setPosition([0, 0, this.position_[2]]);
            this.camera_.setOrientation(this.orientation_);
            break;
    }

    var far_ = this.camera_.getFar();

    var maxDistance_ = this.position_[2] * (Math.tan(this.camera_.getFov()*0.5) / this.camera_.getAspect());

    //if (this.orientation_[1] > -45) {
        maxDistance_ *= Math.tan(Vadstena.radians(90+this.orientation_[1]*0.10));
    //}

    maxDistance_ = maxDistance_ > 9000000.0 ? 9000000.0 : maxDistance_;

    maxDistance_ = maxDistance_ < this.browser_.browserConfig_.cameraVisibility_ ? this.browser_.browserConfig_.cameraVisibility_ : maxDistance_;

    if (Math.abs(maxDistance_- far_) > 1.0) {
        this.camera_.setParams(this.camera_.getFov(), this.camera_.getNear(), maxDistance_);
    }

    this.dirty_ = true;
};

//! Returns the height of the camera above the surface.
//!
Vadstena.Renderer.prototype.cameraHeight = function()
{
    var cameraPos_ = this.camera_.position_;
    return (this.camera_.getPosition()[2] - this.planet_.surfaceHeight([this.position_[0] + cameraPos_[0], this.position_[1] + cameraPos_[1]])[0]);
};

Vadstena.Renderer.prototype.cameraPosition = function()
{
    //var foat_ = this.browser_.mapConfig_.foat_;
    var pos_ = this.camera_.getPosition();

    pos_[0] += this.position_[0];
    pos_[1] += this.position_[1];

    return pos_;
};

//! Constrains camera position and orientation accoring to browser
//! configuration.
//!
Vadstena.Renderer.prototype.constrainCamera = function(maxPixelSize_)
{
    var hit_ = false;
    var config_ = this.browser_.browserConfig_;

    var cameraMinDistance_ = this.cameraMinDistance_;

    if (this.ignoreTexelSize_ == true) {
        cameraMinDistance_ = 1;
    }

    //Constrain distance
    if (config_.controlMode_ == "observer") {
        if (this.position_[2] < cameraMinDistance_) {

            var delta_ = cameraMinDistance_ - this.position_[2];
            this.position_[2] = cameraMinDistance_;

            var yaw_ = (Vadstena.radians(this.orientation_[0]));
            var pitch_ =(Vadstena.radians(-this.orientation_[1]));

            var ddist_ = (0.5 / Math.sin(pitch_));
            var dpos_ = (ddist_*Math.cos(pitch_));

            var forward_ = [-Math.sin(yaw_), Math.cos(yaw_), 0];

            if (this.noForwardMovement_ != true) {
                this.position_[0] += dpos_*forward_[0];
                this.position_[1] += dpos_*forward_[1];
            }
            //this.position_[2] += ddist_;

            if (this.cameraHeightOffset_ > 0) {

                //create camera with limited fov
                var camera_ = this.camera_.clone(9);

                //calculate distance of nearest bounding box
                var minBoxDistance_ = this.planet_.calculateMinDistance(this.browser_.mapConfig_.foat_, camera_);


                if (minBoxDistance_ > cameraMinDistance_) {
                    this.position_[0] += dpos_*forward_[0]*delta_;
                    this.position_[1] += dpos_*forward_[1]*delta_;
                    this.cameraHeightOffset_ -= Math.sin(pitch_)*delta_;

                    if (this.cameraHeightOffset_ < 0) {
                        this.cameraHeightOffset_ = 0;
                    }
                }
            }

            hit_ = true;
        }

        if (this.position_[2] > config_.cameraMaxDistance_) {
            this.position_[2] = config_.cameraMaxDistance_;
            hit_ = true;
        }
    }

    //Constrain tilt
    if (this.orientation_[1] < config_.cameraMinTilt_) {
        this.orientation_[1] = config_.cameraMinTilt_;
        hit_ = true;
    }

    if (this.orientation_[1] > config_.cameraMaxTilt_) {
        this.orientation_[1] = config_.cameraMaxTilt_;
        hit_ = true;
    }

    if (hit_ == true) {
        this.updateCamera();
    }
};


//! Constrains camera position and orientation so that it is above surface
//!
Vadstena.Renderer.prototype.constrainMotionAboveTerrainOnly = function(maxPixelSize_)
{
    var browserConfig_ = this.browser_.browserConfig_;

    if (browserConfig_.controlMode_ == "manual") {
        return false;
    }

    var maxIter_ = 1000;

    var cameraMinDesiredDistance_ = this.cameraMinDesiredDistance_;
    var cameraConstrainDistance_ = this.cameraConstrainDistance_;

    if (this.ignoreTexelSize_ == true) {
        cameraConstrainDistance_ = 1;
        cameraMinDesiredDistance_ = 0.5;
    }


    var hmax_ = Math.max(Math.min(4000,cameraConstrainDistance_), (this.position_[2] * Math.tan(Vadstena.radians(3.0))));
    var cameraHeight_ = this.cameraHeight() - this.cameraHeightOffset_ - this.cameraHeightOffset2_;

    if (cameraHeight_ < hmax_) {

        if (this.position_[2] < hmax_) {

            var getFinalDistance = (function(start_, end_, level_) {

                var value_ = (start_ + end_) * 0.5;

                if (level_ > 20) {
                    return value_;
                } else {

                    this.position_[2] = value_;
                    this.updateCamera();

                    if ((this.cameraHeight() - this.cameraHeightOffset_ - this.cameraHeightOffset2_) < hmax_) {
                        return getFinalDistance(start_, value_, level_+1);
                    } else {
                        return getFinalDistance(value_, end_, level_+1);
                    }

                }

            }).bind(this);

            this.position_[2] = getFinalDistance(this.position_[2]+250, this.position_[2], 0);
            //this.position_[2] = getFinalDistance(this.position_[2]+cameraConstrainDistance_, this.position_[2], 0);

            this.updateCamera();

        } else {

            var getFinalOrientation = (function(start_, end_, level_) {

                var value_ = (start_ + end_) * 0.5;

                if (level_ > 20) {
                    return value_;
                } else {

                    this.orientation_[1] = value_;
                    this.updateCamera();

                    if ((this.cameraHeight() - this.cameraHeightOffset_ - this.cameraHeightOffset2_) < hmax_) {
                        return getFinalOrientation(start_, value_, level_+1);
                    } else {
                        return getFinalOrientation(value_, end_, level_+1);
                    }

                }

            }).bind(this);

            this.orientation_[1] = getFinalOrientation(-89, Math.min(-1, this.orientation_[1]), 0);
            this.updateCamera();

        }

    } else {

        var distance_ = cameraMinDesiredDistance_ * 0.5;

        var hmax2_ = Math.max(distance_, (this.position_[2] * (0.1*(20.0/distance_))));


        //apply cameraMinDesiredDistance_ directly
        if (cameraHeight_ >= hmax2_) {
            //this.cameraMinDistance_ = cameraMinDesiredDistance_;
            //cameraConstrainDistance_ = this.cameraMinDistance_ * 0.5;
        }
    }


    return false;
};


//! Constrains camera position and orientation so that it is not too close
//! to the surface.
//!
Vadstena.Renderer.prototype.constrainMotionTexelSize = function(maxPixelSize_)
{
    var redrawNeeded_ = false;
    var browserConfig_ = this.browser_.browserConfig_;
    var maxIter_ = 1000;


    // keep fixing camera parameters until the resolution is good
    while ((maxPixelSize_ > Vadstena.resolutionThreshold_ || this.cameraHeight() < 0) && (maxIter_ > 0))
    {
        redrawNeeded_ = true;

        if (browserConfig_.controlMode_ == "observer")
        {
            if (this.tilting_ || this.orientation_[1] > -10)
            {
                if (this.position_[2] < 250) {
                    this.position_[2] += 0.3;
                } else {
                    this.orientation_[1] -= 0.3;
                }
            }
            else // increase height by moving forward and increasing distance
            {
                var yaw_ = (Vadstena.radians(this.orientation_[0]));
                var pitch_ =(Vadstena.radians(-this.orientation_[1]));

                var ddist_ = (0.5 / Math.sin(pitch_));
                var dpos_ = (ddist_*Math.cos(pitch_));

                var forward_ = [-Math.sin(yaw_), Math.cos(yaw_), 0];

                if (this.noForwardMovement_ != true) {
                    this.position_[0] += dpos_*forward_[0];
                    this.position_[1] += dpos_*forward_[1];
                }

                this.position_[2] += ddist_;
            }
        }
        else // old control, just increase height
        {
            this.position_[2] += 0.5;
        }

        // calculate resolution after position change
        this.updateCamera();
        maxPixelSize_ = this.planet_.calculateResolution(this.browser_.mapConfig_.foat_);

        maxIter_--;
    }

   return redrawNeeded_;
};



//! Constrains camera position and orientation so that it is not too close
//! to the surface.
//!
Vadstena.Renderer.prototype.constrainMotion = function(maxPixelSize_)
{
    var browserConfig_ = this.browser_.browserConfig_;

    if (browserConfig_.controlMode_ == "manual") {
        return false;
    }

    switch (browserConfig_.cameraConstrainMode_) {

        case "aboveTerrainOnly":
        case "aboveTerrainByPixelSize":
        case "aboveTerrainByGSD":
            return this.constrainMotionAboveTerrainOnly();

        case "constrainTexelSize":
        default:
            return this.constrainMotionTexelSize();

    }

    return false;
};
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file



Vadstena.Renderer.prototype.drawSkydome = function()
{
    ///progSkydome.use();
    var lower_ = 400; // put the dome a bit lower
    var normMat_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(Vadstena.scaleMatrix(2, 2, 2), Vadstena.translationMatrix(-0.5, -0.5, -0.5), normMat_);

    var domeMat_ = Vadstena.mat4.create();
//    Vadstena.mat4.multiply(Vadstena.translationMatrix(0, 0, this.camera_.getPosition()[2] - lower_), Vadstena.scaleMatrixf(this.camera_.getFar()*0.5), domeMat_);
    Vadstena.mat4.multiply(Vadstena.translationMatrix(this.camera_.getPosition()[0], this.camera_.getPosition()[1], this.camera_.getPosition()[2] - lower_), Vadstena.scaleMatrixf(Math.min(this.camera_.getFar()*0.9,600000)), domeMat_);

    var mvp_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.camera_.getMvpMatrix(), domeMat_, mvp_);
    Vadstena.mat4.multiply(mvp_, normMat_, mvp_);

    this.gpu_.useProgram(this.progSkydome_, "aPosition", "aTexCoord");
    this.gpu_.bindTexture(this.skydomeTexture_);
//    this.gpu_.bindTexture(this.hitmapTexture_);

    this.progSkydome_.setSampler("uSampler", 0);
    this.progSkydome_.setMat4("uMVP", mvp_);

    this.gpu_.gl_.depthMask(false);

    this.skydomeMesh_.draw(this.progSkydome_, "aPosition", "aTexCoord");

    this.gpu_.gl_.depthMask(true);

    this.renderedPolygons_ += this.skydomeMesh_.getPolygons();
};

Vadstena.Renderer.prototype.drawBall = function(position_, size_)
{
    var gl_ = this.gpu_.gl_;

    gl_.disable(gl_.CULL_FACE);

    var normMat_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(Vadstena.scaleMatrix(2, 2, 2), Vadstena.translationMatrix(-0.5, -0.5, -0.5), normMat_);


   // var cameraPos2_ = this.camera_.getGlobalPosition();
    //var cameraPos_ = [0,0,0];
    var cameraPos2_ = this.camera_.getPosition();
    var cameraPos_ = this.cameraPosition();

    var pos_ = [position_[0] - cameraPos_[0] + cameraPos2_[0], position_[1] - cameraPos_[1] + cameraPos2_[1], position_[2] - cameraPos_[2] + cameraPos2_[2] ];
//    var pos_ = [position_[0] - cameraPos_[0], position_[1] - cameraPos_[1], position_[2] ];
    //var pos_ = [position_[0], position_[1], position_[2] ];
//    var pos_ = [cameraPos_[0]-position_[0], cameraPos_[1]-position_[1], -(cameraPos_[2]-position_[2]) ];


    var domeMat_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(Vadstena.translationMatrix(pos_[0], pos_[1], pos_[2]), Vadstena.scaleMatrixf(size_ != null ? size_ : 1.5), domeMat_);
    //Vadstena.mat4.multiply(Vadstena.translationMatrix(this.camera_.getPosition()[0]+pos_[0], this.camera_.getPosition()[1]+pos_[1], this.camera_.getPosition()[2]), Vadstena.scaleMatrixf(21.5), domeMat_);

    var mvp_ = Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.camera_.getMvpMatrix(), domeMat_, mvp_);
    Vadstena.mat4.multiply(mvp_, normMat_, mvp_);

    this.gpu_.useProgram(this.progSkydome_, "aPosition", "aTexCoord");
    this.gpu_.bindTexture(this.redTexture_);

    this.progSkydome_.setSampler("uSampler", 0);
    this.progSkydome_.setMat4("uMVP", mvp_);

    this.skydomeMesh_.draw(this.progSkydome_, "aPosition", "aTexCoord");

    this.renderedPolygons_ += this.skydomeMesh_.getPolygons();

    gl_.enable(gl_.CULL_FACE);
};


//draw 2d image - used for debuging
Vadstena.Renderer.prototype.drawImage = function(x, y, lx, ly, texture_, color_, depth_, depthTest_, transparent_) {

    if (texture_ == null || this.imageProjectionMatrix_ == null) {
        return;
    }

    var gl_ = this.gpu_.gl_;

    if (depthTest_ != true) {
        gl_.disable(gl_.DEPTH_TEST);
    }

    if (transparent_ == true) {
        //gl_.blendFunc(gl_.SRC_ALPHA, gl_.ONE);
        gl_.blendEquationSeparate(gl_.FUNC_ADD, gl_.FUNC_ADD);
        gl_.blendFuncSeparate(gl_.SRC_ALPHA, gl_.ONE_MINUS_SRC_ALPHA, gl_.ONE, gl_.ONE_MINUS_SRC_ALPHA);
        gl_.enable(gl_.BLEND);
    }

    gl_.disable(gl_.CULL_FACE);

    this.gpu_.useProgram(this.progImage_, "aPosition", null);
    this.gpu_.bindTexture(texture_);

    var vertices_ = this.rectVerticesBuffer_;
    gl_.bindBuffer(gl_.ARRAY_BUFFER, vertices_);
    gl_.vertexAttribPointer(this.progImage_.getAttribute("aPosition"), vertices_.itemSize, gl_.FLOAT, false, 0, 0);

    var indices_ = this.rectIndicesBuffer_;
    gl_.bindBuffer(gl_.ELEMENT_ARRAY_BUFFER, indices_);

    this.progImage_.setMat4("uProjectionMatrix", this.imageProjectionMatrix_);

    this.progImage_.setMat4("uData", [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    this.progImage_.setVec4("uColor", (color_ != null ? color_ : [255,255,255,255]));
    this.progImage_.setFloat("uDepth", depth_ != null ? depth_ : 0);


    gl_.drawElements(gl_.TRIANGLES, indices_.numItems, gl_.UNSIGNED_SHORT, 0);

    if (depthTest_ != true) {
        gl_.enable(gl_.DEPTH_TEST);
    }

    if (transparent_ == true) {
        gl_.disable(gl_.BLEND);
    }

    gl_.enable(gl_.CULL_FACE);
};

//draw flat 2d image - used for debuging
Vadstena.Renderer.prototype.drawFlatImage = function(x, y, lx, ly, texture_, color_, depth_) {

    if (texture_ == null || this.imageProjectionMatrix_ == null) {
        return;
    }

    var gl_ = this.gpu_.gl_;
    this.gpu_.useProgram(this.progImage_, "aPosition", null);
    this.gpu_.bindTexture(texture_);

    var vertices_ = this.rectVerticesBuffer_;
    gl_.bindBuffer(gl_.ARRAY_BUFFER, vertices_);
    gl_.vertexAttribPointer(this.progImage_.getAttribute("aPosition"), vertices_.itemSize, gl_.FLOAT, false, 0, 0);

    var indices_ = this.rectIndicesBuffer_;
    gl_.bindBuffer(gl_.ELEMENT_ARRAY_BUFFER, indices_);

    this.progImage_.setMat4("uProjectionMatrix", this.imageProjectionMatrix_);

    this.progImage_.setMat4("uData", [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    this.progImage_.setVec4("uColor", (color_ != null ? color_ : [255,255,255,255]));
    this.progImage_.setFloat("uDepth", depth_ != null ? depth_ : 0);

    gl_.drawElements(gl_.TRIANGLES, indices_.numItems, gl_.UNSIGNED_SHORT, 0);
};

//draw 2d text - used for debuging
Vadstena.Renderer.prototype.drawText = function(x, y, size_, text_, color_, depth_) {

    if (this.imageProjectionMatrix_ == null) {
        return;
    }

    var gl_ = this.gpu_.gl_;

    gl_.disable(gl_.CULL_FACE);

    gl_.enable(gl_.DEPTH_TEST);

    if (depth_ == null) {
        gl_.disable(gl_.DEPTH_TEST);
    }

    this.gpu_.useProgram(this.progImage_, "aPosition", null);
    this.gpu_.bindTexture(this.textTexture_);

    var vertices_ = this.rectVerticesBuffer_;
    gl_.bindBuffer(gl_.ARRAY_BUFFER, vertices_);
    gl_.vertexAttribPointer(this.progImage_.getAttribute("aPosition"), vertices_.itemSize, gl_.FLOAT, false, 0, 0);

    var indices_ = this.rectIndicesBuffer_;
    gl_.bindBuffer(gl_.ELEMENT_ARRAY_BUFFER, indices_);

    this.progImage_.setMat4("uProjectionMatrix", this.imageProjectionMatrix_);
    this.progImage_.setVec4("uColor", color_);
    this.progImage_.setFloat("uDepth", depth_ != null ? depth_ : 0);

    var sizeX_ = size_;
    var sizeY_ = size_ * (7/4);

    var texelX_ = 1 / 64;
    var texelY_ = 1 / 8;


    var lx_ = x;

    for (var i = 0, li = text_.length; i < li; i++) {

        var char_ = text_.charAt(i);

        var charPos_ = this.textTable_[char_];

        this.progImage_.setMat4("uData", [
            x, y,  (charPos_ * texelX_), 0,
            x + sizeX_, y,  ((charPos_+4) * texelX_), 0,
            x + sizeX_, y + sizeY_, ((charPos_ + 4) * texelX_), texelY_*7,
            x,  y + sizeY_,  (charPos_ * texelX_), texelY_*7  ]);

        gl_.drawElements(gl_.TRIANGLES, indices_.numItems, gl_.UNSIGNED_SHORT, 0);

        x += sizeX_;
    }

    x = lx_ - 1;

    //draw black line before text
    var charPos_ = this.textTable_[" "];

    this.progImage_.setMat4("uData", [
        x, y,  (charPos_ * texelX_), 0,
        x + sizeX_, y,  ((charPos_+4) * texelX_), 0,
        x + sizeX_, y + sizeY_, ((charPos_ + 4) * texelX_), texelY_*7,
        x,  y + sizeY_,  (charPos_ * texelX_), texelY_*7  ]);

    gl_.drawElements(gl_.TRIANGLES, indices_.numItems, gl_.UNSIGNED_SHORT, 0);


    gl_.enable(gl_.CULL_FACE);

    if (depth_ == null) {
        gl_.enable(gl_.DEPTH_TEST);
    }

};

Vadstena.Renderer.prototype.paintGL = function()
{
    if (this.planet_ == null) {
        return;
    }

    this.debugCounter_ = 0; //TODO remove this counter

    var browserConfig_ = this.browser_.browserConfig_;

    if (browserConfig_.controlMode_ == "drone" && !this.heightInitialized_)
    {
        // at the beginning, adjust height of the camera according to the terrain
        var pair_ = Vadstena.surfaceHeight(this.browser_, this.position_, this.metaCache_);
        if (!pair_[1]) return;

        this.position_[2] += pair_[0];
        this.heightInitialized_ = true;
    }

    if (this.onlyDepth_ != true) {
        this.previousEdgesX_ = this.edgesX_;
        this.previousEdgesY_ = this.edgesY_;
        this.edgesX_ = [];
        this.edgesY_ = [];
    }

    if (browserConfig_.cameraConstrainMode_ == "aboveTerrainByPixelSize" || browserConfig_.cameraConstrainMode_  == "aboveTerrainByGSD") {
        //this.cameraMinDesiredDistance_ = Math.min((Vadstena.surfacePixelSize(this.browser_, this.position_, this.metaCache_, this.browser_.mapConfig_.maxHeightLod_)[0]/0.1)*180.0*1.403008, 180/*browserConfig_.cameraMinDistance_*/);
    } else {
        this.cameraMinDistance_ = this.browser_.browserConfig_.cameraMinDistance_;
        this.cameraConstrainDistance_ = this.browser_.browserConfig_.cameraConstrainDistance_;
    }

    this.constrainCamera();

    var maxPixelSize_ = 0;

    //hack for melown maps - ignore max pixel size
    if (browserConfig_.cameraConstrainMode_ == "aboveTerrainOnly" ||
        browserConfig_.cameraConstrainMode_ == "aboveTerrainByGSD" ||
        browserConfig_.cameraConstrainMode_ == "aboveTerrainByPixelSize") {

        this.constrainMotion(maxPixelSize_);

        this.gpu_.clear();

        this.updateCamera();

        if (this.onlyLayers_ != true) {
            if (this.onlyDepth_ != true && this.onlyHitLayers_ != true) {
                this.drawSkydome();
            }

            // draw the surface recursively, starting with the "Father of all tiles"
            maxPixelSize_ = this.planet_.draw();
            this.drawTiles(this.planet_);
        }

    } else {
        do
        {
            this.gpu_.clear();

            this.updateCamera();

            if (this.onlyLayers_ != true) {
                // draw the surface recursively, starting with the "Father of all tiles"
                maxPixelSize_ = this.planet_.draw();
                this.drawTiles(this.planet_);

                if (this.onlyDepth_ != true && this.onlyHitLayers_ != true) {
                    this.drawSkydome();
                }
            }
        }
        while (this.constrainMotion(maxPixelSize_));
    }

    //debug only - draw hit point
    /*
    if (this.onlyDepth_ != true) {
        this.drawBall(this.lastHitPosition_);
        var screenPos_ = this.project(this.lastHitPosition_);
        this.drawImage(screenPos_[0], screenPos_[1], 40, 40, this.skydomeTexture_);
    }*/

    //debug only - draw line

    if (this.onlyDepth_ != true && this.onlyHitLayers_ != true) {

        if (this.drawLayers_ == true) {
            this.drawLayers();
        }

        if (this.displayDrawTest_ == true) {
            //this.drawBall(this.lastHitPosition_);
            //var screenPos_ = this.project(this.lastHitPosition_);
            //this.drawImage(screenPos_[0], screenPos_[1], 40, 40, this.skydomeTexture_);
            this.drawTest();
        }
     }


    if (this.updateGeoHitmap_ == true) {
        this.drawHitmapGpuJobs(this.planet_);
        this.gpu_.setState(this.gpu_.defaultState_);
        this.updateGeoHitmap_ = false;
    }

    this.clearJobBuffer(this.planet_);

   //this.drawText(100, 100, 10, "0123456789.:LP")


    this.tilting_ = false;
};
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file


Vadstena.Renderer.prototype.setLayersVisible = function(id_, state_) {
    for (var i = 0, li = this.layers_.length; i < li; i++) {
        var layer_ = this.layers_[i];
        if (layer_.getId() == id_) {
            layer_.setVisible(state_);
        }
    }

    this.dirty_ = true;
};

Vadstena.Renderer.prototype.setLayersGroupVisible = function(id_, group_, state_) {
    for (var i = 0, li = this.layers_.length; i < li; i++) {
        var layer_ = this.layers_[i];
        if (layer_.getId() == id_) {
            layer_.setVisible(state_);
        }
    }

    this.dirty_ = true;
};

Vadstena.Renderer.prototype.createLayersIcon = function(id_, data_) {
    if (this.layerIcons_[id_] == null) {
        this.layerIcons_[id_] = new Vadstena.GpuTexture(this.gpu_, data_, this.browser_, null, true);
    }
};


Vadstena.Renderer.prototype.drawLayers = function(sketch_) {
    var gl_ = this.gpu_.gl_;

    if (this.layers_.length == 0) {
        return;
    }

    this.layerPlaces_ = [];

    //gl_.disable(gl_.DEPTH_TEST);
    gl_.stencilMask(0xFF);
    gl_.clear(gl_.STENCIL_BUFFER_BIT);

    gl_.stencilFunc(gl_.EQUAL, 0, 0xFF);
    gl_.stencilOp(gl_.KEEP, gl_.KEEP, gl_.INCR);

    var distance_ = this.position_[2];

    distance_ = distance_ * Math.tan(Vadstena.radians(this.camera_.getFov()));

//    var currentLod_ = 9;


    var currentLod_ = 0;
    if (distance_ < 180200) currentLod_ = 1;
    if (distance_ < 64200) currentLod_ = 2;
    if (distance_ < 32200) currentLod_ = 3;
    if (distance_ < 12200) currentLod_ = 4;
    if (distance_ < 2200) currentLod_ = 5;
    if (distance_ < 1200) currentLod_ = 6;
    if (distance_ < 900) currentLod_ = 7;
    if (distance_ < 600) currentLod_ = 8;
    if (distance_ < 360) currentLod_ = 9;
    if (distance_ < 180) currentLod_ = 10;

    var distanceFactor_ = (500/Math.max(10.0,distance_));
    var tiltFactor_ = 0.5 + 0.5 * (Math.abs(this.orientation_[1]/-90));
    var offsetFactor_ = 1.0 + (distanceFactor_ * distanceFactor_ * distanceFactor_)*0.5*tiltFactor_;

    //console.log("offsetFactor" + offsetFactor_);


    for (var i = 0, li = this.layers_.length; i < li; i++) {
        var layer_ = this.layers_[i];
        if (layer_.isVisible() == true) {
            var lod_ = layer_.getLod();
            if (lod_ == null || lod_ == currentLod_) {
                layer_.draw(offsetFactor_);
            }
        }
    }
};


Vadstena.Renderer.prototype.drawTest = function(sketch_)
{
        return;

        var gl_ = this.gpu_.gl_;

        //this.gpu_.clear(true);
        //gl_.stencilMask(0xFF);
        //gl_.clear(gl_.STENCIL_BUFFER_BIT);

        //gl_.disable(gl_.DEPTH_TEST);
        //gl_.disable(gl_.CULL_FACE);

           // var cameraPos2_ = this.camera_.getGlobalPosition();
        //var cameraPos_ = [0,0,0];
        var cameraPos2_ = this.camera_.getPosition();
        var cameraPos_ = this.cameraPosition();

        //var pos_ = [position_[0] - cameraPos_[0] + cameraPos2_[0], position_[1] - cameraPos_[1] + cameraPos2_[1], position_[2] - cameraPos_[2] + cameraPos2_[2] ];
        //    var pos_ = [position_[0] - cameraPos_[0], position_[1] - cameraPos_[1], position_[2] ];
//        var pos_ = [-this.position_[0], -this.position_[1], -this.position_[2]];
        var pos_ = [-this.position_[0], -this.position_[1], 0];
        //var pos_ = [-cameraPos_[0], -cameraPos_[1], -cameraPos_[2]];

        var domeMat_ = Vadstena.mat4.create();
        Vadstena.mat4.multiply(Vadstena.translationMatrix(pos_[0], pos_[1], pos_[2]), Vadstena.scaleMatrixf(1.0), domeMat_);
        //Vadstena.mat4.multiply(Vadstena.translationMatrix(this.camera_.getPosition()[0]+pos_[0], this.camera_.getPosition()[1]+pos_[1], this.camera_.getPosition()[2]), Vadstena.scaleMatrixf(21.5), domeMat_);

        var mvp_ = Vadstena.mat4.create();
        Vadstena.mat4.multiply(this.camera_.getMvpMatrix(), domeMat_, mvp_);

        var rotationview_ = this.camera_.getRotationviewMatrix();

//        this.gpu_.useProgram(this.progBBox_, "aPosition", null, null, "aNormal");
//        this.progBBox_.setMat4("uMVP", mvp_);

        for (var i = 0, li = this.sketches_.length; i < li; i++) {
            this.sketches_[i].draw(mvp_, rotationview_);
        }

        //gl_.enable(gl_.CULL_FACE);

        return;

//        gl_.polygonOffset(199.9, 199.9);
        gl_.polygonOffset(-199.9, -199.9);
        gl_.enable(gl_.POLYGON_OFFSET_FILL);

        gl_.blendEquationSeparate(gl_.FUNC_ADD, gl_.FUNC_ADD);
        gl_.blendFuncSeparate(gl_.SRC_ALPHA, gl_.ONE_MINUS_SRC_ALPHA, gl_.ONE, gl_.ONE_MINUS_SRC_ALPHA);

        //gl_.blendFunc(gl_.SRC_ALPHA, gl_.ONE);
        //gl_.enable(gl_.BLEND);

//        gl_.stencilFunc(gl_.NOTEQUAL, 0, 0xFF);
        gl_.stencilFunc(gl_.EQUAL, 0, 0xFF);
        gl_.stencilOp(gl_.KEEP, gl_.KEEP, gl_.INCR);
        gl_.enable(gl_.STENCIL_TEST);

        gl_.disable(gl_.STENCIL_TEST);

        //this.lineTest_.draw(this.progBBox_, "aPosition");
        this.lineTest_.draw(this.progLine3_, "aPosition", "aNormal");


        this.gpu_.useProgram(this.progText_, "aPosition", "aTexCoord");
        this.gpu_.bindTexture(this.font_.texture_);

        this.progText_.setSampler("uSampler", 0);
        this.progText_.setMat4("uMVP", mvp_);

        gl_.depthFunc(gl_.LEQUAL);

        //this.textTest_.draw(this.progText_, "aPosition", "aTexCoord");

        gl_.disable(gl_.BLEND);
        gl_.disable(gl_.POLYGON_OFFSET_FILL);

        gl_.enable(gl_.CULL_FACE);

};if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.Renderer.prototype.fogSetup = function(program_, fogDensity_)
{
    // the fog equation is: exp(-density*distance), this gives the fraction
    // of the original color that is still visible at some distance

    // we define visibility as a distance where only 5% of the original color
    // is visible; from this it is easy to calculate the correct fog density

    //var density_ = Math.log(0.05) / this.browser_.browserConfig_.cameraVisibility_;
    var density_ = Math.log(0.05) / (this.browser_.browserConfig_.cameraVisibility_ * 10*(Math.max(5,-this.orientation_[1])/90));
    density_ *= (5.0) / (Math.min(50000, Math.max(this.position_[2], 1000)) /5000);

    if (this.drawFog_ == false) {
        density_ = 0;
    }

    //console.log("fden: " + density_);

    //reduce fog when camera is facing down
    //density_ *= 1.0 - (-this.orientation_[0]/90)

    program_.setFloat(fogDensity_, density_);
};

Vadstena.Renderer.prototype.drawTerrainTile = function(tileId_, tile_, node_)
{
    //this.heightmapOnly_ = true;
    //this.gpu_.gl_.disable(this.gpu_.gl_.BLEND);

    //used for debug only
    if (this.logTilePos_ != null) {

        var tileSize_ = this.browser_.mapConfig_.tileSize(tileId_.lod_);

        if (this.logTilePos_[0] > tileId_.easting_ &&
            this.logTilePos_[0] < tileId_.easting_+tileSize_ &&
            this.logTilePos_[1] > tileId_.northing_ &&
            this.logTilePos_[1] < tileId_.northing_+tileSize_) {

                console.log("tile-hit: x:" + tileId_.easting_ + " y: " + tileId_.northing_  + " lod: " + tileId_.lod_ );
        }
    }

    this.renderMeshFileSize_ += tile_.meshFileSize_;
    this.renderImageFileSize_ += tile_.imageFileSize_;

    var gpuTile_ = this.gpuCache_.get(tileId_, tile_);
    var program_ = null;

    if (this.onlyDepth_ == true) {
        program_ = this.progDepthTile_; //for hit test use different program
    } else {
        switch (this.drawWireframe_) {
            case 0:
            default: program_ = this.progTile_; break;
            case 1: program_ = this.progWireframeTile_; break;
            case 2: program_ = this.progWireframeTile2_; break;
            case 3: program_ = this.progFlatShadeTile_; break;
        }
    }

    this.gpu_.useProgram(program_, "aPosition", "aTexCoord", this.drawWireframe_ == true ? "aBarycentric" : null);

    var mv_ = this.drawTileMatrix_;//Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.camera_.getModelviewMatrix(), tile_.getWorldMatrix(this.position_, this.drawTileWorldMatrix_), mv_);
    var proj_ = this.camera_.getProjectionMatrix();

    program_.setMat4("uMV", mv_);
    program_.setMat4("uProj", proj_);
    this.fogSetup(program_, "uFogDensity");

    this.gpu_.bindTexture(gpuTile_.texture_);
    //this.progTile_.setSampler("uSampler", 0);

    gpuTile_.mesh_.draw(program_, "aPosition", "aTexCoord", this.drawWireframe_ == true ? "aBarycentric" : null);


    if (this.onlyDepth_ != true) {

        //exclude hit test render from statistics
        this.gpuMemoryUsed_ += gpuTile_.mesh_.size() + gpuTile_.texture_.size();
        this.gpuMemoryTextures_ += gpuTile_.texture_.size();
        this.gpuMemoryMeshes_ += gpuTile_.mesh_.size();

        this.renderedTiles_++;
        this.renderedPolygons_ += gpuTile_.mesh_.getPolygons();
    }

    return gpuTile_;
};

Vadstena.Renderer.prototype.drawHeightmapTile = function(tileId_, tile_, node_)
{
    //return;

    if (this.blendHeightmap_ == true) {

        var min_ = node_.bbox_.min_;
        var max_ = node_.bbox_.max_;

        var x1 = min_[0];
        var y1 = min_[1];
        var x2 = max_[0];
        var y2 = max_[1];

        var edgesX_ = this.edgesX_;
        var edgesY_ = this.edgesY_;

        //store edges
        if (this.onlyDepth_ != true) {

            if (edgesX_[x1] == null) {
                edgesX_[x1] = [[y1, y2, tileId_, node_]];
            } else {
                edgesX_[x1].push([y1, y2, tileId_, node_]);
            }

            if (edgesX_[x2] == null) {
                edgesX_[x2] = [[y1, y2, tileId_, node_]];
            } else {
                edgesX_[x2].push([y1, y2, tileId_, node_]);
            }

            if (edgesY_[y1] == null) {
                edgesY_[y1] = [[x1, x2, tileId_, node_]];
            } else {
                edgesY_[y1].push([x1, x2, tileId_, node_]);
            }

            if (edgesY_[y2] == null) {
                edgesY_[y2] = [[x1, x2, tileId_, node_]];
            } else {
                edgesY_[y2].push([x1, x2, tileId_, node_]);
            }
        }

    }

    //for hit test use different program
    var program_ = (this.onlyDepth_ == true) ? this.progDepthHeightmap_ : this.progHeightmap_;

    this.gpu_.useProgram(program_, "aPosition", "aTexCoord");

    var mv_ = this.drawTileMatrix_;//Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.camera_.getModelviewMatrix(), node_.getWorldMatrix(this.position_, this.drawTileMatrix2_), mv_);

    program_.setMat4("uMV", mv_);

    var proj_ = this.camera_.getProjectionMatrix();
    program_.setMat4("uProj", proj_);

    var gridMat_ = this.drawTileMatrix2_;
    node_.getWorldMatrix(this.browser_.mapConfig_.lodAlign(this.position_, 11, this.drawTileVec_), gridMat_);
    program_.setMat4("uGridMat", gridMat_);

    this.fogSetup(program_, "uFogDensity");

    var embed_ = this.browser_.browserConfig_.gridEmbeddingFactor_;
    var minTile_ = this.browser_.browserConfig_.gridMinTileSize_;

    //var altitude_ = this.camera_.getPosition()[2] - 200 /* FIXME */;
    var bias_ = 20; // fine-tune appearance at ground level
    var altitude_ = Math.max(10.0, this.camera_.position_[2] - node_.avgHeight() + bias_);

    var gridSelect_ = (Math.log(altitude_) / Math.log(embed_));
    var step1_ = (Math.pow(embed_, Math.floor(gridSelect_)));
    var step2_ = (Math.pow(embed_, Math.ceil(gridSelect_)));
    var blend_ = (gridSelect_ - Math.floor(gridSelect_));
    //var blend_ = 0;

    program_.setFloat("uGridStep1", (minTile_ / step1_));
    program_.setFloat("uGridStep2", (minTile_ / step2_));
    program_.setFloat("uGridBlend", (blend_));

    if (this.blendHeightmap_ == true) {

        var terrain_ = this.planet_.getMainTerrain();

        function findEdge(array_, value_, skipTile_) {

            if (array_ == null) {
                return null;
            }

            for (var i = 0, li = array_.length; i < li; i++) {
                if (value_ >= array_[i][0] && value_ <= array_[i][1]) {

                    var newTile_ = array_[i][2];

                    if (!(newTile_.easting_ == tileId_.easting_ && newTile_.northing_ == tileId_.northing_)) {
                        return array_[i];
                    }
                }
            }

            return null;
        }


        edgesX_ = this.previousEdgesX_;
        edgesY_ = this.previousEdgesY_;

        topEdge_ = findEdge(edgesY_[y1], x1 + 0.01, tileId_);
        bottomEdge_ = findEdge(edgesY_[y2], x1 + 0.01, tileId_);

        leftEdge_ = findEdge(edgesX_[x1], y1 + 0.01, tileId_);
        rightEdge_ = findEdge(edgesX_[x2], y1 + 0.01, tileId_);


        var newHeightMap_ = node_.heightmap_.slice();


        if (topEdge_ != null) {

            var tmpTile_ = topEdge_[2];

            if (tmpTile_.lod_ < tileId_.lod_) {

                var tmpNode_ = topEdge_[3];

                for (var i = 0; i < 5; i++) {
                    var x = ((x2-x1) / 4) * i + x1;

                    newHeightMap_[i] = terrain_.surfaceTileHeight([x, y1], tmpTile_, tmpNode_);
                }
            }
        }


        if (bottomEdge_ != null) {

            var tmpTile_ = bottomEdge_[2];

            if (tmpTile_.lod_ < tileId_.lod_) {

                var tmpNode_ = bottomEdge_[3];
                var offset_ = 5*4;

                for (var i = 0; i < 5; i++) {
                    var x = ((x2-x1) / 4) * i + x1;

                    newHeightMap_[offset_+i] = terrain_.surfaceTileHeight([x, y2], tmpTile_, tmpNode_);
                }
            }
        }

        if (leftEdge_ != null) {

            var tmpTile_ = leftEdge_[2];

            if (tmpTile_.lod_ < tileId_.lod_) {

                var tmpNode_ = leftEdge_[3];

                for (var i = 0; i < 5; i++) {
                    var y = ((y2-y1) / 4) * i + y1;

                    newHeightMap_[i*5] = terrain_.surfaceTileHeight([x1, y], tmpTile_, tmpNode_);
                }
            }
        }

        if (rightEdge_ != null) {

            var tmpTile_ = rightEdge_[2];

            if (tmpTile_.lod_ < tileId_.lod_) {

                var tmpNode_ = rightEdge_[3];

                for (var i = 0; i < 5; i++) {
                    var y = ((y2-y1) / 4) * i + y1;

                    newHeightMap_[i*5+4] = terrain_.surfaceTileHeight([x2, y], tmpTile_, tmpNode_);
                }
            }
        }

        //process corners
        if (true) {

            var topLeftCorner_ = findEdge(edgesY_[y1], x1 - 0.01, tileId_);
            var topRightCorner_ = findEdge(edgesY_[y1], x2 + 0.01, tileId_);

            var bottomLeftCorner_ = findEdge(edgesY_[y2], x1 - 0.01, tileId_);
            var bottomRightCorner_ = findEdge(edgesY_[y2], x2 + 0.01, tileId_);

            var topLeftTile_ = null;

            if (topLeftCorner_ != null && topLeftCorner_[2].lod_ < tileId_.lod_) {
                topLeftTile_ = topLeftCorner_;
            }

            if (leftEdge_ != null && leftEdge_[2].lod_ < tileId_.lod_) {
                topLeftTile_ = leftEdge_;
            }

            if (topEdge_ != null && topEdge_[2].lod_ < tileId_.lod_) {
                topLeftTile_ = topEdge_;
            }

            if (topLeftTile_ != null) {
                newHeightMap_[0] = terrain_.surfaceTileHeight([x1, y1], topLeftTile_[2], topLeftTile_[3]);
            }



            var topRightTile_ = null;

            if (topRightCorner_ != null && topRightCorner_[2].lod_ < tileId_.lod_) {
                topRightTile_ = topRightCorner_;
            }

            if (rightEdge_ != null && rightEdge_[2].lod_ < tileId_.lod_) {
                topRightTile_ = rightEdge_;
            }

            if (topEdge_ != null && topEdge_[2].lod_ < tileId_.lod_) {
                topRightTile_ = topEdge_;
            }

            if (topRightTile_ != null) {
                newHeightMap_[4] = terrain_.surfaceTileHeight([x2, y1], topRightTile_[2], topRightTile_[3]);
            }



            var bottomLeftTile_ = null;

            if (bottomLeftCorner_ != null && bottomLeftCorner_[2].lod_ < tileId_.lod_) {
                bottomLeftTile_ = bottomLeftCorner_;
            }

            if (leftEdge_ != null && leftEdge_[2].lod_ < tileId_.lod_) {
                bottomLeftTile_ = leftEdge_;
            }

            if (bottomEdge_ != null && bottomEdge_[2].lod_ < tileId_.lod_) {
                bottomLeftTile_ = bottomEdge_;
            }

            if (bottomLeftTile_ != null) {
                newHeightMap_[5*4] = terrain_.surfaceTileHeight([x1, y2], bottomLeftTile_[2], bottomLeftTile_[3]);
            }



            var bottomRightTile_ = null;

            if (bottomRightCorner_ != null && bottomRightCorner_[2].lod_ < tileId_.lod_) {
                bottomRightTile_ = bottomRightCorner_;
            }

            if (rightEdge_ != null && rightEdge_[2].lod_ < tileId_.lod_) {
                bottomRightTile_ = rightEdge_;
            }

            if (bottomEdge_ != null && bottomEdge_[2].lod_ < tileId_.lod_) {
                bottomRightTile_ = bottomEdge_;
            }

            if (bottomRightTile_ != null) {
                newHeightMap_[5*4+4] = terrain_.surfaceTileHeight([x2, y2], bottomRightTile_[2], bottomRightTile_[3]);
            }


        }

        program_.setFloatArray("uHeight", newHeightMap_);

    } else {

        program_.setFloatArray("uHeight", node_.heightmap_);

    }


    this.gpu_.bindTexture(this.heightmapTexture_);
    //program_.setSampler("uSampler", 0);

    this.heightmapMesh_.draw(program_, "aPosition", "aTexCoord");

    //if ((bottomEdge_ == null || topEdge_ == null || leftEdge_ == null || rightEdge_ == null)) {

        //var pos_ = this.project([x1+1, y1+1, max_[2]+1]);
        //this.drawText(Math.round(pos_[0]), Math.round(pos_[1]-10), 4, "" + (this.debugCounter_++), [255,0,255,255], pos_[2]-1);
    //}

//        if (tileId_.easting_ == 620256 && tileId_.northing_ == 5411872) {
    //if (tileId_.easting_ == 621280 && tileId_.northing_ == 5411872) {

        //tileId_ = tileId_;

        //bottomEdge_ = findEdge(edgesY_[y2], x1 + 0.01);

    //}

    /*
    if (bottomEdge_ != null) {

        var tmpTile_ = bottomEdge_[2];

        if (tmpTile_.lod_ < tileId_.lod_) {

            var tmpNode_ = bottomEdge_[3];

            for (var i = 0; i < 5; i++) {
                var x = ((x2-x1) / 5) * i + x1;

                var h = Vadstena.surfaceTileHeight(this.browser_, [x, y2], tmpTile_, tmpNode_);

                var pos_ = this.project([x, y2, h]);
                this.drawText(Math.round(pos_[0]), Math.round(pos_[1]-10), 4, ""+tmpTile_.lod_, [255,0,255,255], pos_[2]-1);
            }
        }
    }

    if (topEdge_ != null) {

        var tmpTile_ = topEdge_[2];

        if (tmpTile_.lod_ < tileId_.lod_) {

            var tmpNode_ = topEdge_[3];

            for (var i = 0; i < 5; i++) {
                var x = ((x2-x1) / 5) * i + x1;

                var h = Vadstena.surfaceTileHeight(this.browser_, [x, y1], tmpTile_, tmpNode_);

                var pos_ = this.project([x, y1, h]);
                this.drawText(Math.round(pos_[0]), Math.round(pos_[1]-10), 4, ""+tmpTile_.lod_, [0,255,255,255], pos_[2]-1);
            }
        }
    }
    */



    if (this.onlyDepth_ != true) { //exclude hit test render from statistics
        this.renderedHTiles_++;
        this.renderedPolygons_ += this.heightmapMesh_.getPolygons();
    }
};

Vadstena.Renderer.prototype.drawGeodataTile = function(tileId_, tile_, node_)
{
    var gpuTile_ = this.gpuCache_.get(tileId_, tile_);

    if (gpuTile_ != null) {

        if (gpuTile_.isReady() == true) {
            var mvp_ = Vadstena.mat4.create();
            //var mv_ = this.drawTileMatrix_;//Vadstena.mat4.create();
            var mv_ = Vadstena.mat4.create();
            Vadstena.mat4.multiply(this.camera_.getModelviewMatrix(), node_.getWorldMatrix3(this.position_, this.drawTileMatrix2_), mv_);

            //var mv_ = this.drawTileMatrix_;
            //Vadstena.mat4.multiply(this.camera_.getModelviewMatrix(), node_.getWorldMatrix2(this.position_, this.drawTileWorldMatrix_), mv_);

            var proj_ = this.camera_.getProjectionMatrix();
            Vadstena.mat4.multiply(proj_, mv_, mvp_);

            gpuTile_.draw(mv_, mvp_);
        } else {
            this.gpuTilesWaiting_[this.gpuTilesWaitingSize_] = gpuTile_;
            this.gpuTilesWaitingSize_++;
        }
    }

};

Vadstena.Renderer.prototype.drawDebugTile = function(tileId_, tile_, node_, gpuTile_, terrain_)
{
    this.gpu_.useProgram(this.progBBox_, "aPosition");

    var mvp_ = Vadstena.mat4.create();
    //Vadstena.mat4.multiply(proj_, mv_, mvp_);

    var mv_ = this.drawTileMatrix_;//Vadstena.mat4.create();
    Vadstena.mat4.multiply(this.camera_.getModelviewMatrix(), node_.getWorldMatrix2(this.position_, this.drawTileWorldMatrix_), mv_);

    var proj_ = this.camera_.getProjectionMatrix();
    Vadstena.mat4.multiply(proj_, mv_, mvp_);


    this.progBBox_.setMat4("uMVP", mvp_);

    //draw bbox
    this.bboxMesh_.draw(this.progBBox_, "aPosition");

    var min_ = node_.bbox_.min_;
    var max_ = node_.bbox_.max_;

    var pos_ = this.project([min_[0] + (max_[0] - min_[0])*0.5, min_[1] + (max_[1] - min_[1])*0.5, max_[2]]);

    //draw positions
    if (this.drawPositions_ == true) {
        var text_ = "" + tileId_.easting_ + " " + tileId_.northing_;
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-11), 4, text_, [0,255,255,255], pos_[2]);
    }

    //draw texture size
    if (this.drawTextureSize_ == true && gpuTile_ != null) {
        var text_ = "" + gpuTile_.texture_.width_ + " x " + gpuTile_.texture_.height_;
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-18), 4, text_, [255,255,255,255], pos_[2]);
    }

    //draw lods
    if (this.drawLods_ == true) {
        text_ = "" + tileId_.lod_;
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-4), 4, text_, [255,0,0,255], pos_[2]);
    }

    //draw texel size
    if (this.drawFaceCount_ == true && gpuTile_ != null) {
        var text_ = "" + gpuTile_.mesh_.polygons_;
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]+3), 4, text_, [0,255,0,255], pos_[2]);
    }

    //draw distance
    if (this.drawDistance_ == true) {

        ///if (tileId_.easting_ == "679392" && tileId_.northing_ == "5437984" && tileId_.lod_ == "15") {
           // tileId_ = tileId_;
        //}
        var value_ = this.planet_.getMainTerrain().tilePixelSize(node_, true);
        var text_ = "" + value_[1].toFixed(2) + " " + value_[0].toFixed(2);
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]+10), 4, text_, [255,0,255,255], pos_[2]);
    }

    //draw texel size
    if (this.drawTexelSize_ == true) {
        //text size top left
        pos_ = this.project([min_[0] + (max_[0] - min_[0])*0.1, min_[1] + (max_[1] - min_[1])*0.1, max_[2]]);

        text_ = "" + node_.pixelSize_[0][0].toFixed(3);
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-4), 4, text_, [255,255,0,255], pos_[2]);

        //text size top right
        pos_ = this.project([min_[0] + (max_[0] - min_[0])*0.9, min_[1] + (max_[1] - min_[1])*0.1, max_[2]]);

        text_ = "" + node_.pixelSize_[0][1].toFixed(3);
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-4), 4, text_, [255,255,0,255], pos_[2]);

        //text size bottom right
        pos_ = this.project([min_[0] + (max_[0] - min_[0])*0.9, min_[1] + (max_[1] - min_[1])*0.9, max_[2]]);

        text_ = "" + node_.pixelSize_[1][1].toFixed(3);
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-4), 4, text_, [255,255,0,255], pos_[2]);

        //text size bottom left
        pos_ = this.project([min_[0] + (max_[0] - min_[0])*0.1, min_[1] + (max_[1] - min_[1])*0.9, max_[2]]);

        text_ = "" + node_.pixelSize_[1][0].toFixed(3);
        this.drawText(Math.round(pos_[0]-(text_.length*4)*0.5), Math.round(pos_[1]-4), 4, text_, [255,255,0,255], pos_[2]);
    }

};

Vadstena.Renderer.prototype.drawTile = function(planet_, tileInfo_, gpuMemoryLimit_) {

    var tileId_ = tileInfo_[1];
    var tile_ = tileInfo_[2];

    //stats stuff
    if (this.renderLODs_[tileId_.lod_] == null) {
        this.renderLODs_[tileId_.lod_] = 1;
    } else {
        this.renderLODs_[tileId_.lod_]++;
    }

    //switch according to tile type
    switch(tileInfo_[0]) {

        case Vadstena.TileType.Terrain:

            var gpuTile_ = null;

            //draw terrain if posible
            if (tile_ && !this.heightmapOnly_ && this.gpuMemoryUsed_ < gpuMemoryLimit_) {
                gpuTile_ = this.drawTerrainTile(tileId_, tile_, tileInfo_[3]);
            } else { // draw the heightfield if the tile has not been downloaded yet
                this.drawHeightmapTile(tileId_, tile_, tileInfo_[3]);
            }

            if (this.onlyDepth_ != true) {
                if (this.drawBBoxes_ == true) {
                    this.drawDebugTile(tileId_, tile_, tileInfo_[3], gpuTile_);
                }
            }

            break;

        case Vadstena.TileType.Geodata:

            this.drawGeodataTile(tileId_, tile_, tileInfo_[3]);
            break;

    }
};

Vadstena.Renderer.prototype.getZoffsetFactor = function(params_) {
    var offsetFactor_ = 1.0 + this.distanceFactor_*params_[1]*((1-params_[2])+params_[2]*this.tiltFactor_);
    return -Math.round(2000 * offsetFactor_ * params_[0]);
};

Vadstena.Renderer.prototype.drawGpuJobs = function(planet_) {

    //setup stencil
    var gpu_ = this.gpu_;
    var gl_ = gpu_.gl_;

    gl_.stencilMask(0xFF);
    gl_.clear(gl_.STENCIL_BUFFER_BIT);

    gl_.stencilFunc(gl_.EQUAL, 0, 0xFF);
    gl_.stencilOp(gl_.KEEP, gl_.KEEP, gl_.INCR);


    var distance_ = this.position_[2];
    distance_ = distance_ * Math.tan(Vadstena.radians(this.camera_.getFov()));
    var distanceFactor_ = (500/Math.max(10.0,distance_));
    this.distanceFactor_ = (distanceFactor_ * distanceFactor_ * distanceFactor_)*0.5;
    this.tiltFactor_ = 0.5 + 0.5 * (Math.abs(this.orientation_[1]/-90));

    var zoffset_ = this.getZoffsetFactor([1,1,1]);

    Vadstena.StencilLineState_ = this.gpu_.createState({blend_:true, stencil_:true, zoffset_:zoffset_, culling_: false});
    Vadstena.LineLabelState_ = this.gpu_.createState({blend_:true, zoffset_:zoffset_, culling_: false});


    var screenPixelSize_ = [1.0/this.curSize_[0], 1.0/this.curSize_[1]];

    //this.updateGeoHitmap_ = this.dirty_;

    var clearPass_ = 513;
    var clearPassIndex_ = 0;

    if (this.clearStencilPasses_.length > 0) {
        clearPass_ = this.clearStencilPasses_[0];
        clearPassIndex_++;
    }

    //draw job buffer and also clean buffer
    for (var i = 0, li = planet_.jobZBuffer_.length; i < li; i++) {
        var lj = planet_.jobZBufferSize_[i];
        var buffer_ = planet_.jobZBuffer_[i];

        if (lj > 0 && i >= clearPass_) {
            gl_.clear(gl_.STENCIL_BUFFER_BIT);

            if (this.clearStencilPasses_.length > clearPassIndex_) {
                clearPass_ = this.clearStencilPasses_[clearPassIndex_];
                clearPassIndex_++;
            } else {
                clearPass_ = 513;
            }
        }

        for (var j = 0; j < lj; j++) {
            Vadstena.drawGpuJob(gpu_, gl_, this, buffer_[j], screenPixelSize_);
            //buffer_[j] = null;
        }

        //planet_.jobZBufferSize_[i] = 0;
    }
};

Vadstena.Renderer.prototype.drawHitmapGpuJobs = function(planet_) {

    //return;
    var gpu_ = this.gpu_;
    var gl_ = gpu_.gl_;

    this.hoverFeatureCounter_ = 0;

    var size_ = this.hitmapSize_;

    //set texture framebuffer
    this.gpu_.setFramebuffer(this.geoHitmapTexture_);

    var oldSize_ = [ this.curSize_[0], this.curSize_[1] ];

    var width_ = size_;
    var height_ = size_;

    gl_.clearColor(1.0,1.0, 1.0, 1.0);
    gl_.enable(gl_.DEPTH_TEST);

    //clear screen
    gl_.viewport(0, 0, size_, size_);
    gl_.clear(gl_.COLOR_BUFFER_BIT | gl_.DEPTH_BUFFER_BIT);

    this.curSize_ = [width_, height_];

    //render scene
    this.onlyHitLayers_ = true;
    //this.paintGL();

    this.gpu_.clear();
    this.updateCamera();

    //this.camera_.update();
    this.drawGpuJobs(planet_);

    this.onlyHitLayers_ = false;

    //return screen framebuffer
    width_ = oldSize_[0];
    height_ = oldSize_[1];

    gl_.clearColor(0.0, 0.0, 0.0, 1.0);

    this.gpu_.setFramebuffer(null);

    this.camera_.setAspect(width_ / height_);
    this.curSize_ = [width_, height_];
    this.gpu_.resize(this.curSize_, true);
    this.camera_.update();
    this.updateCamera();

/*
    var m = [];
    m[0] = 2.0/width_; m[1] = 0; m[2] = 0; m[3] = 0;
    m[4] = 0; m[5] = -2.0/height_; m[6] = 0; m[7] = 0;
    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
    m[12] = -width_*0.5*m[0]; m[13] = -height_*0.5*m[5]; m[14] = 0; m[15] = 1;
    this.imageProjectionMatrix_ = m;
*/

};

Vadstena.Renderer.prototype.clearJobBuffer = function(planet_) {

    //clean job buffer
    for (var i = 0, li = planet_.jobZBuffer_.length; i < li; i++) {
        var lj = planet_.jobZBufferSize_[i];
        var buffer_ = planet_.jobZBuffer_[i];

        for (var j = 0; j < lj; j++) {
            buffer_[j] = null;
        }

        planet_.jobZBufferSize_[i] = 0;
    }

};

Vadstena.Renderer.prototype.drawTiles = function(planet_) {

    var tileBuffer_ = planet_.getTileBuffer();
    var tileBufferSize_ = planet_.getTileBufferSize();
    var gpuMemoryLimit_ = this.browser_.browserConfig_.gpuCacheSize_ - (20 * 1024 * 1024);

    if (!(this.onlyHitLayers_ == true || this.onlyLayers_ == true)) {
        //draw terrain
        for (var i = planet_.terrainTiles_ - 1; i >= 0; i--) {
            this.drawTile(planet_, tileBuffer_[i], gpuMemoryLimit_);
        }
    }

    if (this.onlyDepth_ != true) {

        //draw tiled geolayers
        for (var i = planet_.terrainTiles_; i < tileBufferSize_; i++) {
            this.drawTile(planet_, tileBuffer_[i]);
        }

        //draw geolayers
        var layers_ = planet_.layers_;
        for (var i = 0, li = layers_.length; i < li; i++) {
            layers_[i].draw();
        }
    }

    this.drawGpuJobs(planet_);


    this.gpu_.setState(this.gpu_.defaultState_);
};



if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.TileId = function(browser_, lod_, easting_, northing_, layerId_)
{
    this.browser_ = browser_;
    this.lod_ = (lod_ != null) ? lod_ : 0;
    this.easting_ = (easting_ != null) ? easting_ : 0;
    this.northing_ = (northing_ != null) ? northing_ : 0;
    this.layerId_ = layerId_ || 0;
};

Vadstena.TileId.prototype.clone = function() {
    return new Vadstena.TileId(this.browser_, this.lod_, this.easting_, this.northing_, this.layerId_);
};

Vadstena.TileId.prototype.child = function(index_)
{
    var size_ = this.browser_.mapConfig_.tileSize(this.lod_);

    var midx_ = (this.easting_ + size_/2);
    var midy_ = (this.northing_ + size_/2);

    switch (index_) {
    case 0: return new Vadstena.TileId(this.browser_, this.lod_+1, this.easting_, this.northing_, this.layerId_); // lower-left
    case 1: return new Vadstena.TileId(this.browser_, this.lod_+1, midx_, this.northing_, this.layerId_); // lower-right
    case 2: return new Vadstena.TileId(this.browser_, this.lod_+1, this.easting_, midy_, this.layerId_); // upper-left
    case 3: return new Vadstena.TileId(this.browser_, this.lod_+1, midx_, midy_, this.layerId_); // upper-right
    }
};


Vadstena.TileId.prototype.parent = function()
{
    var size_ = this.browser_.mapConfig_.tileSize(this.lod_);

    var foat_ = this.browser_.mapConfig_.foat_;
    var ix_ = ((this.easting_ - foat_.easting_) / size_);
    var iy_ = ((this.northing_ - foat_.northing_) / size_);

    return new Vadstena.TileId(this.browser_, this.lod_-1, foat_.easting_ + (ix_ & ~1)*size_, foat_.northing_ + (iy_ & ~1)*size_);
};

Vadstena.TileId.prototype.isEqual = function(rhs_)
{
    return this.lod_ == rhs_.lod_ &&
           this.easting_ == rhs_.easting_ &&
           this.northing_ == rhs_.northing_;
};

Vadstena.TileId.prototype.isNotEqual = function(rhs_)
{
    return !this.isEqual(rhs_);
};
//! Downloaded and decoded tile data.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.TileTerrain = function(browser_, id_, mesh_, image_)
{
    this.browser_ = browser_;
    this.id_ = id_;
    this.type_ = "terrain";
    this.mesh_ = mesh_;
    this.image_ = image_;
    this.size_ = this.mesh_.size() + (image_.naturalWidth * image_.naturalHeight * 3);
    this.meshFileSize_ = mesh_.fileSize();
    this.imageFileSize_ = (image_.naturalWidth * image_.naturalHeight * 3);
};

Vadstena.TileTerrain.prototype.kill = function() {

    if (this.mesh_ != null) {
        this.mesh_.kill();
        this.mesh_ = null;
    }

    this.image_ = null;
};

Vadstena.TileTerrain.prototype.getWorldMatrix = function(geoPos_, matrix_) //Vadstena.vec2
{
    var tileSize_ = this.browser_.mapConfig_.tileSize(this.id_.lod_);
    var shiftX_ = tileSize_/2 + this.id_.easting_ - geoPos_[0];
    var shiftY_ = tileSize_/2 + this.id_.northing_ - geoPos_[1];

    var box_ = this.mesh_.bbox_;

    var m = matrix_;

    if (m != null) {
        m[0] = box_.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = box_.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = box_.side(2); m[11] = 0;
        m[12] = box_.min_[0] + shiftX_; m[13] = box_.min_[1] + shiftY_; m[14] = box_.min_[2]; m[15] = 1;
    } else {
        m = Vadstena.mat4.create();

        Vadstena.mat4.multiply(Vadstena.translationMatrix(box_.min_[0] + shiftX_, box_.min_[1] + shiftY_, box_.min_[2]),
                             Vadstena.scaleMatrix(box_.side(0), box_.side(1), box_.side(2)), m);
    }

    return m;
};

//! Returns RAM usage in bytes.
Vadstena.TileTerrain.prototype.size = function() {
    return this.size_;
};

//! Unlike MetaCache, the TileCache is just the DownloadCache itself.
Vadstena.TileTerrainCache = Vadstena.DownloadCache;

Vadstena.TileTerrainDownload = function(browser_, id_, onLoaded_, onError_)
{
    this.browser_ = browser_;
    this.id_ = id_;
    this.onLoaded_ = onLoaded_;
    this.onError_ = onError_;

    this.meshLoaded_ = false;
    this.imageLoaded_ = false;
    this.error_ = false;

    this.checkLoaded_ = (function(){

        if (this.error_ == true) {
            if (this.onError_ != null) {

                //degug
                //var node_ = this.id_.browser_.renderer_.metaCache_.get(this.id_);

                this.onError_(this.id_);
            }
        } else if (this.meshLoaded_ == true && this.imageLoaded_ == true) {
            if (this.onLoaded_ != null) {
                this.onLoaded_(this.id_, new Vadstena.TileTerrain(this.browser_, this.id_, this.mesh_, this.image_));
            }
        }

    }).bind(this);

    //load image
    this.image_ = new Image();
    this.image_.onload = (function () {

        if (this.browser_.killed_ == true){
            return;
        }

        this.imageLoaded_ = true;
        this.checkLoaded_();
    }).bind(this);

    this.image_.onerror = (function () {

        if (this.browser_.killed_ == true){
            return;
        }

        this.error_ = true;
        this.checkLoaded_();
    }).bind(this);

    this.image_.crossOrigin = "anonymous";

    if (Vadstena.noTextures_ == true) {
        this.imageLoaded_ = true; //hack
    } else {
        this.image_.src = this.browser_.mapConfig_.textureUrl(this.id_);
    }

    //load mesh
    this.mesh_ = new Vadstena.Mesh(this.browser_);

    this.onMeshLoaded_ = (function(){

        if (this.browser_.killed_ == true){
            return;
        }

        this.meshLoaded_ = true;
        this.checkLoaded_();
    }).bind(this);

    this.onMeshError_ = (function(){

        if (this.browser_.killed_ == true){
            return;
        }

        this.error_ = true;
        this.checkLoaded_();
    }).bind(this);

    this.mesh_.load(this.browser_.mapConfig_.meshUrl(this.id_), this.onMeshLoaded_, this.onMeshError_);
};




//! Downloaded and decoded tile data.

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.TileGeodata = function(layer_, id_, type_, geodata_)
{
    this.layer_ = layer_;
    this.browser_ = layer_.browser_;
    this.id_ = id_;
    this.type_ = type_;
    this.geodata_ = geodata_;
    this.geodataSize_ = geodata_.length;
};

Vadstena.TileGeodata.prototype.kill = function() {
    this.geodata_ = null;
};


Vadstena.TileGeodata.prototype.getWorldMatrix = function(geoPos_, matrix_) //Vadstena.vec2
{
    var tileSize_ = this.browser_.mapConfig_.tileSize(this.id_.lod_);
    var shiftX_ = tileSize_/2 + this.id_.easting_ - geoPos_[0];
    var shiftY_ = tileSize_/2 + this.id_.northing_ - geoPos_[1];

    var box_ = this.mesh_.bbox_;

    var m = matrix_;
/*
    if (m != null) {
        m[0] = box_.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = box_.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = box_.side(2); m[11] = 0;
        m[12] = box_.min_[0] + shiftX_; m[13] = box_.min_[1] + shiftY_; m[14] = box_.min_[2]; m[15] = 1;
    } else {
        m = Vadstena.mat4.create();

        Vadstena.mat4.multiply(Vadstena.translationMatrix(box_.min_[0] + shiftX_, box_.min_[1] + shiftY_, box_.min_[2]),
                             Vadstena.scaleMatrix(box_.side(0), box_.side(1), box_.side(2)), m);
    }
*/
    return m;
};

//! Returns RAM usage in bytes.
Vadstena.TileGeodata.prototype.size = function() {

    switch(this.type_){
        case "geodata": return this.geodataSize_;
    }

};

//! Unlike MetaCache, the TileCache is just the DownloadCache itself.
Vadstena.TileGeodataCache = Vadstena.DownloadCache;

Vadstena.TileGeodataDownload = function(browser_, id_, onLoaded_, onError_, layer_)
{
    this.browser_ = browser_;
    this.id_ = id_;
    this.onLoaded_ = onLoaded_;
    this.onError_ = onError_;

    var onLoaded_ = (function(data_) {

        var tile_ = new Vadstena.TileGeodata(layer_, id_, layer_.type_, data_);

        //id_.layerInnerId_ = layer_.innerId_;
        this.onLoaded_(this.id_, tile_);
        //id_.layerInnerId_ = null;

        this.browser_.renderer_.dirty_ = true;

    }).bind(this);

    var onError_ = function() {

    };

    var path_ = browser_.mapConfig_.makeUrl(layer_.urlTemplate_, id_, true);

    //load

    switch(layer_.type_) {
        case "geodata":
            Vadstena.loadJSON(path_, onLoaded_, onError_.bind(this), true);
            break;
    }

};





if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.MetaNodeHMSize_ = 5;

//! Stores metadata for a tile.
/**
 * @constructor
 */
Vadstena.MetaNode = function(browser_, id_, stream_, version_, parentNode_)
{
    this.browser_ = browser_;
    this.bbox_ = new Vadstena.BBox;
    this.pixelSize_ = []; //2x2
    this.heightmap_ = []; //[HMSize][HMSize];
    this.childFlags_ = 0;
    this.sons_ = [];
    this.gsd_ = 0.01;

    for (var i = 0; i < 2; i++) {
        this.pixelSize_[i] = [];
    }

    if (parentNode_ != null) {
        this.createDirectly(id_, parentNode_);
        return;
    }



    //for (var i = 0, li = Vadstena.MetaNodeHMSize_; i < li; i++) {
      //  this.heightmap_[i] = [];
    //}
    var streamData_ = stream_.data_;

    var zmin_ = streamData_.getInt16(stream_.index_, true); stream_.index_ += 2;
    var zmax_ = streamData_.getInt16(stream_.index_, true); stream_.index_ += 2;

    this.bbox_.min_[0] = id_.easting_;
    this.bbox_.min_[1] = id_.northing_;
    this.bbox_.min_[2] = zmin_;

    var size_ = this.browser_.mapConfig_.tileSize(id_.lod_);
    this.bbox_.max_[0] = id_.easting_ + size_;
    this.bbox_.max_[1] = id_.northing_ + size_;
    this.bbox_.max_[2] = zmax_;

    if (version_ > 2) {
        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
                this.pixelSize_[i][j] = Vadstena.decodeFloat16( streamData_.getUint16(stream_.index_, true) ); stream_.index_ += 2;
            }
        }

        //gsd
        this.gsd_ = Vadstena.decodeFloat16( streamData_.getUint16(stream_.index_, true) ); stream_.index_ += 2;

        //coarseness
        streamData_.getUint16(stream_.index_, true); stream_.index_ += 2;
    } else {
        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
                this.pixelSize_[i][j] = streamData_.getFloat32(stream_.index_, true); stream_.index_ += 4;
            }
        }
    }


    if (version_ > 1) {

        var hmin_ = streamData_.getInt16(stream_.index_, true); stream_.index_ += 2;
        var hmax_ = streamData_.getInt16(stream_.index_, true); stream_.index_ += 2;

        for (var i = 0, li = Vadstena.MetaNodeHMSize_*Vadstena.MetaNodeHMSize_; i < li; i++) {
///            this.heightmap_[i] = hmin_ + (hmax_ - hmin_) * ((streamData_.getInt16(stream_.index_, true)+32768) / 65535); stream_.index_ += 2;
            this.heightmap_[i] = hmin_ + (streamData_.getInt16(stream_.index_, true) + 32768 ) * ((hmax_ - hmin_) / 65535); stream_.index_ += 2;
        }
    } else {
        for (var i = 0, li = Vadstena.MetaNodeHMSize_*Vadstena.MetaNodeHMSize_; i < li; i++) {
            this.heightmap_[i] = streamData_.getInt16(stream_.index_, true); stream_.index_ += 2;
        }
    }

    for (var i = 0; i < 4; i++) {
        this.sons_[i] = null;//nullptr;
    }

    this.childFlags_ = 0; // will be set in loadTree
};

//used only for virtual meta nodes
Vadstena.MetaNode.prototype.kill = function() {

};

//used only for virtual meta nodes
Vadstena.MetaNode.prototype.createDirectly = function(id_, parentNode_)
{
    var node_ = parentNode_;
    var size_ = this.browser_.mapConfig_.tileSize(id_.lod_);

    var x1 = id_.easting_;
    var y1 = id_.northing_;

    var x2 = x1 + size_;
    var y2 = y1 + size_;

    //set pixel size, 0 means no geometry
    this.pixelSize_[0][0] = 0;//node_.getPixelSize(id_, x1, y1, node_) * 0.5;
    this.pixelSize_[0][1] = 0;//node_.getPixelSize(id_, x2, y1, node_) * 0.5;
    this.pixelSize_[1][0] = 0;//node_.getPixelSize(id_, x1, y2, node_) * 0.5;
    this.pixelSize_[1][1] = 0;//node_.getPixelSize(id_, x2, y2, node_) * 0.5;

    var hmax_ = Number.NEGATIVE_INFINITY;
    var hmin_ = Number.POSITIVE_INFINITY;
    var step_ = (x2 - x1) / 5;

    //set height map
    for (var j = 0; j < 5; j++) {
        for (var i = 0; i < 5; i++) {
            var height_ = node_.getHeight(id_, x1 + step_*i, y1 + step_*j, node_);
            this.heightmap_[j * 5  + i] = height_;

            if (height_ > hmax_) {
                hmax_ = height_;
            }

            if (height_ < hmin_) {
                hmin_ = height_;
            }
        }
    }

    this.bbox_.min_[0] = x1;
    this.bbox_.min_[1] = y1;
    this.bbox_.min_[2] = hmin_;

    this.bbox_.max_[0] = x2;
    this.bbox_.max_[1] = y2;
    this.bbox_.max_[2] = hmax_;
};

Vadstena.MetaNode.prototype.getHeight = function(tileId_, x, y, parentNode_)
{
    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var x = ((x - this.bbox_.min_[0]) / tileSize_);
    var y = ((y - this.bbox_.min_[1]) / tileSize_);

    // do bilinear interpolation of the heightmap values
    var eps_ = 1e-4;
    x = Vadstena.clamp(x, 0.0, 1.0 - eps_);
    y = Vadstena.clamp(y, 0.0, 1.0 - eps_);

    var metaNodeHMSize_ = Vadstena.MetaNodeHMSize_;

    var hx = (x * (metaNodeHMSize_-1));
    var hy = (y * (metaNodeHMSize_-1));
    var ix = (Math.floor(hx)), iy = (Math.floor(hy));

    var v00 = (parentNode_.heightmap_[iy*metaNodeHMSize_ + ix]);
    var v01 = (parentNode_.heightmap_[iy*metaNodeHMSize_ + ix+1]);
    var v10 = (parentNode_.heightmap_[(iy+1)*metaNodeHMSize_ + ix]);
    var v11 = (parentNode_.heightmap_[(iy+1)*metaNodeHMSize_ + ix+1]);

    var fx = (hx - ix), fy = (hy - iy);
    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);

    return (w0 + (w1 - w0)*fy);
};

Vadstena.MetaNode.prototype.getPixelSize = function(tileId_, x, y, parentNode_)
{
    var tileSize_ = (this.browser_.mapConfig_.tileSize(tileId_.lod_));
    var fx = ((x - this.bbox_.min_[0]) / tileSize_);
    var fy = ((y - this.bbox_.min_[1]) / tileSize_);

    // do bilinear interpolation of the heightmap values
    var eps_ = 1e-4;
    x = Vadstena.clamp(x, 0.0, 1.0 - eps_);
    y = Vadstena.clamp(y, 0.0, 1.0 - eps_);

    var v00 = parentNode_.pixelSize_[0][0];
    var v01 = parentNode_.pixelSize_[0][1];
    var v10 = parentNode_.pixelSize_[1][0];
    var v11 = parentNode_.pixelSize_[1][1];

    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);

    return (w0 + (w1 - w0)*fy);
};

// used only for virtual tiles
Vadstena.MetaNode.prototype.findNode = function()
{
    return this;
};

//! Returns a transformation from the local [0..1] coords to the world space.
//! (See notes inside the function on the specifics of the world space in
//! this app.)
Vadstena.MetaNode.prototype.getWorldMatrix = function(geoPos_, matrix_)
{
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    var m = matrix_;

    if (m != null) {
        m[0] = this.bbox_.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox_.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = this.bbox_.min_[0] - geoPos_[0]; m[13] = this.bbox_.min_[1] - geoPos_[1]; m[14] = 0; m[15] = 1;
    } else {
        var m = Vadstena.mat4.create();

        Vadstena.mat4.multiply( Vadstena.translationMatrix(this.bbox_.min_[0] - geoPos_[0], this.bbox_.min_[1] - geoPos_[1], 0),
                       Vadstena.scaleMatrix(this.bbox_.side(0), this.bbox_.side(1), 1), m);
    }

    return m;
};

//used debuf render of bbox
Vadstena.MetaNode.prototype.getWorldMatrix2 = function(geoPos_, matrix_)
{
    var m = matrix_;

    if (m != null) {
        m[0] = this.bbox_.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox_.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.bbox_.side(2); m[11] = 0;
        m[12] = this.bbox_.min_[0] - geoPos_[0]; m[13] = this.bbox_.min_[1] - geoPos_[1]; m[14] =  this.bbox_.min_[2]; m[15] = 1;
    }

    return m;
};

//used for geotiles
Vadstena.MetaNode.prototype.getWorldMatrix3 = function(geoPos_, matrix_)
{
    var m = matrix_;

    if (m != null) {
        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = this.bbox_.min_[0] - geoPos_[0]; m[13] = this.bbox_.min_[1] - geoPos_[1]; m[14] = 0; /*this.bbox_.min_[2];*/ m[15] = 1;
    }

    return m;
};


//! Returns true if the node is an actual tile (with mesh and texture)
Vadstena.MetaNode.prototype.hasGeometry = function(){ return this.pixelSize_[0][0] < 1e6; };


//! Calculates RAM usage in bytes of this node and all its subtrees.
Vadstena.MetaNode.prototype.size = function()
{
    var result_ = (2*3+2*2+5*5+3)*8+4; //sizeof(MetaNode)

    for (var i = 0; i < 4; i++) {
        if (this.sons_[i] != null) result_ += this.sons_[i].size();
    }

    return result_;
};

//! Returns approximate average height of the tile.
Vadstena.MetaNode.prototype.avgHeight = function() {
    var HMSize_ = Vadstena.MetaNodeHMSize_;

    return (this.heightmap_[0] + this.heightmap_[HMSize_-1] +
            this.heightmap_[(HMSize_-1)*HMSize_] + this.heightmap_[(HMSize_-1)*HMSize_+HMSize_-1]) * 0.25;
};

//! Returns average pixel size of the tile.
Vadstena.MetaNode.prototype.avgPixelSize = function() {
    return (this.pixelSize_[0][0] + this.pixelSize_[0][1] +
            this.pixelSize_[1][0] + this.pixelSize_[1][1]) * 0.25;
};


//! Represents a metatile file. Contains aggregated MetaNodes.
/**
 * @constructor
 */
Vadstena.MetaTile = function(browser_, id_, stream_)
{
    this.id_ = id_;
    this.browser_ = browser_;

    // check header and version
    var magic_ = "";

    //read magic
    for (var i = 0; i < 8; i++) {
        magic_ += String.fromCharCode(stream_.data_.getUint8(stream_.index_, true)); stream_.index_ += 1;
    }


    if (magic_ != "METATILE") {
        // "Bad metatile data.";
        return;
    }

    //read version
    var version_ = stream_.data_.getUint32(stream_.index_, true); stream_.index_ += 4;

    if (version_ > 3) {
        //"Unsupported binary mesh format (" << version << ").";
        return;
    }

    // load the contents
    this.tree_ = this.loadTree(id_, stream_, version_);
};

Vadstena.MetaTile.prototype.kill = function() {

};

Vadstena.MetaTile.prototype.loadTree = function(id_, stream_, version_)
{
    //this.id_ = id_;
    var node_ = new Vadstena.MetaNode(this.browser_, id_, stream_, version_);

    var childFlags_ = stream_.data_.getUint8(stream_.index_, true); stream_.index_ += 1;

    for (var i = 0; i < 4; i++) {
        if (childFlags_ & (1 << (i + 4))) {
            node_.sons_[i] = this.loadTree(id_.child(i), stream_, version_);
        }
    }

    node_.childFlags_ = (childFlags_ & 0x0f);

    return node_;
};

//! Calculates RAM usage in bytes.
Vadstena.MetaTile.prototype.size = function() {
    return this.tree_.size();
};

//! Searches the tree for metadata belonging to the given tile.
Vadstena.MetaTile.prototype.findNode = function(tile_)
{
    var curId_ = new Vadstena.TileId(this.browser_, this.id_.lod_, this.id_.easting_, this.id_.northing_);
    var curNode_ = this.tree_;

    // keep going down the tree until we reach the right ID
    while (curId_.lod_ < tile_.lod_)
    {
        var size_ = (this.browser_.mapConfig_.tileSize(curId_.lod_));
        var midx_ = (curId_.easting_ + size_/2);
        var midy_ = (curId_.northing_ + size_/2);

        var childIndex_ = 0;
        if (Math.round(tile_.easting_) >= Math.round(midx_)) {
            childIndex_ |= 1;
            curId_.easting_ = midx_;
        }
        if (Math.round(tile_.northing_) >= Math.round(midy_)) {
            childIndex_ |= 2;
            curId_.northing_ = midy_;
        }
        curId_.lod_++;

        var lastNode_ = curNode_;

        curNode_ = curNode_.sons_[childIndex_];
        if (!curNode_) {
            console.log("Missing tile metadata");
            //LOGTHROW(err2, BadMetaData) << "Missing tile metadata.";
        }
    }

    if (curId_.isNotEqual(tile_)) {
        console.log("Metatile inconsistency");
        //LOGTHROW(err2, BadMetaData) << "Metatile inconsistency.";
    }

    return curNode_;
};

//static download
Vadstena.MetaTileDownload = function(browser_, id_, onLoaded_, onError_)
{
    this.browser_ = browser_;
    this.id_ = id_;
    this.onLoaded_ = onLoaded_;
    this.onError_ = onError_;

    this.onLoadedLocal_ = (function(data_) {
        if (this.browser_.killed_ == true){
            return;
        }

        if (this.onLoaded_ != null) {
            var metaTile_ = new Vadstena.MetaTile(browser_, this.id_, {data_ : data_, index_ : 0});
            this.onLoaded_(this.id_, metaTile_);
        }
    }).bind(this);

    this.onErrorLocal_ = (function() {
        if (this.browser_.killed_ == true){
            return;
        }

        if (this.onError_ != null) {
            this.onError_(this.id_);
        }
    }).bind(this);

    Vadstena.loadBinary(this.browser_.mapConfig_.metaUrl(this.id_), this.onLoadedLocal_, this.onErrorLocal_);
};



//! MetaTile cache with a modified get() function which hides the fact that
//! MetaNodes are stored in MetaTiles. Returns metadata directly for the given
//! tile.
/**
 * @constructor
 */
Vadstena.MetaCache = function(browser_, cacheSize_, onDownloadFinished_, numThreads_, downloadFunction_)
{
    this.browser_ = browser_;
    this.downloadCache_ = new Vadstena.DownloadCache(browser_, cacheSize_, onDownloadFinished_, numThreads_, downloadFunction_);

    this.contains = this.downloadCache_.contains.bind(this.downloadCache_);
    this.trim = this.downloadCache_.trim.bind(this.downloadCache_);
    this.insert = this.downloadCache_.insert.bind(this.downloadCache_);
    this.reset = this.downloadCache_.reset.bind(this.downloadCache_);
    this.newRequest = this.downloadCache_.newRequest.bind(this.downloadCache_);
    this.update = this.downloadCache_.update.bind(this.downloadCache_);
    this.size = this.downloadCache_.size.bind(this.downloadCache_);
};

Vadstena.MetaCache.prototype.get = function(tile_, virtual_, forceLayerId_)
{
    if (tile_.lod_ == 12) {
        tile_ = tile_;
    }

    if (forceLayerId_ != null) {
        tile_ = new Vadstena.TileId(this.browser_, tile_.lod_, tile_.easting_, tile_.northing_, forceLayerId_);
    }

    if (virtual_) {
        return this.downloadCache_.get(tile_);
    }

    var metaId_ = this.metaTileId(tile_);
    var metaTile_ = this.downloadCache_.get(metaId_);
    if (!metaTile_) return null;
    return metaTile_.findNode(tile_);
};

Vadstena.MetaCache.prototype.metaTileId = function(tile_)
{
    var curId_ = tile_;
    var mc_ = this.browser_.mapConfig_;

    // climb up the hierarchy until a metatile level or FOAT level is reached
    while ((Math.abs(curId_.lod_ - mc_.metaLod_) % mc_.metaDelta_) && (curId_.lod_ > mc_.foat_.lod_))
    {
        curId_ = curId_.parent();
    }

    return curId_;
};





if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.Platform = {

    init: function () {

        var self_ = Vadstena.Platform;

        self_.browser = self_.searchString(self_.dataBrowser) || "An unknown browser";
        self_.version = self_.searchVersion(navigator.userAgent.toLowerCase()) || self_.searchVersion(navigator.appVersion) || "an unknown version";
        self_.OS = self_.searchString(self_.dataOS) || "an unknown os: ua: " + navigator.userAgent + " pl: " + navigator.platform;

        self_.mobile_ = (self_.OS == "iphone/ipod" || self_.OS == "android" || self_.OS == "ipad" || self_.OS == "windows ce"  || self_.OS == "windows phone" || self_.OS == "kindle");
        self_.mobileAndroid_ = (self_.OS == "android");
    },

    isMobile : function() { return Vadstena.Platform.mobile_; },
    isAndroid : function() { return Vadstena.Platform.mobileAndroid_; },

    searchString: function (data) {
        var self_ = Vadstena.Platform;
        for (var i=0; i<data.length; i++) {
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            self_.versionSearchString = data[i].versionSearch || data[i].identity;

            if (dataString) {
                if (dataString.toLowerCase().indexOf(data[i].subString) != -1) {
                    if (data[i].version != null) {
                        self_.version = data[i].version;
                    }
                    return data[i].identity;
                }
            } else if (dataProp) {
                return data[i].identity;
            }
        }
    },

    searchVersion: function (dataString) {
        var self_ = Vadstena.Platform;
        if (self_.version != null) {
            return self_.version;
        }
        var index = dataString.indexOf(self_.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index+self_.versionSearchString.length+1));
    },

    dataBrowser: [
        {
            string: navigator.userAgent,
            subString: "chrome",
            identity: "chrome"
        },
        {
            string: navigator.userAgent,
            subString: "firefox",
            identity: "firefox"
        },
        {
            string: navigator.vendor,
            subString: "apple",
            identity: "safari",
            versionSearch: "version"
        },
        {
            prop: window.opera,
            identity: "opera",
            versionSearch: "version"
        },
        {
            string: navigator.vendor,
            subString: "icab",
            identity: "icab"
        },
        {
            string: navigator.vendor,
            subString: "kde",
            identity: "konqueror"
        },
        {
            string: navigator.vendor,
            subString: "camino",
            identity: "camino"
        },
        {       // for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: "netscape",
            identity: "netscape"
        },
        {
            string: navigator.userAgent,
            subString: "msie",
            identity: "explorer",
            versionSearch: "msie"
        },
        {
            string: navigator.userAgent,
            subString: "trident/",
            identity: "explorer",
            version: "11"
        },
        {
            string: navigator.userAgent,
            subString: "edge/",
            identity: "explorer",
            version: "12"
        },
        {   string: navigator.userAgent,
            subString: "omniweb",
            versionSearch: "omniweb/",
            identity: "omniweb"
        },
        {   string: navigator.userAgent,
            subString: "silk",
            versionSearch: "silk/",
            identity: "silk"
        },
        {
            string: navigator.userAgent,
            subString: "gecko",
            identity: "mozilla",
            versionSearch: "rv"
        },
        {       // for older Netscapes (4-)
            string: navigator.userAgent,
            subString: "mozilla",
            identity: "netscape",
            versionSearch: "mozilla"
        }
    ],

    dataOS : [
        {
           string: navigator.userAgent,
           subString: "windows ce",
           identity: "windows ce"
        },
        {
           string: navigator.userAgent,
           subString: "windows phone",
           identity: "windows phone"
        },
        {
            string: navigator.platform,
            subString: "win",
            identity: "windows"
        },
        {
            string: navigator.platform,
            subString: "mac",
            identity: "mac"
        },
        {
           string: navigator.userAgent,
           subString: "iphone",
           identity: "iphone/ipod"
        },
        {
           string: navigator.userAgent,
           subString: "ipod",
           identity: "iphone/ipod"
        },
        {
           string: navigator.userAgent,
           subString: "ipad",
           identity: "ipad"
        },
        {
           string: navigator.userAgent,
           subString: "android",
           identity: "android"
        },
        {
           string: navigator.userAgent,
           subString: "silk",
           identity: "kindle"
        },
        {
           string: navigator.userAgent,
           subString: "blackberry",
           identity: "blackberry"
        },
        {
            string: navigator.platform,
            subString: "linux",
            identity: "linux"
        }
    ]

};

if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

window["VadstenaMobile_"] = true;
window["VadstenaScreenScaleFactor_"] = 1.0;
Vadstena.mobileScaleFactor_ = 0.5;

/**
 * @constructor
 */
Vadstena.Browser = function(divId_, mapConfig_, browserConfig_, initCallback_, updateCallback_, keepFrameBuffer_)
{
    this.panDeltas_ = [];
    this.orbitDeltas_ = [];
    this.distanceDeltas_ = [];
    this.renderer_ = null;
    this.mapConfig_ = null;
    this.browserConfig_ = null;
    this.updateCallback_ = null;
    this.ready_ = false;
    this.killed_ = false;
    this.div_ = null;
    this.keepFrameBuffer_ = keepFrameBuffer_;
    this.currentLayer_ = null;
    this.oldViewHeight_ = null;
    this.listeners_ = [];
    this.listenerCounter_ = 0;

    //mobile
    Vadstena.Platform.init();
    window["VadstenaMobile_"] = Vadstena.Platform.isMobile();

    /*
    if (window["VadstenaMobile_"] == true) {
        window["VadstenaScreenScaleFactor_"] = Vadstena.mobileScaleFactor_;
        document.getElementById("vadstena-engine-canvas-3d").style.width = "100%";
        document.getElementById("vadstena-engine-canvas-3d").style.height = "100%";
    }*/

    //get div element
    if (typeof divId_ === "string") {
        this.div_ = document.getElementById(divId_);
    } else if (typeof divId_ === "object") {
        this.div_ = divId_;
    }

    if (this.div_ == null) {
        //div does not exist
        if (initCallback_ != null) {
            initCallback_(false, "DOM element does not exist");
        }

        return;
    }

    if (mapConfig_ != null) {
        this.loadMap(mapConfig_, browserConfig_, initCallback_, updateCallback_);
    }
};

Vadstena.Browser.prototype.loadMap = function(mapConfig_, browserConfig_, initCallback_, updateCallback_) {

    if (mapConfig_ == null || mapConfig_ == "") {

        //div does not exist
        if (initCallback_ != null) {
            initCallback_(false, "Map config does not exist");
        }

        return;
    }

    //get config root path
    var baseURL_ = "";

    if ((typeof mapConfig_) === "string") {
        baseURL_ = mapConfig_.split('?')[0].split('/').slice(0, -1).join('/')+'/';
    }

    var mapConfigData_ = null;
    var browserConfigData_ = null;
    this.ready_ = false;

    var checkLoaded_ = (function(jsonData_){

        if (mapConfigData_ != null && (browserConfigData_ != null || browserConfig_ == null)) {

            this.mapConfig_ = new Vadstena.MapConfig(this, mapConfigData_, baseURL_);
            this.browserConfig_ = new Vadstena.BrowserConfig(browserConfigData_);
            this.updateCallback_ = updateCallback_;

            if (this.renderer_ != null) {
                this.renderer_.kill();
                this.renderer_ = null;
            }

            // run the renderer
            this.renderer_ = new Vadstena.Renderer(this, this.div_, this.onUpdate.bind(this), this.keepFrameBuffer_);

            //this.setPosition(449940, 5406734, 2055.3469188680235);
            //this.setOrientation(1.7071238129971096, -88.61203101055301, 0);

            if (initCallback_ != null) {
                this.ready_ = true;
                initCallback_(true);
            }
        }

    }).bind(this);


    var onMapConfigLoaded_ = (function(jsonData_){
        mapConfigData_ = jsonData_;
        checkLoaded_();
    }).bind(this);


    var onBrowserConfigLoaded_ = (function(jsonData_){
        browserConfigData_ = jsonData_;
        checkLoaded_();
    }).bind(this);


    var onError_ = (function(configName_){

        //config not found
        if (initCallback_ != null) {
            initCallback_(false, configName_ + " config not found");
        }

    }).bind(this);


    // laad and parse browser config
    if (browserConfig_ != null && (typeof browserConfig_) === "string") {
        Vadstena.loadJSON(browserConfig_, onBrowserConfigLoaded_, onError_.bind(this, "browser"));
    }

    if ((typeof mapConfig_) === "string") {
        Vadstena.loadJSON(mapConfig_, onMapConfigLoaded_, onError_.bind(this, "map"));
    }

    //get config data dirrectly
    if ((typeof mapConfig_) === "object") {
        mapConfigData_ = mapConfig_;
    }

    if ((typeof browserConfig_) === "object") {
        browserConfigData_ = browserConfig_;
    }

    if (mapConfigData_ != null || browserConfigData_ != null) {
        checkLoaded_();
    }


    //this.renderer_.kill();
    //this.killed_ = true;
};

Vadstena.Browser.prototype.kill = function() {

    this.renderer_.kill();
    this.killed_ = true;
};

Vadstena.Browser.prototype.isReady = function() {
    return this.ready_;
};


/*
void setControlMode(string mode)

    Sets current user control model.

    mode: one of following control modes:
        "manual" : camera position and orientation is controlled directly by user actions (e.g. pan, rotate). No restrictions are applied.
        "drone" : same as "manual" mode but position of camera is restricted (e.g. camera can not be below terrain).
        "observer" : camera position is determined by distance from reference point and camera always points towards reference point. User actions (e.g. pan) can change position of observing point, distance from observing point (e.g. zoom) or point of view (e.g. rotate). Point of view and distance of camera is restricted (e.g. camera can not be below terrain)
*/

Vadstena.Browser.prototype.setControlMode = function(mode_)
{
    if (this.killed_ == true || this.renderer_ == null || this.renderer_.camera_ == null) {
        return;
    }

    if (this.browserConfig_.controlMode_ == mode_) {
        return;
    }

    if (mode_ == "manual") {
        var height_ = Vadstena.getSurfaceHeight(this.renderer_.position_[0], this.renderer_.position_[1]);

        if (height_[0] > this.renderer_.position_[2]) {
            this.renderer_.position_[2] = height_[0] + 100;
        }
    }

    this.browserConfig_.controlMode_ = mode_;
    this.renderer_.updateCamera();

    this.panDeltas_ = [];
    this.distanceDeltas_ = [];
    this.orbitDeltas_ = [];
};

/*
string getControlMode()

    Gets current user control model.

    Returns: control mode. Possible values are: "manual", "drone", "observer"
*/

Vadstena.Browser.prototype.getControlMode = function()
{
    return this.browserConfig_.controlMode_;
};

/*
void setPosition(number x, number y, number distance)

    Sets camera position.

    x: UTM x coordinate
    y: UTM y coordinate
    distance: height above terrain in meters or distance from reference point
*/

Vadstena.Browser.prototype.setPosition = function(x, y, distance_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.position_ = [x, y, distance_];
    this.renderer_.updateCamera();
};

/*
object getPosition()

    Gets camera position or in case of "observer" control mode it gets position of reference point.

    Returns: [UTM x, UTM y, distance]
*/

Vadstena.Browser.prototype.getPosition = function()
{
    if (this.killed_ == true || this.renderer_ == null) {
        return [0,0,0];
    }

    return [this.renderer_.position_[0], this.renderer_.position_[1], this.renderer_.position_[2]];
};

/*
void setOrientation(number yaw, number pitch, number roll)

    Sets camera viewing direction.

    yaw: azimuth angle -PI..PI
    pitch: pitch (up/down) angle -PI/2..PI/2
    roll: roll angle (usually zero)
*/

Vadstena.Browser.prototype.setOrientation = function(yaw_, pitch_, roll_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.orientation_ = [yaw_, pitch_, roll_];
    this.renderer_.updateCamera();
};

/*
object getOrientation()

    Gets camera viewing direction.

    Returns: [yaw, pitch, roll]
*/

Vadstena.Browser.prototype.getOrientation = function()
{
    if (this.killed_ == true || this.renderer_ == null) {
        return [0,0,0];
    }

    return this.renderer_.orientation_;
};


/*
void setCamera(number FOV, number visibility)

    Sets camera parameters.

    FOV: horizontal field of view angle (e.g., 100)
    visibility: maximum visible distance
*/

Vadstena.Browser.prototype.setCamera = function(FOV_, visibility_)
{
    if (this.renderer_ == null || this.renderer_.camera_ == null) {
        return;
    }

    this.renderer_.camera_.setParams(FOV_, this.renderer_.camera_.getFov(), visibility_);
    this.renderer_.updateCamera();
};

/*
void setCameraConstrainMode(string mode)

    Sets current camera constrain mode.

    mode: one of following constrain modes:
      "disabled" : no constrain is applied
      "aboveTerrainOnly" : camera position is kept above terrain
      "aboveTerrainByPixelSize" : camera position is kept above terrain and minimum distance is determined by terrain resolution
      "constrainTexelSize" : camera is only allowed to see terrain from distance from which is texture resolution sufficiently sharp. This mode is experimental and it is not recommended to used this mode in production.
*/

Vadstena.Browser.prototype.setCameraConstrainMode = function(mode_)
{
    if (this.killed_ == true || this.renderer_ == null || this.renderer_.camera_ == null) {
        return;
    }

    this.browserConfig_.cameraConstrainMode_ = mode_;
    this.renderer_.updateCamera();
};

/*
string getCameraConstrainMode()

    Gets current camera constrain mode.

    Returns: constrain mode. Possible values are: "disabled", "aboveTerrainOnly", "aboveTerrainByPixelSize", "constrainTexelSize"
*/

Vadstena.Browser.prototype.getCameraConstrainMode = function()
{
    return this.browserConfig_.cameraConstrainMode_;
};

/*
object hitTest(number screenX, number screenY)

    Determines which 3D point lies at the given pixel coordinates.

    Returns: [x, y, altitude, hitSurface]
*/

Vadstena.Browser.prototype.hitTest = function(screenX_, screenY_)
{
    if (this.renderer_ == null) { // || this.renderer_.camera_ == null) {
        return [0, 0, 0, false];
    }

    return this.renderer_.hitTest(screenX_, screenY_, "all");
};


/*
object project(number x, number y, number altitude)

    Projects a 3D point to the screen. An inverse to "hitTest".

    Returns: [screenX, screenY, distance]
*/

Vadstena.Browser.prototype.project = function(x, y, altitude_)
{
    if (this.renderer_ == null) { // || this.renderer_.camera_ == null) {
        return [0,0,0];
    }

    return this.renderer_.project([x, y, altitude_]);
};

/*
object visibleArea(number near, number far)

    Calculates a polygon in the world XY plane that corresponds to the portion of the terrain currently visible in the browser window.

    Returns: list of vertices of a closed polygon: [[x1, y1], ..., [xn, yn]].
*/

Vadstena.Browser.prototype.visibleArea = function(near_, far_)
{
    return [[0,0],[1,0],[1,1],[0,1]];
};

/*
object getScreenRay(number screenX, number screenY)

    Projects ray from screen coordinate into the scene. Returns absolute camera location and ray vector.

    Returns: [camera psotion, ray vector]
*/

Vadstena.Browser.prototype.getScreenRay = function(screenX_, screenY_)
{
    if (this.renderer_ == null) { // || this.renderer_.camera_ == null) {
        return [0, 0, 0, false];
    }

    //get screen ray
    var screenRay_ = this.renderer_.getScreenRay(screenX_, screenY_);
    var cameraPos_ = this.renderer_.cameraPosition();

    return [cameraPos_, screenRay_];
};


/*
array getCameraVector()

    Returns absolute camera position and vector

    Returns: [camera position, camera vector]
*/

Vadstena.Browser.prototype.getCameraVector = function()
{
    if (this.renderer_ == null) { // || this.renderer_.camera_ == null) {
        return [[0, 0, 0], [0,1,0]];
    }

    var v = this.renderer_.cameraVector_;

    return [this.renderer_.cameraPosition(), [v[0], v[1], v[2]]];
};

/*
array getTerrainHeight(number x, number y)

    Returns terrain height at given coordinates.

    Returns: [height, finalValue]
* */

Vadstena.Browser.prototype.getTerrainHeight = function(x, y) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    return this.renderer_.planet_.surfaceHeight([x, y]);
};


/*
object pan(number dx, number dy)

    Mouse control helper, returns recommended position change given mouse movement delta in pixels.

    Returns: [UTM deltaX, UTM deltaY]
*/

Vadstena.Browser.prototype.pan = function(dx, dy)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    var zoomFactor_ = (this.renderer_.cameraHeight() * Math.tan(Vadstena.radians(this.renderer_.camera_.getFov()))) / 800;

    //zoomFactor_ *= Math.tan(Vadstena.radians(this.renderer_.camera_.getFov()));

    dx *= zoomFactor_;
    dy *= zoomFactor_;

    var yaw_ = Vadstena.radians(this.getOrientation()[0]);

    var forward_ = [-Math.sin(yaw_), Math.cos(yaw_)];
    var aside_ = [Math.cos(yaw_), Math.sin(yaw_)];

    this.renderer_.position_[0] += forward_[0]*dy - aside_[0]*dx;
    this.renderer_.position_[1] += forward_[1]*dy - aside_[1]*dx;

    if (this.browserConfig_.controlInertia_[0] > 0) {
        this.panDeltas_.push([ forward_[0]*dy - aside_[0]*dx,
                               forward_[1]*dy - aside_[1]*dx ]);
    }

    this.renderer_.updateCamera();
};

/*
object rotate(number dx, number dy)

    Mouse control helper, returns recommended orientation change given mouse movement delta in pixels.

    Returns: [deltaYaw, deltaPitch]
*/

Vadstena.Browser.prototype.rotate = function(dx, dy, dz, sensitivity_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    if (dz == null) { dz = 0; }

    if (sensitivity_ == null) {
        sensitivity_ = 0.3;
    }

    this.renderer_.orientation_[0] += -dx * sensitivity_;
    this.renderer_.orientation_[1] += -dy * sensitivity_;
    this.renderer_.orientation_[2] += dz * sensitivity_;

    if (this.browserConfig_.controlInertia_[1] > 0) {
        this.orbitDeltas_.push([ -dx * sensitivity_,  -dy * sensitivity_, dz * sensitivity_]);
    }

    this.renderer_.tilting_ = true;

    this.renderer_.updateCamera();
};

/*
void zoom(number dz)

    Changes camera height above terrain or distance from reference point.
*/

Vadstena.Browser.prototype.zoom = function(dz)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    var value_ = 1.0 + dz*0.001;
    this.renderer_.position_[2] *= value_;

    if (this.browserConfig_.controlInertia_[2] > 0) {
        this.distanceDeltas_.push([ value_ ]);
    }

    this.oldViewHeight_ = Math.tan(Vadstena.radians(this.renderer_.camera_.getFov())) * this.renderer_.position_[2];

    this.renderer_.updateCamera();
};

//experimantal
Vadstena.Browser.prototype.changeFov = function(dz)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    var sensitivity_ = 0.1;
    var oldFov_ = this.renderer_.camera_.getFov();
    var newFov_ = oldFov_ + dz * sensitivity_;
    newFov_ = Vadstena.clamp(newFov_, 2, 89);

    if (this.oldViewHeight_ == null) {
        this.oldViewHeight_ = Math.tan(Vadstena.radians(oldFov_)) * this.renderer_.position_[2];
    }

    this.renderer_.position_[2] = this.oldViewHeight_ / Math.tan(Vadstena.radians(newFov_));

    var newViewHeight_ = Math.tan(Vadstena.radians(newFov_)) * this.renderer_.position_[2];


    //console.log("" + newFov_ + "  " +  this.renderer_.position_[2] + "  " + newViewHeight_ + "  " + this.oldViewHeight_);

    this.renderer_.camera_.setParams(newFov_, this.renderer_.camera_.getNear(), this.renderer_.camera_.getFar());
    this.renderer_.updateCamera();
};

/*
void getMapConfig()

    Returns: map config structure. Vadsteba have to be initialized otherwise returns null
*/

Vadstena.Browser.prototype.getMapConfig = function()
{
    return this.mapConfig_;
};

/*
void getBrowserConfig()

    Returns: browser config structure. Vadsteba have to be initialized otherwise returns null
*/

Vadstena.Browser.prototype.getBrowserConfig = function()
{
    return this.browserConfig_;
};


/*
void saveScreenshot()

    Used only for debug. Logouts tile propertie at specified position
*/

Vadstena.Browser.prototype.saveScreenshot = function()
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.saveScreenshot();
};

/*
void setOption(option_, value_)

*/

Vadstena.Browser.prototype.setOption = function(option_, value_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    switch(option_) {
        case "cameraHeightOffset": this.renderer_.cameraHeightOffset_ = value_;  break;
        case "drawOnlyHeightmap":  this.renderer_.heightmapOnly_ = value_;       break;
        case "noForwardMovement":  this.renderer_.noForwardMovement_ = value_;   break;
        case "texelSize":          this.renderer_.texelSizeLimit_ = value_ * Vadstena.texelSizeFactor_; break;
        case "ignoreTexelSize":    this.renderer_.ignoreTexelSize_ = value_;     break;
        case "drawBBoxes":         this.renderer_.drawBBoxes_ = value_;          break;
        case "drawWireframe":      this.renderer_.drawWireframe_ = value_;       break;
        case "drawLods":           this.renderer_.drawLods_ = value_;            break;
        case "drawPositions":      this.renderer_.drawPositions_ = value_;       break;
        case "drawTexelSize":      this.renderer_.drawTexelSize_ = value_;       break;
        case "drawFaceCount":      this.renderer_.drawFaceCount_ = value_;       break;
        case "drawDistance":       this.renderer_.drawDistance_ = value_;        break;
        case "drawMaxLod":         this.renderer_.drawMaxLod_ = value_;          break;
        case "drawTextureSize":    this.renderer_.drawTextureSize_ = value_;     break;
        case "drawLayers":         this.renderer_.drawLayers_ = value_;          break;
        case "drawFog":            this.renderer_.drawFog_ = value_;             break;
        case "blendHeightmap":     this.renderer_.blendHeightmap_ = value_;      break;
        case "recordStats":        this.renderer_.recordStats_ = value_;         break;
        case "heightLod":          this.renderer_.heightLod_ = value_;           break;
        case "degdradeHorizon":    this.mapConfig_.degdradeHorizon_ = value_;    break;
        case "lowRes":             this.mapConfig_.lowRes_ = value_;             break;
        case "controlInertia":     this.browserConfig_.controlInertia_ = value_; break;
        case "minDistance":
            this.renderer_.cameraMinDistance_ = value_;
            this.renderer_.cameraMinDesiredDistance_ = value_;
            this.renderer_.cameraConstrainDistance_ = value_ * 0.5;
            break;

    }

    this.renderer_.updateCamera();
};

/*
void getOption(option_, value_)

*/

Vadstena.Browser.prototype.getOption = function(option_, value_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    switch(option_) {
        case "cameraHeightOffset":  return this.renderer_.cameraHeightOffset_;     break;
        case "drawOnlyHeightmap":   return this.renderer_.heightmapOnly_;          break;
        case "noForwardMovement":   return this.renderer_.noForwardMovement_;      break;
        case "minDistance":         return this.renderer_.cameraMinDistance_;      break;
        case "maxDistance":         return this.browserConfig_.cameraMaxDistance_; break;
        case "texelSize":           return this.renderer_.texelSizeLimit_;         break;
        case "ignoreTexelSize":     return this.renderer_.ignoreTexelSize_;        break;
        case "drawBBoxes":          return this.renderer_.drawBBoxes_;             break;
        case "drawWireframe":       return this.renderer_.drawWireframe_;          break;
        case "drawLods":            return this.renderer_.drawLods_ ;              break;
        case "drawPositions":       return this.renderer_.drawPositions_;          break;
        case "drawTexelSize":       return this.renderer_.drawTexelSize_;          break;
        case "drawFaceCount":       return this.renderer_.drawFaceCount_;          break;
        case "drawDistance":        return this.renderer_.drawDistance_;           break;
        case "drawMaxLod":          return this.renderer_.drawMaxLod_;             break;
        case "drawTextureSize":     return this.renderer_.drawTextureSize_;        break;
        case "drawLayers":          return this.renderer_.drawLayers_;             break;
        case "drawFog":             return this.renderer_.drawFog_;                break;
        case "blendHeightmap":      return this.renderer_.blendHeightmap_;         break;
        case "recordStats":         return this.renderer_.recordStats_;            break;
        case "heightLod":           return this.renderer_.heightLod_;              break;
        case "controlInertia":      return this.browserConfig_.controlInertia_;    break;
        case "degdradeHorizon":     return this.mapConfig_.degdradeHorizon_;       break;
        case "lowRes":              return this.mapConfig_.lowRes_;                break;
        case "fov":                 return this.renderer_.camera_.getFov();        break;
    }

    return null;
};

/*
void getData(data_)

*/

Vadstena.Browser.prototype.getData = function(data_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    switch(data_) {
        case "mapConfig":     return this.mapConfig_.clone();
        case "browserConfig": return this.browserConfig_.clone();
        case "stats":         return this.renderer_.stats_;
        case "layer-places":  return this.renderer_.layerPlaces_;
        case "statsSamples":  return {
            "index" :    this.renderer_.statsTimeIndex_,
            "samples":   this.renderer_.statsTimeSamples_,
            "render":    this.renderer_.statsRenderTimes_,
            "meshes":    this.renderer_.statsCreateMeshTimes_,
            "gpumeshes": this.renderer_.statsCreateGpuMeshTimes_,
            "textures":  this.renderer_.statsCreateTextureTimes_,
            "frame":     this.renderer_.statsFrameGapTimes_,
            "polygons":  this.renderer_.statsPolygons_,
            "lods":      this.renderer_.statsLODs_,
            "cache":           this.renderer_.statsGpuMemory_,
            "cache-used":      this.renderer_.statsGpuMemoryUsed_,
            "cache-textures":  this.renderer_.statsGpuMemoryTextures_,
            "cache-meshes":    this.renderer_.statsGpuMemoryMeshes_,
            "cache-size":      this.browserConfig_.gpuCacheSize_,
            "flux-textures":   this.renderer_.statsFluxTextures_,
            "flux-meshes":     this.renderer_.statsFluxMeshes_
        };
        break;
    }
};

/*
void setData(data_, value_)

*/

Vadstena.Browser.prototype.setData = function(data_, value_)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    switch(data_) {
        case "layer-begin":         this.currentLayer_ = new Vadstena.LayerOld(this.renderer_.getPlanet(), value_["id"], value_["lod"], value_["group"], value_["visible"]);
                                    this.currentLayer_.path_ = value_["path"];
                                    break;
        case "layer-visible":       this.renderer_.setLayersVisible(value_["id"], value_["state"]);  break;
        case "layer-group-visible": this.renderer_.setLayersGroupVisible(value_["id"], value_["group"], value_["state"]);  break;
        case "layer-icon":          this.renderer_.createLayersIcon(value_["id"], value_["data"]);  break;
        case "layer-bbox":          this.currentLayer_.add(value_["id"], "bbox", { bbox_:value_["bbox"]} ); break;
        case "layer-origin":        this.currentLayer_.add(value_["id"], "origin", { origin_:value_["origin"]} ); break;
        case "layer-optimize":      this.currentLayer_.add(value_["id"], "optimize", { optimize_:value_["optimize"]} ); break;
    }

    if (this.currentLayer_ != null) {
        switch(data_) {
            case "layer-end":
                this.currentLayer_.compile();
                this.renderer_.layers_.push(this.currentLayer_);
                this.currentLayer_ = null;
                this.renderer_.dirty_ = true;
                break;

            case "pixel-line":
                this.currentLayer_.add(value_["id"], "pixel-line", { points_:value_["points"], size_:value_["size"], color_:value_["color"]} );
                break;

            case "pixel-line2":
                this.currentLayer_.add(value_["id"], "pixel-line2", { points_:value_["points"], size_:value_["size"], color_:value_["color"]} );
                break;

            case "stencil-line":
                this.currentLayer_.add(value_["id"], "stencil-line", { points_:value_["points"], size_:value_["size"], color_:value_["color"]} );
                break;

            case "pixel-wall":
                this.currentLayer_.add(value_["id"], "pixel-wall", { points_:value_["points"], points2_:value_["points2"], size_:value_["size"], color_:value_["color"]} );
                break;

            case "polygon-wall":
                this.currentLayer_.add(value_["id"], "polygon-wall", { points_:value_["points"], points2_:value_["points2"], color_:value_["color"]} );
                break;

            case "flat-image":
                this.currentLayer_.add(value_["id"], "flat-image", { icon_:value_["icon"], point_:value_["point"],
                                                                    x_:value_["x"], y_:value_["y"], xunits_:value_["xunits"], yunits_:value_["yunits"],
                                                                    scale_:value_["scale"], color_:value_["color"], html_:value_["html"]} );
                break;

            case "flat-text":
                this.currentLayer_.add(value_["id"], "flat-text", { text_:value_["text"], point_:value_["point"], scale_:value_["scale"],
                                       color_:value_["color"], image_:value_["image"], minDistance_:value_["minDistance"], html_:value_["html"]} );
                break;

            case "path-text":
                this.currentLayer_.add(value_["id"], "path-text", { text_:value_["text"], points_:value_["points"], size_:value_["size"], color_:value_["color"]} );
                break;

            case "flat-place":
                //this.currentLayer_.add(value_["id"], "flat-place", { text_:value_["text"], image_:value_["image"]} );
                break;

        }
    }

};

/*
void addLayer(string layerId, string layerType, object layerParams)

    Adds geo layer data
    layerID -- unique identifier for geo layer
    layerType -- type of layer
    layerParamas -- according to layerType following layer params are supported:

        layerType == "geodata"
            geodata -- JSON object which defines geo data
            style -- JSON object which defines used style
            visible -- optional: sets whether is object  visible (default=true)
            group -- optional: sets to which group larer belongs (default=null)

        layerType == "tiled-geodata"
            url -- URL to server where are geo data provided
            style -- JSON object which defines used style
            minLod -- sets minimal LOD level from which are tiles privided
            maxLod -- sets maximal LOD level to which are tiles privided
            tileWidth -- sets tile width in pixels

            visible -- optional: sets whether is object  visible (default=true)
            group -- optional: sets to which group larer belongs (default=null)

* */
Vadstena.Browser.prototype.addLayer = function(layerId_, layerType_, layerParams_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    if (layerParams_ == null || layerParams_["style"] == null) {
        return;
    }

    switch(layerType_) {
        case "geodata":
            if (layerParams_["geodata"] == null) {
                return;
            }

            this.renderer_.planet_.addLayer(layerId_, layerParams_["group"], layerParams_["geodata"],
                                            layerParams_["minLod"], layerParams_["maxLod"],
                                            layerParams_["tileWidth"], layerParams_["generateLods"],
                                            layerParams_["style"], layerParams_["visible"] || true);
            break;

        case "tiled-geodata":
            this.renderer_.planet_.addTiledLayer(layerId_, layerParams_["type"] || "geodata", layerParams_["url"],
                                                 layerParams_["minLod"], layerParams_["maxLod"], layerParams_["tileWidth"],
                                                  layerParams_["style"], layerParams_["group"], layerParams_["visible"] || true);
            break;
    }

};


/*
void removeGeoLayer(string layerId)

    Removes geo layer data
    layerID -- unique identifier for geo layer

* */
Vadstena.Browser.prototype.removeLayer = function(layerId_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.planet_.removeTiledLayer(layerId_);
    this.renderer_.planet_.removeLayer(layerId_);
};

/*
void showGeoLayer(string layerId, boo state)

    Show or hides geo layer
    layerID -- unique identifier for geo layer
    state -- sets whether geo layer will be visible or not

* */
Vadstena.Browser.prototype.showLayer = function(layerId_, state_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.planet_.showTiledLayer(layerId_, state_);
    this.renderer_.planet_.showLayer(layerId_, state_);
};


/*
void showGeoLayerGroup(string groupId, bool state)

    Show or hides geo layer groups. To which group geo data belongs is defined inside geo data structure.
    groupID -- unique identifier for geo layer
    state -- sets whether geo layer will be visible or not

* */
Vadstena.Browser.prototype.showLayerGroup = function(groupId_, state_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.planet_.showTiledLayerGroup(groupId_, state_);
    this.renderer_.planet_.showLayerGroup(groupId_, state_);
};


/*
void showGeoLayerGroupsByTag(string groupId, bool state)

    Show or hides geo layer groups. To which group geo data belongs is defined inside geo data structure.
    groupID -- unique identifier for geo layer
    state -- sets whether geo layer will be visible or not

* */
Vadstena.Browser.prototype.showLayerGroupsByTag = function(tag_, state_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.planet_.showTiledLayerGroupsByTag(tag_, state_);
    this.renderer_.planet_.showLayerGroupsByTag(tag_, state_);
};

/*
void Browser.setLayerGroupOrigin(string groupId, object position)}}}
  Set position of origin of layer group
   * groupID -- identifier for layer group
   * position -- position of origin of geo layer group
   * yaw -- rotation of geo layer group
   * scale -- scale of geo layer group
* */
Vadstena.Browser.prototype.setLayerGroupTransform = function(groupId_, position_, yaw_, scale_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.planet_.setLayerGroupTransform(groupId_, position_, yaw_, scale_);
};


/*
void clearStencilPasses(array passes)
    Sets clear stencil passes
    passes -- array of numbers, each number represent z-index at which is stencil buffer cleared
*/

Vadstena.Browser.prototype.clearStencilPasses = function(passes_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    if (passes_ == null) {
        this.renderer_.clearStencilPasses_ = [];
    } else {
        var newPasses_ = passes_.slice();

        for (var i = 0, li = newPasses_; i < li; i++) {
            newPasses_[i] += 256;
        }

        this.renderer_.clearStencilPasses_ = newPasses_;
    }
};

/*
void click(number screenX, number screeenY, object state)

    Generates click input. If coordinates are over geo feature which has
    enabled "click-event" then "geo-feature-click" event is generated.

    screenX, screenY -- screen coordinates in pixels
    state -- optional: object where use can store custom parameters,
             object is then received in "geo-feature-click" event

* */
Vadstena.Browser.prototype.click = function(screenX_, screenY_, state_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.clickEvent_ = [screenX_, screenY_, state_];
};


/*
void hover(number screenX, number screeenY, bool persistent, object state)

    Generates hover input. If coordinates are over geo feature which has
    enabled "hover-event" then "geo-feature-hover" event is generated.

    screenX, screenY -- screen coordinates in pixels
    persistent -- optional: sets whether hover will be only for one
                  render cyckle or or applied continualy until changed to
                  to some new value. (default = false)
    state -- optional: object where use can store custom parameters,
             object is then received in "geo-feature-hover" event
             (deafult = null)

* */
Vadstena.Browser.prototype.hover = function(screenX_, screenY_, persistent_, state_) {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.hoverEvent_ = [screenX_, screenY_, persistent_, state_];
};


/*
function on(string eventName, funtion listener)

    Creates listener for the engine events.
    name: name of listened event
    listener: function which will be called when event occur. Function will be called with these parameters: function(event).
    Returns: deregistration function for this listener

* */

Vadstena.Browser.prototype.on = function(name_, listener_) {

    if (this.killed_ == true) { // || this.renderer_ == null) {
        return;
    }

    if (listener_ == null) {
        return;
    }

    this.listenerCounter_++;
    this.listeners_.push({ name_ : name_, listener_ : listener_, id_ : this.listenerCounter_ });

    return (function(id_){ this.removeListener(id_); }).bind(this, this.listenerCounter_);
};


// private
Vadstena.Browser.prototype.callListener = function(name_, event_) {
    for (var i = 0; i < this.listeners_.length; i++) {
        if (this.listeners_[i].name_ == name_) {
            this.listeners_[i].listener_(event_);
        }
    }
};

// private
Vadstena.Browser.prototype.removeListener = function(id_) {
    for (var i = 0; i < this.listeners_.length; i++) {
        if (this.listeners_[i].id_ == id_) {
            //this.listeners_[i].splice(i, 1);
            this.listeners_.splice(i, 1);
            return;
        }
    }
};

/*
void logTile(position)

    Used only for debug. Logouts tile propertie at specified position
*/

Vadstena.Browser.prototype.logTile = function(pos)
{
    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    this.renderer_.logTilePos_ = pos;
    this.renderer_.paintGL();
    this.renderer_.logTilePos_ = null;
};


//private update
Vadstena.Browser.prototype.onUpdate = function() {

    if (this.killed_ == true || this.renderer_ == null) {
        return;
    }

    var hit_ = false;
    var factorPan_ = this.browserConfig_.controlInertia_[0];
    var factorRotate_ = this.browserConfig_.controlInertia_[1];
    var factorZoom_ = this.browserConfig_.controlInertia_[2];

    if (this.orbitDeltas_.length > 0 && this.panDeltas_.length == 0 && this.distanceDeltas_.length == 0) {
        this.renderer_.tilting_ = true;
    }

    for (var i = 0; i < this.panDeltas_.length; i++) {
        this.panDeltas_[i][0] *= factorPan_;
        this.panDeltas_[i][1] *= factorPan_;

        this.renderer_.position_[0] += this.panDeltas_[i][0];
        this.renderer_.position_[1] += this.panDeltas_[i][1];

        //remove zero deltas
        if (Math.abs(this.panDeltas_[i][0])+Math.abs(this.panDeltas_[i][1]) < 0.01) {
            this.panDeltas_.splice(i, 1);
            i--;
        }

        hit_ = true;
    }

    for (var i = 0; i < this.distanceDeltas_.length; i++) {

        this.distanceDeltas_[i][0] += (1 - this.distanceDeltas_[i][0]) * (1.0 - factorZoom_);// * 0.01;
        this.renderer_.position_[2] *= this.distanceDeltas_[i][0];

        this.renderer_.position_[2] = Math.min(this.renderer_.position_[2], this.browserConfig_.cameraVisibility_);

        //remove zero deltas
        if (Math.abs(1 - this.distanceDeltas_[i][0]) < 0.001) {
            this.distanceDeltas_.splice(i, 1);
            i--;
        }

        hit_ = true;
    }

    for (var i = 0; i < this.orbitDeltas_.length; i++) {
        this.orbitDeltas_[i][0] *= factorRotate_;
        this.orbitDeltas_[i][1] *= factorRotate_;
        this.orbitDeltas_[i][2] *= factorRotate_;

        this.renderer_.orientation_[0] += this.orbitDeltas_[i][0];
        this.renderer_.orientation_[1] += this.orbitDeltas_[i][1];
        this.renderer_.orientation_[2] += this.orbitDeltas_[i][2];

        //remove zero deltas
        if (Math.abs(this.orbitDeltas_[i][0])+Math.abs(this.orbitDeltas_[i][1])+Math.abs(this.orbitDeltas_[i][2]) < 0.01) {
            this.orbitDeltas_.splice(i, 1);
            i--;
        }

        hit_ = true;
    }

    //console.log("pos: " + this.renderer_.position_[0] + " "  + this.renderer_.position_[1] + " " + this.renderer_.position_[2] + "rot: " + this.renderer_.orientation_[0] + " "  + this.renderer_.orientation_[1] + " " + this.renderer_.orientation_[2]);

    if (hit_ == true) {
        this.renderer_.updateCamera();
    }

    //TODO: remove
    //this.hitTest(0,0);

    if (this.updateCallback_ != null) {
        this.updateCallback_(this.renderer_.dirty_);
    }
};

/*
bool checkSupport()

    Returns true if the environment is capable of running the WebGL browser, false otherwise.
*/

Vadstena.checkSupport = function()
{
    Vadstena.Platform.init();

    //is webgl supported
    var canvas_ = document.createElement("canvas");

    if (canvas_ == null) {
        return false;
    }

    canvas_.width = 1024;
    canvas_.height = 768;

    if (canvas_.getContext == null) {
        return false;
    }

    var gl_ = null;

    try {
        gl_ = canvas_.getContext("webgl") || canvas_.getContext("experimental-webgl");
    } catch(e) {
        return false;
    }

    if (!gl_) {
        return false;
    }

    return true;
};


//prevent minification
Vadstena["Browser"] = Vadstena.Browser;
Vadstena.Browser.prototype["setControlMode"] = Vadstena.Browser.prototype.setControlMode;
Vadstena.Browser.prototype["getControlMode"] = Vadstena.Browser.prototype.getControlMode;
Vadstena.Browser.prototype["setPosition"] = Vadstena.Browser.prototype.setPosition;
Vadstena.Browser.prototype["getPosition"] = Vadstena.Browser.prototype.getPosition;
Vadstena.Browser.prototype["setOrientation"] = Vadstena.Browser.prototype.setOrientation;
Vadstena.Browser.prototype["getOrientation"] = Vadstena.Browser.prototype.getOrientation;
Vadstena.Browser.prototype["setCamera"] = Vadstena.Browser.prototype.setCamera;
Vadstena.Browser.prototype["setCameraConstrainMode"] = Vadstena.Browser.prototype.setCameraConstrainMode;
Vadstena.Browser.prototype["getCameraConstrainMode"] = Vadstena.Browser.prototype.getCameraConstrainMode;
Vadstena.Browser.prototype["hitTest"] = Vadstena.Browser.prototype.hitTest;
Vadstena.Browser.prototype["project"] = Vadstena.Browser.prototype.project;
Vadstena.Browser.prototype["setOption"] = Vadstena.Browser.prototype.setOption;
Vadstena.Browser.prototype["getOption"] = Vadstena.Browser.prototype.getOption;
Vadstena.Browser.prototype["setData"] = Vadstena.Browser.prototype.setData;
Vadstena.Browser.prototype["getData"] = Vadstena.Browser.prototype.getData;
Vadstena.Browser.prototype["addLayer"] = Vadstena.Browser.prototype.addLayer;
Vadstena.Browser.prototype["removeLayer"] = Vadstena.Browser.prototype.removeLayer;
Vadstena.Browser.prototype["showLayer"] = Vadstena.Browser.prototype.showLayer;
Vadstena.Browser.prototype["showLayerGroup"] = Vadstena.Browser.prototype.showLayerGroup;
Vadstena.Browser.prototype["setLayerGroupTransform"] = Vadstena.Browser.prototype.setLayerGroupTransform;
Vadstena.Browser.prototype["clearStencilPasses"] = Vadstena.Browser.prototype.clearStencilPasses;
Vadstena.Browser.prototype["click"] = Vadstena.Browser.prototype.click;
Vadstena.Browser.prototype["hover"] = Vadstena.Browser.prototype.hover;
Vadstena.Browser.prototype["on"] = Vadstena.Browser.prototype.on;
Vadstena.Browser.prototype["getScreenRay"] = Vadstena.Browser.prototype.getScreenRay;
Vadstena.Browser.prototype["getCameraVector"] = Vadstena.Browser.prototype.getCameraVector;
Vadstena.Browser.prototype["getTerrainHeight"] = Vadstena.Browser.prototype.getTerrainHeight;
Vadstena.Browser.prototype["saveScreenshot"] = Vadstena.Browser.prototype.saveScreenshot;
Vadstena.Browser.prototype["visibleArea"] = Vadstena.Browser.prototype.visibleArea;
Vadstena.Browser.prototype["pan"] = Vadstena.Browser.prototype.pan;
Vadstena.Browser.prototype["rotate"] = Vadstena.Browser.prototype.rotate;
Vadstena.Browser.prototype["zoom"] = Vadstena.Browser.prototype.zoom;
Vadstena.Browser.prototype["kill"] = Vadstena.Browser.prototype.kill;
Vadstena["checkSupport"] = Vadstena.checkSupport;
Vadstena["loadJSON"] = Vadstena.loadJSON;





if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

Vadstena.Autopilot = function(engine_, finishCall_, updateCall_) {
    this.engine_ = engine_;
    this.browser_ = engine_.browser_;

    this.source_ = {
        position_ : [0,0,0],
        orientation_ : [0,0,0],
        distance_ : 1,
        heightOffset_ : 0
    };

    this.destination_ = {
        position_ : [0,0,0],
        orientation_ : [0,0,0],
        distance_ : 1,
        heightOffset_ : 0,
        autorotate_ : null
    };

    this.position_ = [0,0,0];
    this.orientation_ = [0,0,0];
    this.lastOrientation_ = [0,0,0];
    this.distance_ = 1.0;
    this.heightOffset_ = 0;

    this.mode_ = "direct";
    this.timeStart_ = 0;
    this.timeTotal_ = 0;
    this.sequenceLength_ = 1500;
    this.finished_ = true;
    this.finishCall_ = finishCall_;
    this.updateCall_ = updateCall_;
};

Vadstena.Autopilot.prototype.setSource = function(position_, orientation_, distance_, heightOffset_) {

    orientation_[0] = orientation_[0] % 360;

    this.position_ = position_;
    this.orientation_ = orientation_;
    //this.distance_ = distance_;
    this.heightOffset_ = (heightOffset_ != null) ? heightOffset_ : 0;

    this.source_ = {
        position_ : this.position_,
        orientation_ : this.orientation_,
        distance_ : this.distance_,
        heightOffset_ : (heightOffset_ != null) ? heightOffset_ : 0
    };

};

Vadstena.Autopilot.prototype.setDestination = function(position_, orientation_, distance_, heightOffset_, direct_, autorotate_) {

    //console.log("---------------------------------------");

    if (direct_) {
        this.position_ = position_;
        this.orientation_ = orientation_;
        this.distance_ = distance_;
        this.heightOffset_ = (heightOffset_ != null) ? heightOffset_ : 0;
    }

    this.source_ = {
        position_ : this.position_,
        orientation_ : this.orientation_,
        distance_ : this.distance_,
        heightOffset_ : this.heightOffset_
    };

    this.destination_ = {
        position_ : position_,
        orientation_ : orientation_,
        distance_ : distance_,
        heightOffset_ : (heightOffset_ != null) ? heightOffset_ : 0,
        autorotate_ : autorotate_
    };

    if (direct_) {
        this.finished_ = true;

        this.browser_.setPosition(this.position_[0], this.position_[1], this.position_[2]);
        this.browser_.setOrientation(this.orientation_[0], this.orientation_[1], this.orientation_[2]);
        this.browser_.setOption("cameraHeightOffset", this.heightOffset_);

        if (this.destination_.autorotate_ != null) {
            this.engine_.setAutorotate(autorotate_);
        }

    } else {

        var dx = this.destination_.position_[0] - this.source_.position_[0];
        var dy = this.destination_.position_[1] - this.source_.position_[1];
        var distance_ = Math.sqrt(dx*dx + dy*dy);

        if (distance_ < 500) {
            this.timeTotal_ = 1000;
            this.mode_ = "direct";
        } else if (distance_ < 2000) {
            this.timeTotal_ = 2000;
            this.mode_ = "direct";
        } else {

            var minCameraDistance_ = Math.min(this.source_.position_[2], this.destination_.position_[2]);

            if (minCameraDistance_ > distance_ / 4) {
                this.mode_ = "direct";
            } else {
                this.mode_ = "fly3";
            }

            this.timeTotal_ = distance_ / 100;
            this.sequenceLength_ = 1500;

            if (this.timeTotal_ < 300) {
                 this.timeTotal_ = 3000;
                 this.sequenceLength_ = 1000;
            }

            else if (this.timeTotal_ < 6000) {
                 this.timeTotal_ = 6000;
            }

            if (this.timeTotal_ > 10000) {
                 this.timeTotal_ = 10000;
            }

            if (this.mode_ != "direct") {
                this.timeTotal_ *= 1.8;
                this.sequenceLength_ *= 1.8;
            }
        }

        this.timeStart_ = (new Date()).getTime();

        this.finished_ = false;
        this.tick();
    }
};


Vadstena.Autopilot.prototype.tick = function() {

    if (this.finished_ == true) {
        return;
    }

    //TODO: use Math.sin shape to jump from one point to another, distance will be used to determine height of jump
    //      first phase of jump camera turn to the ground and rotate in fly direction
    //      second phase flying
    //      third rotate into final direction and final tilt

    var maxDistance_ = this.browser_.getOption("maxDistance");

    var time_ = (new Date()).getTime() - this.timeStart_;

    if (time_ >= this.timeTotal_) {

        var cw_ = this.orientation_[0] > this.lastOrientation_[0];

        this.position_[0] = this.destination_.position_[0];
        this.position_[1] = this.destination_.position_[1];
        this.position_[2] = this.destination_.position_[2];

        this.orientation_[0] = this.destination_.orientation_[0];
        this.orientation_[1] = this.destination_.orientation_[1];
        this.orientation_[2] = this.destination_.orientation_[2];

        this.heightOffset_ = this.destination_.heightOffset_;

        var pos = this.position_, rot = this.orientation_;
        //console.log("autopilot1 pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + " rot " + rot[0] + " " + rot[1]);

        this.browser_.setPosition(this.position_[0], this.position_[1], this.position_[2]);
        this.browser_.setOrientation(this.orientation_[0], this.orientation_[1], this.orientation_[2]);
        this.browser_.setOption("cameraHeightOffset", this.heightOffset_);

        this.browser_.renderer_.motion_ = 1.0;
        //console.log("motion: " + this.browser_.renderer_.motion_);

        if (this.finishCall_ != null) {
            if (this.destination_.autorotate_ != null) {
                this.engine_.setAutorotate(this.destination_.autorotate_);
            }

            this.finishCall_(cw_);
        }

       return;
    }

    var fadeFactor_ = 1.0;

    switch(this.mode_) {

        case "direct":

            var factor_ = time_ / this.timeTotal_;

            //blend position
            var sp1_ = this.source_.position_;
            var sp2_ = this.destination_.position_;

            this.position_ = [ sp1_[0] + (sp2_[0] - sp1_[0]) * factor_,
                               sp1_[1] + (sp2_[1] - sp1_[1]) * factor_,
                               sp1_[2] + (sp2_[2] - sp1_[2]) * factor_ ];

            //blend orientation
            var so1_ = this.source_.orientation_;
            var so2_ = this.destination_.orientation_;

            var od1_ = so2_[0] - so1_[0];
            var od2_ = so2_[1] - so1_[1];
            var od3_ = so2_[2] - so1_[2];

            if (Math.abs(od1_) > 180) {
                if (od1_ > 0) {
                    od1_ = -(360 - od1_);
                } else {
                    od1_ = 360 - Math.abs(od1_);
                }
            }

            this.lastOrientation_ = this.orientation_;
            this.orientation_ = [ so1_[0] + od1_ * factor_,
                                  so1_[1] + od2_ * factor_,
                                  so1_[2] + od3_ * factor_];

            var sho1_ = this.source_.heightOffset_;
            var sho2_ = this.destination_.heightOffset_;

            this.heightOffset_ = sho1_ + (sho2_ - sho1_) * factor_;

            break;

        case "fly":
        case "fly2":
        case "fly3":

            var factor_ = time_ / this.timeTotal_;

            var x = factor_;

            //http://en.wikipedia.org/wiki/Smoothstep
            factor_ =  x*x*(3 - 2*x);
            x = factor_;
            factor_ =  x*x*(3 - 2*x);

            fadeFactor_ = factor_;

            //this factor is used for position
            if (this.mode_ == "fly3") {
                var x = 0;

                if (time_ < this.sequenceLength_) {
                    x = 0;
                } else if (time_ > (this.timeTotal_ - this.sequenceLength_)) {
                    x = 1.0;
                } else {
                    x = Math.min(1.0, (time_-this.sequenceLength_) / (this.timeTotal_ - this.sequenceLength_*2));
                }

                x = x*x*(3 - 2*x);
                factor2_ =  x*x*(3 - 2*x);
            } else if (this.mode_ == "fly2") {
                var factor2_ = Math.min(1.0, time_ / (this.timeTotal_ - this.sequenceLength_));
                x = factor2_;
                factor2_ =  x*x*(3 - 2*x);
                x = factor2_;
                factor2_ =  x*x*(3 - 2*x);
            } else {
                factor2_ =  factor2;
            }

            //bezier curve to smooth start and end
            //var a = 0.4;
            //var t = factor_;
            //factor_ = Math.pow(1-t,3)*0+3*(Math.pow(1-t,2))*t*(0.5+a)+3*(1-t)*t*t*(0.5-a)+t*t*t*1;

            //blend position
            var sp1_ = this.source_.position_;
            var sp2_ = this.destination_.position_;

            var dx = this.destination_.position_[0] - this.source_.position_[0];
            var dy = this.destination_.position_[1] - this.source_.position_[1];
            var distance_ = Math.sqrt(dx*dx + dy*dy);



            this.position_ = [ sp1_[0] + (sp2_[0] - sp1_[0]) * factor2_,
                               sp1_[1] + (sp2_[1] - sp1_[1]) * factor2_,
                               sp1_[2] + (sp2_[2] - sp1_[2]) * factor_ + Math.sin(Math.PI * factor_)*(Math.min(maxDistance_,distance_*0.5))];

            this.position_[2] = Math.min(maxDistance_*0.98, this.position_[2]);

            //blend orientation
            var so1_ = null;
            var so2_ = null;
            var fo_ = [ 0, -90, 0]; //flight orientation

            //get fly direction angle
            fo_[0] = Math.atan2((sp2_[1] - sp1_[1]), (sp2_[0] - sp1_[0])) * (180/Math.PI) - 90;

            if (fo_[0] < 0) {
                fo_[0] = 360 - Math.abs(fo_[0]);
            }


            if (time_ <= this.sequenceLength_) { //start sequence

                factor_ = time_ / this.sequenceLength_;

                so1_ = this.source_.orientation_;
                so2_ = fo_;

            } else if (time_ >= this.timeTotal_ - this.sequenceLength_) { //end sequence

                factor_ = (time_ - (this.timeTotal_ - this.sequenceLength_)) / this.sequenceLength_;

                so1_ = fo_;
                so2_ = this.destination_.orientation_;

            } else { //fly sequence

                factor_ = 0;

                so1_ = fo_;
                so2_ = fo_;
            }


            //console.log("autopilot3 rot " + so1_[0] + " " + so2_[0]);


            var od1_ = so2_[0] - so1_[0];
            var od2_ = so2_[1] - so1_[1];
            var od3_ = so2_[2] - so1_[2];

            if (Math.abs(od1_) > 180) {
                if (od1_ > 0) {
                    od1_ = -(360 - od1_);
                } else {
                    od1_ = 360 - Math.abs(od1_);
                }
            }

            this.lastOrientation_ = this.orientation_;
            this.orientation_ = [ so1_[0] + od1_ * factor_,
                                  so1_[1] + od2_ * factor_,
                                  so1_[2] + od3_ * factor_];

            //blend height offset
            var sho1_ = this.source_.heightOffset_;
            var sho2_ = this.destination_.heightOffset_;

            this.heightOffset_ = sho1_ + (sho2_ - sho1_) * factor_;


            break;
    }

    //debug stuff
    var pos = this.position_, rot = this.orientation_;
    //console.log("pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + " rot " + rot[0] + " " + rot[1]);
    //console.log("autopilot2 pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + " rot " + rot[0] + " " + rot[1]);

    //used for motion calculation
    //var pos_ =  this.browser_.renderer_.camera_.getPosition();

    //set new position, orientation and height offset


    this.browser_.setPosition(this.position_[0], this.position_[1], this.position_[2]);
    this.browser_.setOrientation(this.orientation_[0], this.orientation_[1], this.orientation_[2]);
    this.browser_.setOption("cameraHeightOffset", this.heightOffset_);

    //reduce texel size limit during the flight, not used
    //var pos2_ =  this.browser_.renderer_.camera_.getPosition();
    //var motion_ =  Vadstena.vec3.length([pos_[0] - pos2_[0], pos_[1] - pos2_[1], pos_[2] - pos2_[2]]);
    //motion_ *= motion_ * motion_ * motion_;
    this.browser_.renderer_.motion_ = 1.0;
    //console.log("motion: " + this.browser_.renderer_.motion_);

    if (this.updateCall_ != null) {
        this.updateCall_();
    }

    window.setTimeout(this.tick.bind(this), 1000 / 60);
};

//prevet minification
Vadstena.Autopilot.prototype["setSource"] = Vadstena.Autopilot.prototype.setSource;
Vadstena.Autopilot.prototype["setDestination"] = Vadstena.Autopilot.prototype.setDestination;


if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.InterfaceBuilder = function()
{
    var element_ = document.getElementById("vadstena-engine");

    if (element_ == null){
        return;
    }

    var str_ =
        '<!-- 3D MAP -->' +
        '<div id="vadstena-engine-canvas-3d"></div>'+
        '<canvas id="vadstena-engine-canvas-2d"></canvas>'+
        '<canvas id="vadstena-engine-canvas2-2d"></canvas>'+

        '<!-- GALLERY -->'+
        '<div id="vadstena-engine-nowebgl">'+
            '<div id="vadstena-engine-nowebgl-text">'+
                '<p>Melown Maps is <a href="http://get.webgl.org/">WebGL</a> dependent service.</p>'+
                '<p>You can read more about Melown Maps in our <a/ href="https://www.melown.com/maps/about.html">About section</a>.</p>'+
            '</div>'+
        '</div>';

    str_ +=
        '<!-- LOGO SMALL -->'+
        '<a id="vadstena-engine-logo" href="' + Vadstena.HomepageUrl + '">Powered by MELOWN MAPS</a>'+

        '<!-- MENU BUTTON -->'+
        '<div id="vadstena-engine-tools-button">'+
            '<img onclick="VadstenaInterfaceCommand_(\'show-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEQzMzNCMUEyQzMzMTFFNEExMzlCRTI3NkI2NjNBNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEQzMzNCMUIyQzMzMTFFNEExMzlCRTI3NkI2NjNBNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0RDMzM0IxODJDMzMxMUU0QTEzOUJFMjc2QjY2M0E0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0RDMzM0IxOTJDMzMxMUU0QTEzOUJFMjc2QjY2M0E0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pp/Ui4oAAALZSURBVHjazJhLaFNBFIYbo+jKCKIt7tRWVNBFqIIi2bUq6MKCGnEnUomPPrZuBBfupLX1AUHQjVrblejCtqLiE7S4EKmC1ZWIVYS2K7W28Rv4A9fcm2ZmkkAPfNyQdu75c2bOmTMTy+VyNfPBFpb7gmw2W9b41tZWdyE4XcSjGZqgEephmf48AZ9gBIZhEKYrGhEEGGdtcBJeydEAjElAjQStlcBjcA0uQ1fgf4raAgsRaR7vYQlshj1wAZ7DOPwW5vML6IG9sBFMBD9A2jsiCIjL4XI4CE8cp/8HnIb7kIEUnIIZ64hIRB+YlDrsISJoZuwhCeiHuMvUmHn9pl8wW6EMNe/6qiiXFkI09vOog84qlIt2TXV6TiGISGixXYG/VRAyq3f3BNI+MiIdcB0eeTgx9eWW5Zq5Kl/hrFGxOgGbPEXctElTWTeMwjn4UxiRZhWrcUcROwMiHliO+Q4v5TM0NU2qmC62SyIOOIjI26B+REhIo/YJFxE3wGTZQ4/pfAPJqMpar73DxnZLRAs89sygj9AQJWQpTFmKMNOxrwwRxiYhYb3pRbUQ8AXeVbLABIVMKSqlrEUL09SDVWX4TigqISFjWielLKfyb/qRZ7DaU0iD1klIyIgyx9bOwCV4Chs8hCSVOSEhw6olLnYezmpLSHpU46EoIebLrVDr2j9rqkyB2mE5ZiVs15j/hdBNTyvUHR5hNpvdEfUcNmZ8XMzvM1GtYrd6zCGPHfiuKGWmZTwK64q2AURlUt16phJnniLlIiMfE3N2aIgZUJvYVQUhpk38qX7YqmftVLvY61l9o6xXBbDdunkmKjPqL2La3FJlCEhpMcfVLtgfJ/JiwJzs7sBtdVN1DgJWaEy/3nG8mAirTQ8xfaqcv+At3NNi26aas1jU6rs2Zc+ozr7ro9ZEocVcriUCh3DDFlhTcAj/DK9dDuH524BYufcjlbqWiM2Xi5p/AgwAwM6/AB42QCMAAAAASUVORK5CYII=">'+
        '</div>'+

        '<!-- CREDITS -->'+
        '<div id="vadstena-engine-credits"></div>';

    str_ +=
        '<!-- PLACE HOVER -->'+
        '<div id="vadstena-engine-place-hover"></div>' +

        '<!-- PLACE PANEL -->'+
        '<div id="vadstena-engine-place-panel"></div>'+

        '<!-- LOCATIONS PANEL -->'+
        '<div id="vadstena-engine-locations-panel"></div>';

    str_ +=
        '<!-- STATS GRAPH -->'+
        '<div id="vadstena-engine-stats-graphs">'+
            '<canvas id="vadstena-engine-stats-render" class="vadstena-engine-stats-canvas" width="500" height="100" ></canvas>'+
            '<div id="vadstena-engine-stats-info" class="vadstena-engine-stats-info" >&FilledSmallSquare; Frame: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: 1234 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Mesh: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMesh: 1234</div>'+
            '<canvas id="vadstena-engine-stats-cache" class="vadstena-engine-stats-canvas" width="500" height="100" ></canvas>'+
            '<div id="vadstena-engine-stats-info2" class="vadstena-engine-stats-info" >&FilledSmallSquare; Cache: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Used: 123 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> Mesh: &nbsp 1234</div>'+
            '<div id="vadstena-engine-stats-rec" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'recording\');">Recording On</div>'+
            '<div id="vadstena-engine-stats-ref" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'refresh\');">Refresh On</div>'+
            '<div id="vadstena-engine-stats-res" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'reset\');">Reset</div>'+
            '<div id="vadstena-engine-stats-zoom" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'zoom\');">Scale: Max value</div>'+
            '<div id="vadstena-engine-stats-magnify" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'magnify\');">Magnify Off</div>'+
            '<div id="vadstena-engine-stats-graph" class="vadstena-engine-stats-button" onclick="VadstenaInterfaceCommand_(\'stats-button\', \'graph\');">Graph: Cache</div>'+
        '</div>';


    str_ +=
        '<!-- TOOLBAR -->'+
        '<div id="vadstena-engine-toolbar">'+
            '<div id="vadstena-engine-toolbar-bottons">'+
                '<div id="vadstena-engine-toolbar-view" title="View" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'view\');"></div>'+
                '<div id="vadstena-engine-toolbar-position" title="Position" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'position\');"></div>'+
                '<div id="vadstena-engine-toolbar-length"  title="Distance" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'length\');"></div>'+
                '<div id="vadstena-engine-toolbar-distance" title="Track" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'distance\');"></div>'+
                '<div id="vadstena-engine-toolbar-break2" class="break"></div>'+
                '<div id="vadstena-engine-toolbar-streets" title="Streets" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'streets\');"></div>'+
                '<div id="vadstena-engine-toolbar-break" class="break"></div>'+
                '<div id="vadstena-engine-toolbar-stats" title="Statistics" onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'stats\');"></div>'+
                '<div id="vadstena-engine-toolbar-link" title="Link" Statistic onclick="VadstenaInterfaceCommand_(\'toolbar-button\', \'link\');"></div>'+
            '</div>'+
        '</div>';

    str_ +=
        '<!-- BLANK PRESENTATION PANEL -->'+
        '<div id="vadstena-engine-blank-presentation">'+
        '</div>';

    str_ +=
        '<!-- BIG PRESENTATION PANEL -->'+
        '<div id="vadstena-engine-big-presentation" class="vadstena-engine-big-presentation">'+

            '<!-- CAPTIONS -->'+
            '<div id="vadstena-engine-big-presentation-texts">'+
            '</div>'+

            '<!-- PREV BUTTON -->'+
            '<div id="vadstena-engine-big-presentation-prev-button" onclick="VadstenaInterfaceCommand_(\'info-button\',\'up\');">'+
                '<i class="icon-caret-left"></i> Back'+
            '</div>'+

            '<!-- NEXT BUTTON -->'+
            '<div id="vadstena-engine-big-presentation-next-button" onclick="VadstenaInterfaceCommand_(\'info-button\',\'down\');">'+
                '<span id="vadstena-engine-big-presentation-next-button-text">Continue</span> <i class="icon-caret-right"></i>'+
            '</div>'+

        '</div>';

    str_ +=
        '<!-- PRESENTATION PANEL -->'+
        '<div id="vadstena-engine-presentation" class="vadstena-engine-presentation">'+
            '<!-- PREV BUTTON -->'+
            '<div id="vadstena-engine-presentation-prev-button" onclick="VadstenaInterfaceCommand_(\'info-button\',\'up\');">'+
                '<i class="icon-caret-left"></i>'+
            '</div>'+

            '<!-- CAPTIONS -->'+
            '<div id="vadstena-engine-presentation-texts">'+
            '</div>'+

            '<!-- NEXT BUTTON -->'+
            '<div id="vadstena-engine-presentation-next-button" onclick="VadstenaInterfaceCommand_(\'info-button\',\'down\');">'+
                '<i class="icon-caret-right"></i>'+
            '</div>'+
        '</div>';


    str_ +=
        '<!-- TOOLS PANEL -->'+
        '<div id="vadstena-engine-tools" class="vadstena-engine-tools">'+

            '<!-- INFO PANEL -->'+
            '<div id="vadstena-engine-info-panel">'+
                '<h3 id="vadstena-engine-info-panel-title-block">'+
                    '<img class="vadstena-all-close" id="vadstena-engine-tools-close" onclick="VadstenaInterfaceCommand_(\'hide-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlDMkU3MEQyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlDMkU3MEUyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozOUMyRTcwQjJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozOUMyRTcwQzJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv+NYboAAALESURBVHjazJhNSFRRFMdnptRWNoJotCsTEheCiRHYxyYt0IVKai5djBjq2EKEFhZC7gI/KGGgduVHCwndaFGpFYi4aBEqfqw0UloMrdLBxv/Bv/CcmTfv3jsP8sAPHnPfve9/7z3nnnPHG41GPSfBTodCof8qIBAIHArR7JcGKsBtUALygJ9tYbAGFsE0iagO7FN8Tz72BPwEzWAddIIicJbIcxfbWsAm6LYITVlIA1gG6aAQVIEB8A1sg10iz1/ZVklhZ8ASqHf0kSRtp8AgyAJ1YFZzG3+BR2CKK3QdBMG+zoqIiDF2um8gwmozoBFIeI5wbGUh/fSHNpeC4x/HklXqUxUi+5nNZXTbOkAOtzqpED+dbYizcNv2OfZAbDT5Eih+yX11MtnvcgMxn8Gr2BW3CpHwfGC3hwlMBL82FNPPb6UlEiIDzoMdxcHeM6Le8LTVMTlzFqyTsAqpYMzr2Ac6nomYaTshV5gndO0juEcxdzT6LfKbcUIuMWl5DMXUUsxdxT6rID+RED8zqKlJNFTTgVXE/AGZutlX1X6ALSkzdDtahYRVU7aNnWdOEgeuUXg/k6sSJ2SNfmJiF8AX8BY8ZIJzsnz6SZyQY16sYQVgDjwHjzX6HYtSq5Apg7OgGHwCPeCZZt9yniVxQuTHq8yOKlZG8bIVuhV4Lii1E7IHXjDxqZjUF01g2GA7g9zKiF2pKAlvhTN1ysD1ho59ixO4nKwMkBBuZ43p9hlzVIK28BthpwptFPxmqnbb+pjdx1Rr1iAPqEGXBPg41jk7H/QlKenquJTijDdSEHGTydDLO5LWdeJIjFRR77iUvRqh7eHse1lSjoNWOxGqSW+EHr7HpDZBZ7vG8yCD5PI3aZsE38Ffnryjqdz0YqNJ7r5PLZdwWeaLMZfwDZaAQywJlC/huv8GRDjbSbfDyXtS/qg5EGAAYcKcR24KUtAAAAAASUVORK5CYII=">'+
                    '<span id="vadstena-engine-info-panel-title"></span>'+
                '</h3>'+
                '<div id="vadstena-engine-info-panel-up-button">'+
                    '<img onclick="VadstenaInterfaceCommand_(\'info-button\',\'up\');" style="margin-left:34px" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAANCAYAAACtpZ5jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozRkJFMjI3OTA3MjA2ODExODIyQTk4NzkwMUNENzlCMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDOURGNTFGRkM2NkQxMUU0QjBBN0UyRUJFMzEwNDU1RCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDOURGNTFGRUM2NkQxMUU0QjBBN0UyRUJFMzEwNDU1RCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFFOTc2Q0E0NkRDNkU0MTFCOUY4OTg2NzdBQTc3QTY1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjNGQkUyMjc5MDcyMDY4MTE4MjJBOTg3OTAxQ0Q3OUIzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0CCp2AAAARNJREFUeNqs1LtOAkEYhmFmlwUDGA0eCsTQeLoVLS3pDJUFhZW1NTUdCXfiZcAdUFlYkBgQWd+ZfJOMm+WgssmTDSy8/MweTCF/M4gQI0FRIh3/wgKf2tvXqbgt2hAtYQ+3GOMV16ihomOJPmtk5aT2Q2V9+RgdzIKJJrjDBc5QR1VDxHnxMLqPE3T1V9OMN9zjCs118bzo84qo9462lsbGjzJxFy1qvXz0Bcs1UW+KB9zgXPGa4j8mPUVvi2DoA485cXdWq3qj/8uoN9P5uEQDhwVNe4DBH6PeHE9o6Wpyazv8Z9RbaHK7pO5aTHdoZCc2OoOJ9qXgToo23U3afDC8zecmeA7EwfNg22g2vvQ/8C3AANKRioCeheA2AAAAAElFTkSuQmCC">'+
                    '<img class="vadstena-all-close" id="vadstena-engine-tools-close" onclick="VadstenaInterfaceCommand_(\'hide-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlDMkU3MEQyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlDMkU3MEUyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozOUMyRTcwQjJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozOUMyRTcwQzJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv+NYboAAALESURBVHjazJhNSFRRFMdnptRWNoJotCsTEheCiRHYxyYt0IVKai5djBjq2EKEFhZC7gI/KGGgduVHCwndaFGpFYi4aBEqfqw0UloMrdLBxv/Bv/CcmTfv3jsP8sAPHnPfve9/7z3nnnPHG41GPSfBTodCof8qIBAIHArR7JcGKsBtUALygJ9tYbAGFsE0iagO7FN8Tz72BPwEzWAddIIicJbIcxfbWsAm6LYITVlIA1gG6aAQVIEB8A1sg10iz1/ZVklhZ8ASqHf0kSRtp8AgyAJ1YFZzG3+BR2CKK3QdBMG+zoqIiDF2um8gwmozoBFIeI5wbGUh/fSHNpeC4x/HklXqUxUi+5nNZXTbOkAOtzqpED+dbYizcNv2OfZAbDT5Eih+yX11MtnvcgMxn8Gr2BW3CpHwfGC3hwlMBL82FNPPb6UlEiIDzoMdxcHeM6Le8LTVMTlzFqyTsAqpYMzr2Ac6nomYaTshV5gndO0juEcxdzT6LfKbcUIuMWl5DMXUUsxdxT6rID+RED8zqKlJNFTTgVXE/AGZutlX1X6ALSkzdDtahYRVU7aNnWdOEgeuUXg/k6sSJ2SNfmJiF8AX8BY8ZIJzsnz6SZyQY16sYQVgDjwHjzX6HYtSq5Apg7OgGHwCPeCZZt9yniVxQuTHq8yOKlZG8bIVuhV4Lii1E7IHXjDxqZjUF01g2GA7g9zKiF2pKAlvhTN1ysD1ho59ixO4nKwMkBBuZ43p9hlzVIK28BthpwptFPxmqnbb+pjdx1Rr1iAPqEGXBPg41jk7H/QlKenquJTijDdSEHGTydDLO5LWdeJIjFRR77iUvRqh7eHse1lSjoNWOxGqSW+EHr7HpDZBZ7vG8yCD5PI3aZsE38Ffnryjqdz0YqNJ7r5PLZdwWeaLMZfwDZaAQywJlC/huv8GRDjbSbfDyXtS/qg5EGAAYcKcR24KUtAAAAAASUVORK5CYII=">'+
                '</div>'+
                '<div id="vadstena-engine-info-panel-texts"></div>'+
                '<div id="vadstena-engine-info-panel-like"></div>'+
                '<div id="vadstena-engine-info-panel-down-button">'+
                    '<img onclick="VadstenaInterfaceCommand_(\'info-button\',\'down\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAANCAYAAACtpZ5jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozRkJFMjI3OTA3MjA2ODExODIyQTk4NzkwMUNENzlCMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozRjRBRTUzQUM2NkQxMUU0ODlFN0I3QTc1MzZGNTBDMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozRjRBRTUzOUM2NkQxMUU0ODlFN0I3QTc1MzZGNTBDMSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGM0U2QjA5QTNCREU0MTE4QjZCQUI5NDU0RjRENjk0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjNGQkUyMjc5MDcyMDY4MTE4MjJBOTg3OTAxQ0Q3OUIzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+OWn4kwAAASJJREFUeNqslLtOAkEUhvcilwhGRSRGjDai70AMD0Bpp7WlFHa8iKXxSayMBbUJj2BhLGgQhfXyHfJPMq6iqzLJl53JzH57zsyZDYMgWBCxnpEIRZb2Jl7hBRJ7MQ85PV0//oXcSadCmMDYJure5DzoQ9XERbick9Qi7kDNxAVYhot/Si39M9hxEduelmANzv8ofVakDdiElTh1ODcaN4Ps7UmRXsFI40mcWmTl0tOCVoaKGMIpXKv/qOjHbkGoErP9XoJ16OowZqU/gGPYhy1tZUkl+yHgr+SdGfIHOIQ9SSsp6adMfXlZp3ui1Jz0DtqwqzvwozQtz0tuKR7BPdzCAWzDBqzCoior8qXhN/JIH8h5/5NI8/71TTR2GU3buwADAO6jgVW4FvRWAAAAAElFTkSuQmCC">'+
                '</div>'+

            '</div>';

    str_ +=
            '<!-- GIS PANEL -->'+
            '<div id="vadstena-engine-gis-panel">'+

                '<h3><img class="vadstena-all-close" id="vadstena-engine-tools-close" onclick="VadstenaInterfaceCommand_(\'hide-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlDMkU3MEQyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlDMkU3MEUyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozOUMyRTcwQjJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozOUMyRTcwQzJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv+NYboAAALESURBVHjazJhNSFRRFMdnptRWNoJotCsTEheCiRHYxyYt0IVKai5djBjq2EKEFhZC7gI/KGGgduVHCwndaFGpFYi4aBEqfqw0UloMrdLBxv/Bv/CcmTfv3jsP8sAPHnPfve9/7z3nnnPHG41GPSfBTodCof8qIBAIHArR7JcGKsBtUALygJ9tYbAGFsE0iagO7FN8Tz72BPwEzWAddIIicJbIcxfbWsAm6LYITVlIA1gG6aAQVIEB8A1sg10iz1/ZVklhZ8ASqHf0kSRtp8AgyAJ1YFZzG3+BR2CKK3QdBMG+zoqIiDF2um8gwmozoBFIeI5wbGUh/fSHNpeC4x/HklXqUxUi+5nNZXTbOkAOtzqpED+dbYizcNv2OfZAbDT5Eih+yX11MtnvcgMxn8Gr2BW3CpHwfGC3hwlMBL82FNPPb6UlEiIDzoMdxcHeM6Le8LTVMTlzFqyTsAqpYMzr2Ac6nomYaTshV5gndO0juEcxdzT6LfKbcUIuMWl5DMXUUsxdxT6rID+RED8zqKlJNFTTgVXE/AGZutlX1X6ALSkzdDtahYRVU7aNnWdOEgeuUXg/k6sSJ2SNfmJiF8AX8BY8ZIJzsnz6SZyQY16sYQVgDjwHjzX6HYtSq5Apg7OgGHwCPeCZZt9yniVxQuTHq8yOKlZG8bIVuhV4Lii1E7IHXjDxqZjUF01g2GA7g9zKiF2pKAlvhTN1ysD1ho59ixO4nKwMkBBuZ43p9hlzVIK28BthpwptFPxmqnbb+pjdx1Rr1iAPqEGXBPg41jk7H/QlKenquJTijDdSEHGTydDLO5LWdeJIjFRR77iUvRqh7eHse1lSjoNWOxGqSW+EHr7HpDZBZ7vG8yCD5PI3aZsE38Ffnryjqdz0YqNJ7r5PLZdwWeaLMZfwDZaAQywJlC/huv8GRDjbSbfDyXtS/qg5EGAAYcKcR24KUtAAAAAASUVORK5CYII=">'+
                '<span id="vadstena-engine-info-panel-title">Measurements</h3>'+

                '<div id="vadstena-engine-gis-panel-coords-buttons">'+
                    'Geodetic datum: WGS84'+
                '</div>'+

                '<br/>'+
                '<span>Measurements log:</span>'+
                '<textarea id="vadstena-engine-gis-panel-texts" rows="10" cols="39" readonly></textarea>'+

                '<div id="vadstena-engine-gis-panel-coords-buttons">'+
                    '<span class="vadstena-engine-button" id="vadstena-engine-gis-panel-button-clear" onclick="VadstenaInterfaceCommand_(\'gis-button\', \'clear\');">Clear</span>'+
                    '<span class="vadstena-engine-button-disabled" id="vadstena-engine-gis-panel-button-remove-last" onclick="VadstenaInterfaceCommand_(\'gis-button\', \'remove-last\');">Remove Last Point</span>'+
                '</div>'+

            '</div>';

    str_ +=
            '<!-- LINK PANEL -->'+
            '<div id="vadstena-engine-link-panel">'+

                '<h3><img class="vadstena-all-close" id="vadstena-engine-tools-close" onclick="VadstenaInterfaceCommand_(\'hide-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlDMkU3MEQyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlDMkU3MEUyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozOUMyRTcwQjJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozOUMyRTcwQzJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv+NYboAAALESURBVHjazJhNSFRRFMdnptRWNoJotCsTEheCiRHYxyYt0IVKai5djBjq2EKEFhZC7gI/KGGgduVHCwndaFGpFYi4aBEqfqw0UloMrdLBxv/Bv/CcmTfv3jsP8sAPHnPfve9/7z3nnnPHG41GPSfBTodCof8qIBAIHArR7JcGKsBtUALygJ9tYbAGFsE0iagO7FN8Tz72BPwEzWAddIIicJbIcxfbWsAm6LYITVlIA1gG6aAQVIEB8A1sg10iz1/ZVklhZ8ASqHf0kSRtp8AgyAJ1YFZzG3+BR2CKK3QdBMG+zoqIiDF2um8gwmozoBFIeI5wbGUh/fSHNpeC4x/HklXqUxUi+5nNZXTbOkAOtzqpED+dbYizcNv2OfZAbDT5Eih+yX11MtnvcgMxn8Gr2BW3CpHwfGC3hwlMBL82FNPPb6UlEiIDzoMdxcHeM6Le8LTVMTlzFqyTsAqpYMzr2Ac6nomYaTshV5gndO0juEcxdzT6LfKbcUIuMWl5DMXUUsxdxT6rID+RED8zqKlJNFTTgVXE/AGZutlX1X6ALSkzdDtahYRVU7aNnWdOEgeuUXg/k6sSJ2SNfmJiF8AX8BY8ZIJzsnz6SZyQY16sYQVgDjwHjzX6HYtSq5Apg7OgGHwCPeCZZt9yniVxQuTHq8yOKlZG8bIVuhV4Lii1E7IHXjDxqZjUF01g2GA7g9zKiF2pKAlvhTN1ysD1ho59ixO4nKwMkBBuZ43p9hlzVIK28BthpwptFPxmqnbb+pjdx1Rr1iAPqEGXBPg41jk7H/QlKenquJTijDdSEHGTydDLO5LWdeJIjFRR77iUvRqh7eHse1lSjoNWOxGqSW+EHr7HpDZBZ7vG8yCD5PI3aZsE38Ffnryjqdz0YqNJ7r5PLZdwWeaLMZfwDZaAQywJlC/huv8GRDjbSbfDyXtS/qg5EGAAYcKcR24KUtAAAAAASUVORK5CYII=">'+
                '<span id="vadstena-engine-info-panel-title">Link to this map</h3>'+

                '<textarea id="vadstena-engine-link-panel-text" name="name" cols="40" rows="4" readonly></textarea>'+

                '<div class="vadstena-engine-link-panel-autorotate" id="vadstena-engine-link-panel-autorotate" onclick="VadstenaInterfaceCommand_(\'link-button\', \'autorotate\');"><span id="vadstena-engine-link-panel-autorotate-img" class="vadstena-engine-checkbox"></span><span>Autorotate</span></div>'+

            '</div>'+

            '<!-- STATS PANEL -->'+
            '<div id="vadstena-engine-stats-panel">'+

                '<h3><img class="vadstena-all-close" id="vadstena-engine-tools-close" onclick="VadstenaInterfaceCommand_(\'hide-menu\');" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlDMkU3MEQyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlDMkU3MEUyQzMzMTFFNDhBOTlFRjU0QkQ1MzIwMDEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozOUMyRTcwQjJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozOUMyRTcwQzJDMzMxMUU0OEE5OUVGNTRCRDUzMjAwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv+NYboAAALESURBVHjazJhNSFRRFMdnptRWNoJotCsTEheCiRHYxyYt0IVKai5djBjq2EKEFhZC7gI/KGGgduVHCwndaFGpFYi4aBEqfqw0UloMrdLBxv/Bv/CcmTfv3jsP8sAPHnPfve9/7z3nnnPHG41GPSfBTodCof8qIBAIHArR7JcGKsBtUALygJ9tYbAGFsE0iagO7FN8Tz72BPwEzWAddIIicJbIcxfbWsAm6LYITVlIA1gG6aAQVIEB8A1sg10iz1/ZVklhZ8ASqHf0kSRtp8AgyAJ1YFZzG3+BR2CKK3QdBMG+zoqIiDF2um8gwmozoBFIeI5wbGUh/fSHNpeC4x/HklXqUxUi+5nNZXTbOkAOtzqpED+dbYizcNv2OfZAbDT5Eih+yX11MtnvcgMxn8Gr2BW3CpHwfGC3hwlMBL82FNPPb6UlEiIDzoMdxcHeM6Le8LTVMTlzFqyTsAqpYMzr2Ac6nomYaTshV5gndO0juEcxdzT6LfKbcUIuMWl5DMXUUsxdxT6rID+RED8zqKlJNFTTgVXE/AGZutlX1X6ALSkzdDtahYRVU7aNnWdOEgeuUXg/k6sSJ2SNfmJiF8AX8BY8ZIJzsnz6SZyQY16sYQVgDjwHjzX6HYtSq5Apg7OgGHwCPeCZZt9yniVxQuTHq8yOKlZG8bIVuhV4Lii1E7IHXjDxqZjUF01g2GA7g9zKiF2pKAlvhTN1ysD1ho59ixO4nKwMkBBuZ43p9hlzVIK28BthpwptFPxmqnbb+pjdx1Rr1iAPqEGXBPg41jk7H/QlKenquJTijDdSEHGTydDLO5LWdeJIjFRR77iUvRqh7eHse1lSjoNWOxGqSW+EHr7HpDZBZ7vG8yCD5PI3aZsE38Ffnryjqdz0YqNJ7r5PLZdwWeaLMZfwDZaAQywJlC/huv8GRDjbSbfDyXtS/qg5EGAAYcKcR24KUtAAAAAASUVORK5CYII=">'+
                '<span id="vadstena-engine-info-panel-title">Render statistics</h3>'+

                '<p id="vadstena-engine-render-stats"></p>'+
            '</div>'+

        '</div>';


    str_ +=
        '<!-- NAVIGATION CONTROLS -->'+
        '<div id="vadstena-engine-navigation">'+

            '<!-- ZOOM BUTTONS -->'+
            '<img id="vadstena-engine-plus" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTAyOUNBMDJCQjNCMTFFM0JDQjQ5NURBODEzRTcxRTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTAyOUNBMDNCQjNCMTFFM0JDQjQ5NURBODEzRTcxRTkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5MDI5Q0EwMEJCM0IxMUUzQkNCNDk1REE4MTNFNzFFOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5MDI5Q0EwMUJCM0IxMUUzQkNCNDk1REE4MTNFNzFFOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pul3mzIAAANGSURBVHja7FlLTxNRGJ0WpNJoDSILDQ9t5NG4w52QVowGF8Z/YDfqyo0/xY0rWeFfYKExAdvYpd2Z4WEaQKILfEQwlNbSeq6em0wmM7cznUeniSc5+RrozHf6zTf3zncm1mq1tF5DXOtB9KTofp9++CQ4DV4GR8ABMAHWwDq4D+6COvgRPJEHx2IxR0mMbRzz0NMZcB681sGxH8B34keEJToN3mOUlZ4CJ8AL4CDYB54Gj1nVKvgN3AY3wSaPrYArEF4JUvQD8Do/n2WlR8Gki3McgXus9CH/9h7CX/ot+gz4ELzCKi6wuqc83Au/wS1wlVdjB3wB8b/8ED0EPuGlvwgugud8XAx+gq/BL+BX8DmE//AiWrTAU3CYlb3JnvUbouffst9F7z+D8EM70e3W6UcUPAPeDkiwxvPeYZ5h5u1oc8lzRRAtkfPYv073jBzzTaCyebeixSYxy5tukctXGBB57jLvLISn3Yi+z7jg803nBCnm1bgfOBKd4caR4s3XDUwzfxrVzjgRPc94I4Q+VvX3HD9n24mO81lCxDEvWbPZ7F96wCh1ZFDtPpXoScYpl1tzEEiyTTRzm8Yt+lmuHlGA1DGjEj3OeD4ioocYx1SiRwyXJgpImnRZik74ONH4OVklVOPWgNWXVMjlctZPQNWq8v+FQsHJ6RMmXZaVrjPWIlLpmkmXZaVr/FUNp9W2q5hcox1W1A4NqyKaK71vGImigCOTLkvRu4zfIyJaTjCfVKJ1xu2IiJY61lWitxg3I9AiIv+GQY+t6Car3eSY303sST2YF0/a2WJFPoOU+Fzd0UZTLBa9rholg562z9M6nZ8Dw+UJGxvMX0GVdafj1grjGg8OEwfMa9ThSLSodJnOzyvtnycXBo6ZT+Qt23l8KgthmVaVcH4Kht0pKDSYR+TbgeDlTnwPgSU6PmKdfEMnKAhUef515ltSfdmtl3eJPkjK5x4WXt5nzScvT0K4po/pOIkh8xbntn6P7SA2jUBcUyPydJ6kqTKnde5PlwwrU1nVw15Fa5r9mwAxhArzcJBXQL5zaWhdfhNgntyzhgneDXTudHrYL4okRI9fpfhxDqEJDhN1Vjsyb7e6hv9vbMPCHwEGAPd0FDaYMbMfAAAAAElFTkSuQmCC">'+
            '<img id="vadstena-engine-minus" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUREMDE5NURCQjNCMTFFMzhBQzJFQkIxMjY5Q0I0QjEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUREMDE5NUVCQjNCMTFFMzhBQzJFQkIxMjY5Q0I0QjEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5REQwMTk1QkJCM0IxMUUzOEFDMkVCQjEyNjlDQjRCMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5REQwMTk1Q0JCM0IxMUUzOEFDMkVCQjEyNjlDQjRCMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhZ6YaAAAAMZSURBVHja7JlLTxRBEMeHVQ6Ie5BlwWgEA5hwwEAiiSNETIwnLnrzET+Bn8YPYXzc8MTFmCjB4O56INnDJoIRDZt1YPGwIAedWav0P9pMel47j56NVvJPTyY9U7/pVE93Vfe0222t2yyndaEdj+nDh0lDpAIpj/eyfkAtUpNkQGYUhz0RwuMMaYx0toNnt0kfSPW0oHlEp0hFYaRHSBNoT5H60KdKOiR9JX0ibaC18OwO+hhJQl8mncf1CdI8aZo0G+IdFdI6aZX0Dfc+kt7GDc0jN0caxMgukBYxsp0aj/gy6RVGvokPOYwD+iTpGlqGvk26GuPPYIX0jLRL2sdH7EeB5hC4TuonjZLuIRziNg6Xx6Qt0gHppRA6oaFv4DfGcfwgYjj4WYP0EPHNofKik8VFBzCHxP2EgdlOw88g/OphoYsIhxxieCqlxY793IXfUfxeA0NfRLsQ86QLYvPwq7kNVs5lpSti8i0q2l7cgv8ieHyhx9BeSSGOveJ7DtfjftA57CW4nVG8mZsGB4/0MS/oYbQjIZfmJGwWk1HkkkLbs3UiI1vnCw4uKXQB7bmMQNvb3gEv6Lysk0IbcHBJM5deWScf25TNcA/bEK79wjDv4JJC27N0MiiBrut/gC3LCvLIL9BSqRSk76SDSwptokMtKLhp/k73EsrqawKXK/R3QLeCvrVcLicZ0y2By3Ui2p32MjIR9xxcUugm2s8Zgd6WDaIT2pDMcJX23sElhf4iJJ0VxcAVpF8ilxTaQgHFQt6m0tYFHtNva7qJ9g3yNhXWgH+RxxO6jsoPZ8VLiqCX4H9Hk5TO3NKtKtrXKKCkaavwK3IEgjYwCTimnrg9nIBV4c+CfyNsCWEN/22u/DxKIb4b8LMLv2v/VIWJTazlcXZ8B2l+nDH8FJMullqebX0ALSCk+CNuImuOEg7PtYSqpke2z0Ky2Y80n7P2SyHe8U77W58+wL0trxiOCm0nmX4nAXnsx2vYoSk9CXBWosZlFaAAVsdKl9qZiyZJ0Ya0o6dbvbhvYgOfmdMtZdaVh5//odOynwIMAFn66fVJ7Ib5AAAAAElFTkSuQmCC">'+

            '<!-- COMPASS -->'+
            '<div id="vadstena-engine-compass-main">'+
                '<div id="vadstena-engine-compass-frame">'+
                    '<img id="vadstena-engine-compass" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODRDNjZFNDJCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODRDNjZFNDNCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NEM2NkU0MEJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4NEM2NkU0MUJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pgg3VBcAAAzUSURBVHja7F1bbBTXGf7tNdiAbTAXYxscMJe04GDLwVwKNDgNhaogRB+4qKgtzUMrISEhIXjiLsT9gQd4oQ8lPFRtEdACoWCCuASRBCelJBASEnM1xsbgGwYbg03PN/4PHI93vTO7s7tnxv6kX7Pe9Y7H/zf/5fxnzn/iXr16Rd3QA3HdZHST0Q2XktFTSLKQNCGpQlKEJLL4WFqFvGRp5uMTIfVCaoQ08PvdZNgEFJ8uZIiQQQ6fu0rIfSEPmaBuMvygv5CRQrJN78cLyeLPQc4AIX2ZsB5Cegn5qZBqIff47oc8F1In5DErH5+XswWpwHdK+fMuTQYUOUrIaJPy3xLyEyYnV0iGQ3+vQsg1Vv73Qu6ayPlByI9CGrsSGf34bs5SCMgRksfKL4jSdVxmcr4WckshBhb0nZBaL5ORysrO5J+ThExmmRBjD3FJyBdCPhfSxO89YLLqvUQGsp18IcP5Z2RD04X8jC1EJ8AiPhNyjrMx4LaQK0Ja3E7GGBaZon4gZCbHBZ2BeHJKyCdKSnydxXVk+Nj1ZHFMeEfIbCGFLhuHfSnkYyFXOaYgnpREykoiQQbSz2lMCFLS+WwNbkaxkAOcAoOIC5w2a03GOCVVRXa0UMO4EE48+QdnXzIV/kZXMibwoA0WMU/Ib8mb+JuQf7GF3GO3pQ0Z8ZwZDeZMaYmQIvI2zgrZxxlXJWdgrbEmA0T8nOMEyPijBmOGaAEW8VcmA/Hj03AJCYeMOA7UKOYNFfJ7IeOpa+ErIfuFlFFbERKB/VU4d3aomMhEoID3oVUijhw5QqWlpV4hYzz/77LCPDFcNxMK3uULQJ3pdzzCtoSmpiaqqanxknXksw7SWCfvRpOMd7i0gTL2n63EiKqqKrp+vW3w2qtXL3r27JnX3BV08CfWyXDWUcTJgCW8zenrEqtmWVlZSSUlbRlg7969qbGxkTyIiawTH+soLZJk4Hen8OtfC3nfikuSBMjXHrUMifdZN8Tpvq2bPcEm8yh7j7E6oNu8eTNt3LjRIEMS0LdvXzp27BhdvnyZfD6f8RkIeu+99ygvL88LhEA3mKS6zjr73GkyQICc/kStqaedq+vTp89ry8jNzTVIAl68eEFPnz41iEpOTvaKdfRkHe1WdHfdKTJ8fMJ4/iP5wVJX3OX9+vVrRwaC+KFDhwwrgMAiBg4cSCNGjGj3ux7KsKCrv7DubpCFSm+8xRMDKAIGrb6WlZXRkydt8zJwQy9fvqT4+HhasmQJZWVlUWJiIjU0NNCdO3fo1q1brtEuLLi52dbTPjMV3eU7YRmpnKolKoGpUyQlJb2OD7AAKD09Pd1wTyDFjbh48SJduHCBVq1aZfervxLyLesQcaQ+HDJy+TiDLE4Mwf3gLgLGjh1LR48epefPnxvpbGtrK8XFxdH69euNoxusYefOnXTu3Dk6cOBAKKcoZN19zLr8LFQy4Mjx8EAKn9AS1NR1zpw5rnX6sIZNmzbRw4cPacOGDTRgwIBQTwXdnVd0WhsKGXJSqIhszFmDjOPHj9OlS5deB2vI9OnTKSMjwzXWAIsGpk2bRrNnzw7nlG+xDo+yTgOmuoGqtkkcI3DcSG0PlFkGLEOmrPL1yJEjKS0tzTXWYATM1FTDPYVhFRKojK6ltseA/kMBHpQLZBly6nSyXSJk3IC4KVNSrUFixYoVThBBrEPo8iy1PUX5jZ3UdjR/Nok8DgTn+fPndyDCAfdkxiTW6Wg7MaM/H3MozPq8zsBYaNu2bXTixImO+bxwT2vWrHH6T05knZayjqutWIZ0S3letwZ/RADLly93yj2ZkWfScVDLyGaScruSNUhMnjyZ5s6dG6lLgE7/zTouCUaGrNZhxFjgNWvYsmULPXr0KODvoFi5du3aSF5GAev2Juu6oTMy0k3ZVJewBtU9oXQTYbzNZKQHI2NIZz7Ni9aguqd58+ZF47JGKLq+2RkZeMLB5/Z4YccaouSezHHDR37WK6pkyAkj1KMyuoI1RNk9SWSwjstY583+yEg2jTNchbq6OsMaiouLbX0viu7JPJYrY51X+xtnpJnihmtw+vRpY9xgl4gouycVQ00672AZqXwc4CZr2Lp1K506dSqk70fZPfmrcqQGIiOFj33dYg1wS9XVoS3hjpF7IpOOUwKRkWSKHdoCAfrgwYMhfz+G7skcn5PUN+P9ZFM9dLcISUSoU7cxdE8SiSaddyDDx8deumdMAOZLMAeBCqsdTJo0KZbuyWwZvmBkaLsGD8Faxohly5YZU7l79uyxTAgIXL16tQ7/yshgZMhVN9U6EgH3JLOmCRMmGKksMGbMGMuEgMDMzExtXbBKxks+3tPdPZmDrxVCVAI1gFwt1BKMDO2aZG3fvr2de/J3d3dGiD8CY4yGYGRIEl7odNWoNZ08edLS3R2IEA3d03N/N75KhiRBm5UsqL5iTGHn7gYhixYt0tU9mS2jKdCgD8+BDtIpgCNOyOqrlbvbXB7R0D1JyFYXdYHIkKseH+ninuR8hJW721weARF4wkPT7OmRSecdyJD9lcrd5J78FQtBHr6jcRpbbtJ5BzKkH6t1i3vyZw34fQ1jhBm1Jp13IEMGcLRfQHPFjFi7p8LCQr+Kdak1SFSwjjtkruY58CoO4tdiQYbqnvDkur/ShYutQeIajy+qzB+YybjPZGCE+EEs3dPSpUtp6NChnVoD5iQQpAcPHkwuwk1F152S8ZCPP8TSPRUUFLQbK5itAfMRKINrUH0NBTdMug5Ihgwot6mt72tBLNzTunXrjLkKKB8kgAzVGhAbYjwfESous247BG9/ZAAoFGazbyuIlXtCCWTHjh1UW1vrBWuQwGLLVgpQjPVHRimT8XU0ru78+fPt3NOsWbNo5cqVdObMGa9Yg4orio4tkSHLIVikjU7IEVujgRVDCMrSPU2dOpUWLFjgNWuQuMQ6pUAlp0DLyBDA8fDzF5EkA9Omcv0csHv3bi9ag0QJu6iAyVEgMn5kMrAyEwstHX8QGosZ1aVbsu2RbtaARmXoHIeWG3KtonxtA3BLFxXd2iKjkesnaN7yqdNkwD1hVakZOloDGgqADNwsUpBsFBUV0cyZlnsnQ4dNrNNGu2QA3zEZZ4X8ghzsX252T5gMgjVEcMVQyMDa9YULF7Z7D60rHj+23PD5LusQ+L6zX0wIUsx6wK/RoP3DSLgnrCrFKDpCa+hCAtbGo6UGjuh3guQCDWhGjRpldH2Ai0LDGouA7p6wLmtCJUPWUTL5hFgcWOiUe4I1YJ21w8t7HQEGnGhRAaDfCa4bloyH50AGYobFbnJfsu6kLikcMup5xDhcyIlwyZDuSUdrkGUXjPplPywZrMeNG2e8J5MMtc1fEEBnmO++QxY2RbHSc+iKciwOxz2h/oQ7bteuXdoRAeTk5NCwYcOMjA6Bu7y8nPbt22dYR0JCArW0tD3MkZKS0q6IGQDFiu7+Z+XvW+nEhitAWzd0FEOfH5RI8+26JwQ9h/pwOIr6+nqjGRnu9uzsbKMznIobN24Y1w8CJNA5LkiycYV11cq6a3GKDOITysfYDzAxlvsU9ujRI5TGWVHB7du3jZIMXBDiAO5+dI9bvHix0bAMzczMZARBM73Za6OcbOxGY6cXOlwaOovhMXbcFn8gj+Lw4cPGHMmUKVNo7969NGPGDMNiECdAThB8JOQIjytOkI1m9Xb61OGkspMYOoud8SoZaiNktc2fBSLOsG6IQtjGwW7TQOTJshPlPnJwIw+doHaTw9y6xZnEEtZJC+vIdsP3hBCu9SrHi+FskiB0vNcso6KiwniNJxQt4CvWRQMPBa6G8ncTQrze/9KbRTX7+Tz5XiEDHeMsuCQ1c9rPI+xK1k1og80wNjOBRWAzk4HUvZkJaiOYqrxAYewu4+Q2P5mcYXWlbX4+YouI+TY/KiFdbQOsc0xEHWm0AZYKuTUc4sdvhCzyKBF/x1CE2hYXabc1nIruTRM1IoOo43aiC4T80uVE4DHGf5LLthOVMG+0C4vBXLobN9o9zhbgyo12VahbUKMrwAwWN2xB/QmLXH/n2i2ozVZi3py9iFNi3drvlXKKepY8uDm7CixBzeXxCIAhLjbUmqjB2ASuBw+Z4XEaOYWH8QOmSuujdRHRJON1tYEzrExlnJLD1jOWotfCFQ8hf8t3/S1lnPCAM6eo7+wYCzIkUNsaRe3btsZzPAFZI9iSnFq0U8F3+k1W9l3TQA2pKh4wi9nS61iSoaI/x49sP6N7uQvaEE6bMeOYzAlBmpIM3OW7GQG3gUfHSD/v05tZN/Mo+R6T81gHJehChopkLq2AhEEOn7uKSakkP+sjuskIjp5MUBonASkc/HtypibbBLWwNHMQfsLBt4YV36z7P+oGMroMusnQCP8XYACgtQtbAKLiKwAAAABJRU5ErkJggg==">'+
                '</div>'+

                '<div id="vadstena-engine-compass-frame2">'+
                    '<img id="vadstena-engine-compass2" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'+
                '</div>'+

                '<div id="vadstena-engine-compass-frame3">'+
                    '<img id="vadstena-engine-compass3" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'+
                '</div>'+
            '</div>'+

        '</div>';


    element_.innerHTML = str_;

};
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

/**
 * @constructor
 */
Vadstena.Interface = function(engine_)
{
    this.engine_ = engine_;
    this.browser_ = this.engine_.browser_;
    this.autopilot_ = this.engine_.autopilot_;
    this.params_ = this.engine_.params_;
    this.diagnosticMode_ = false;
    this.lastLocationId_ = null;
    this.initialized_ = false;

    //PLACES
    this.layerPlaces_ = [];
    this.hoverPlace_ = null;
    this.placePanelVisible_ = false;

    //COMPASS
    this.compassMove_ = false;
    this.compassFirst_ = false;
    this.compassAngle_ = 0;

    //LOCATIONS
    this.locationsVisible_ = false;

    //GIS
    this.gisDisplayCoords_ = "Geographic";
    this.gisCurrentTool_ = "position";
    this.gisToolData_ = { phase_: 0 };
    this.gisShowCusor_ = true;
    this.gisProj4String_ = "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84";
    this.gisProjectedCoordinateSystem_ = "UTM 33N";
    this.gisGeographicCoordinateSystem_ = "WGS84";
    this.gisCoordinateSystem_ = this.gisProjectedCoordinateSystem_;

    this.gisCanvas_ = null;
    this.gisCtx_ = null;
    this.gisCurrentPos_ = [0,0,0,false];

    this.gisIgnoreMouseUp_ = false;

    //INFO
    this.infoHideTitle_ = false;

    //PLACEMARK
    this.showPos_ = false;
    this.placemarkCanvas_ = null;
    this.placemarkCtx_ = null;

    //PANELS
    this.interfacePanelsState_ = null;
    this.interfacePanelsState2_ = null;
    this.infoPanelBanned_ = false;
    this.infoMenuClosed_ = false;
    this.infoPanelTotallyHidden_ = false;
    this.linkAutorotate_ = true;
    this.currentLocationIndex_ = null;
    this.flyLocationIndex_ = null;

    //INPUT
    this.ignoreMove_ = false;
    this.ignoreMouseUp_ = false;
    this.ignoreWheel_ = false;
    this.ignoreDoubleClick_ = false;

    this.ignorePan_ = false;

    //keyboard events
    this.altDown_ = false;
    this.ctrlDown_ = false;
    this.shiftDown_ = false;

    //mouse events
    this.ignoreMouse_ = false;
    this.mouseRightDown_ = false;
    this.mouseLeftDown_ = false;

    this.mouseLX_ = 0;
    this.mouseLY_ = 0;
    this.mouseX_ = 0;
    this.mouseY_ = 0;
    this.mouseDX_ = 0;
    this.mouseDY_ = 0;

    //touch events
    this.ignoreTouch_ = false;

    //PANELS
    this.panelVisible_ = "info";
    this.lastPanelVisible_ = "info";
    this.statsGraphsVisible_ = false;
    this.statsRefresh_ = true;
    this.statsZoom_ = "max";
    this.statsMagnify_ = false;
    this.statsShowCursor_ = false;
    this.statsGraph_ = "Cache";
    this.shareLink_ = "";

    this.init();

    this.engine_.on("location-changed", this.locationChanged.bind(this));
    var tt = this.engine_.on("flight-update", this.flightUpdate.bind(this));
    tt();
};

Vadstena.Interface.prototype.reset = function() {
    this.currentLocationIndex_ = null;
    this.flyLocationIndex_ = null;
};

Vadstena.Interface.prototype.showNoWebGLScreen = function() {
    this.setElementStyle("vadstena-engine-nowebgl", "display", "block");
//    this.hideMenuAndButton();
    this.engine_.params_.urlParams_["info"] = "0";
};

Vadstena.Interface.prototype.flightUpdate = function() {
    this.sendWSCoords();
};

Vadstena.Interface.prototype.locationChanged = function(event_, locationIndex_, skipSetLocation_) {

    if (typeof locationIndex_ == "undefined") {
        locationIndex_ = this.engine_.getCurrentLocationIndex();
    }

    if (this.currentLocationIndex_ == locationIndex_) {
        return;
    }


    this.currentLocationIndex_ = locationIndex_;

    if (locationIndex_ != -1) {

        var location_ = this.engine_.getLocationByIndex(locationIndex_);

        if (location_ == null) {
            return;
        }

        if (this.engine_.getFlightProgress() >= 1.0 && skipSetLocation_ != true) {
            this.engine_.setCurrentLocationByIndex(this.currentLocationIndex_, false, true);
        }
    }

    //this.setInfoPanelPage(0, true);
    this.updateInfoPanel(locationIndex_);

    //do not allow GIS during the flight
    //this.toolbarItemSelected("view");

};

Vadstena.Interface.prototype.init = function() {
    this.initInput();
    this.toolbarItemSelected("view");

    if (this.params_.urlParams_["wsmc"] != null) {
        this.initWS(this.params_.urlParams_["wsmc"]);
    }

};


//check galley initialization
Vadstena.Interface.prototype.onGalleryInitialized = function() {
    //TODO: only when first init
    /*
    var config_ = this.params_.config_;
    var pos_ = [0,0,0];
    if (config_["forcePositonX"] != null){ pos_[0] = config_["forcePositonX"]; }
    if (config_["forcePositonY"] != null){ pos_[1] = config_["forcePositonY"]; }
    if (config_["forceDistance"] != null){ pos_[2] = config_["forceDistance"]; }
    this.engine_.getLocationIndexFromPosition(pos_);
    */
    this.initialized_ = true;

};

//check Vadstena initialization
Vadstena.Interface.prototype.onVadstenaInitialized = function(success_, message_) {
    if (success_ == false) {
        alert("Vadstena3D initialization failed. Reason: " + message_);
        return;
    }

    //do not allow GIS when map changed
    this.toolbarItemSelected("view");

    var mapConfig_ = this.browser_.getMapConfig()["json"];

    if (mapConfig_ != null & mapConfig_["version"] != null && parseInt(mapConfig_["version"], 10) >= 2) {
        this.gisProj4String_ = mapConfig_["srs"];
        this.params_.config_["hideGis"] = this.params_.config_["initalHideGis"] == true;
        this.applyConfigParams();
    } else {
        this.params_.config_["hideGis"] = true;
        this.applyConfigParams();
    }

    this.setInfoPanelPage(0, true);

    if (this.initialized_ != true) {
        this.initialized_ = true;
        this.storeInterfacePanels2();
    }

    this.updateInfoPanel(this.engine_.getCurrentLocationIndex());

    var pos_ = this.browser_.getPosition();
    var rot_ = this.browser_.getOrientation();
    var ho_ = this.browser_.getOption("cameraHeightOffset");

    var config_ = this.params_.config_;

    //only when first location initialized
    if (this.engine_.firstLocation_ == true) {
        if (config_["forcePositonX"] != null){ pos_[0] = config_["forcePositonX"]; }
        if (config_["forcePositonY"] != null){ pos_[1] = config_["forcePositonY"]; }
        if (config_["forceDistance"] != null){ pos_[2] = config_["forceDistance"]; }
        if (config_["forceHeightOffset"] != null){ ho_ = config_["forceHeightOffset"]; }

        if (config_["forceOrientationX"] != null){  rot_[0] = config_["forceOrientationX"]; }
        if (config_["forceOrientationY"] != null){  rot_[1] = config_["forceOrientationY"]; }
        if (config_["forceAutorotate"] != null){ this.engine_.setAutorotate(config_["forceAutorotate"]); }
        this.engine_.firstLocation_ = false;
    }

    this.browser_.setPosition(pos_[0], pos_[1], pos_[2]);
    this.browser_.setOrientation(rot_[0], rot_[1], rot_[2]);
    this.browser_.setOption("cameraHeightOffset", ho_);

    if (this.params_.urlParams_["wsmc"] != null) {
        this.browser_.setOption("controlInertia", [0,0,0]);
    }

    this.setElementProperty("vadstena-engine-tools", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-info-panel", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-stats-panel", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-link-panel", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-gis-panel", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-gis-panel", "onmouseup", (function() { if (this.ignoreMouse_ != true) { this.ignoreMouseUp_ = true; } }).bind(this));
    this.setElementProperty("vadstena-engine-tools", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-tools", "ontouchend", (function() { this.ignoreMouseUp_ = true; this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-gis-panel", "ontouchend", (function() { this.ignoreMouseUp_ = true; this.ignoreDoubleClick_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-toolbar-bottons", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-bottons", "onmouseup", (function() { if (this.ignoreMouse_ != true) { this.ignoreMouseUp_ = true; } }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-bottons", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-bottons", "ontouchstart", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-bottons", "ontouchend", (function() { this.ignoreMouseUp_ = true; this.ignoreDoubleClick_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-toolbar-view", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-length", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-distance", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-position", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-stats", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-toolbar-link", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-place-panel", "onmousedown", (function() { this.ignoreMove_ = true; this.ignoreMouseUp_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-place-panel", "onmouseup", (function() { if (this.ignoreMouse_ != true) { this.ignoreMouseUp_ = true; } }).bind(this));
    this.setElementProperty("vadstena-engine-place-panel", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-place-panel", "ontouchstart", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-place-panel", "ontouchend", (function() { this.ignoreMouseUp_ = true; this.ignoreDoubleClick_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-navigation", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-tools-close", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-tools-button", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-info-panel-up-button", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-info-panel-down-button", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-presentation", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-big-presentation", "onmousedown", (function() { this.ignoreMove_ = true; }).bind(this));

    this.setElementProperty("vadstena-engine-presentation", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));
    this.setElementProperty("vadstena-engine-big-presentation", "ondblclick", (function() { this.ignoreDoubleClick_ = true; }).bind(this));



    //document.getElementById("vadstena-engine-tools").addEventListener("DOMMouseScroll", (function() { /*this.ignoreWheel_ = true;*/ }).bind(this), false);
    //document.getElementById("vadstena-engine-tools").addEventListener("mousewheel", (function() { /*this.ignoreWheel_ = true;*/ }).bind(this), false);

    this.initCompass();
};


//called when map is updated
Vadstena.Interface.prototype.onBrowserUpdate = function() {
    this.compassUpdate();


    //if (this.wsConnection_ != null) { //no autorotation

    //}

    //scan places
    this.layerPlaces_ = this.browser_.getData("layer-places");
    this.placesMouseMove();

    var locations_ = this.engine_.getLocations();

    if (locations_ != null && locations_.length > 1) {
        if (this.engine_.getFlightProgress() >= 1.0) {
            var loactionIndex_ = this.engine_.getLocationIndexFromPosition(this.browser_.getPosition(), true);
            this.locationChanged(null, loactionIndex_);
        }
    }

    switch (this.panelVisible_) {

    case "gis":      this.gisUpdate();       break;
    case "location": this.updateLinkPanel(); break;

    }

    if (this.statsGraphsVisible_ == true) {
        //this.updateStatsGraphs();
    }

    if (this.showPos_ == true) {
        this.drawPosition();
    }

};


Vadstena.Interface.prototype.command = function(command_, variable_) {

    switch(command_) {
        case "show-menu": this.showMenu(); break;
        case "hide-menu": this.hideMenu(); break;
        case "menu-tab-selected": this.menuItemSelected(variable_); break;
        case "gis-button":

            switch(variable_) {
                case 'position':     this.positionPressed();    break;
                case 'length':       this.lengthPressed();      break;
                case 'distance':     this.distancePressed();    break;
                case 'projected':    this.projectedPressed();   break;
                case 'geographic':   this.geographicPressed();  break;
                case 'clear':        this.clearPressed(); this.newDistancePressed(); break;
                case 'remove-last':  this.removeLastPressed();  break;
            }

            break;

        case "info-button":

            switch(variable_) {
                case 'next':      this.engine_.setCurrentLocationByIndex(this.engine_.getNextLocationIndex(), true && (!this.shiftDown_));     break;
                case 'previous':  this.engine_.setCurrentLocationByIndex(this.engine_.getPreviousLocationIndex(), true && (!this.shiftDown_)); break;
                case 'up':        this.setInfoPanelPage(this.getInfoPanelPage()-1); break;
                case 'down':      this.setInfoPanelPage(this.getInfoPanelPage()+1); break;
            }

            break;

        case "link-button":

            switch(variable_) {
                case 'autorotate':  this.linkAutorotate_ = !this.linkAutorotate_; this.updateLinkPanel();   break;
            }

            break;

        case "locations-button":

            this.engine_.setCurrentLocationByIndex(variable_, true && (!this.shiftDown_));
            break;

        case "toolbar-button":

            this.toolbarItemSelected(variable_);
            break;

        case "fly-to-placemark":

            //GOOGLE ANALYTICS STUFF
            var location_ = this.engine_.getCurrentLocation();

            if (location_ != null) {
                var token_ = location_["accessToken"];
                this.engine_.logGA('LinkClick', variable_);
            }

            this.engine_.flyToPlacemark(this.engine_.getCurrentLocation(), variable_);
            break;

        case "stats-button":

            switch(variable_) {
                case 'recording': this.statsRecordingPressed(); break;
                case 'refresh':   this.statsRefreshPressed();   break;
                case 'reset':     this.statsResetPressed();     break;
                case 'zoom':      this.statsZoomPressed();      break;
                case 'magnify':   this.statsMagnifyPressed();   break;
                case 'graph':     this.statsGraphPressed();     break;
            }

            break;
    }
};

Vadstena.Interface.prototype.setElementStyle = function(elementId_, property_, value_) {

    var element_ = document.getElementById(elementId_);

    if (element_ != null) {
        element_.style[property_] = value_;
    } else {
        console.log("element not found: " + elementId_);
    }
};

Vadstena.Interface.prototype.getElementStyle = function(elementId_, property_) {

    var element_ = document.getElementById(elementId_);

    if (element_ != null) {
        return element_.style[property_];
    } else {
        console.log("element not found: " + elementId_);
        return "";
    }
};

Vadstena.Interface.prototype.setElementProperty = function(elementId_, property_, value_) {

    var element_ = document.getElementById(elementId_);

    if (element_ != null) {
        element_[property_] = value_;
    } else {
        console.log("element not found: " + elementId_);
    }
};

Vadstena.Interface.prototype.setElementStyleByClass = function(classId_, property_, value_) {

    var elements_ = document.getElementsByClassName(classId_);

    if (elements_ != null && elements_.length > 0) {
        for (var i = 0, li = elements_.length; i < li; i++) {
            elements_[i].style[property_] = value_;
        }
    } else {
        console.log("element not found: " + elementId_);
    }
};


Vadstena.Interface.prototype.getElementProperty = function(elementId_, property_, value_) {

    var element_ = document.getElementById(elementId_);

    if (element_ != null) {
        return element_[property_];
    } else {
        console.log("element not found: " + elementId_);
        return "";
    }
};

Vadstena.Interface.prototype.addToElementProperty = function(elementId_, property_, value_) {

    var element_ = document.getElementById(elementId_);

    if (element_ != null) {
        element_[property_] += value_;
    } else {
        console.log("element not found: " + elementId_);
    }
};

Vadstena.Interface.prototype.applyConfigParams = function() {
    var hideInterfacePanels_ = false;

    //check if interface panels are hidden
    if (this.interfacePanelsState_ != null){
        this.showInterfacePanels();
        hideInterfacePanels_ = true;
    }

    var config_ = this.params_.config_;

    var value_ = (config_["hideNavigationControls"] == true) ? "none" : "block";

    this.setElementStyle("vadstena-engine-compass-main", "display", value_);
    this.setElementStyle("vadstena-engine-plus", "display", value_);
    this.setElementStyle("vadstena-engine-minus", "display", value_);


    if (config_["hideToolPanel"]) {
        this.hideMenuAndButton();
    } else {
        this.showMenu();
    }

    if (config_["closeToolPanel"]) {
        this.hideMenu();
    }

    if (config_["hideToolbar"] || (config_["hideGis"] && config_["hideLink"])) {
        this.hideToolbar();
    } else {
        this.showToolbar();
    }

    this.banInfoPanel(config_["hideInfo"]);

    if (config_["shareLink"]) {
        this.shareLink_ = config_["shareLink"];
    } else {
        this.shareLink_ = window.location.href;
    }

    //hide link
    this.setElementStyle("vadstena-engine-toolbar-break", "display", config_["hideLink"] ? "none" : "inline-block");
    this.setElementStyle("vadstena-engine-toolbar-link", "display", config_["hideLink"] ? "none" : "inline-block");

    //hide streets
    this.setElementStyle("vadstena-engine-toolbar-break2", "display", config_["hideGeo"] ? "none" : "inline-block");
    this.setElementStyle("vadstena-engine-toolbar-streets", "display", config_["hideGeo"] ? "none" : "inline-block");
    this.setElementProperty("vadstena-engine-toolbar-streets", "className", config_["hideStreets"] ? "" : "selected");

    //hide gis
    this.setElementStyle("vadstena-engine-toolbar-position", "display", config_["hideGis"] ? "none" : "inline-block");
    this.setElementStyle("vadstena-engine-toolbar-length", "display", config_["hideGis"] ? "none" : "inline-block");
    this.setElementStyle("vadstena-engine-toolbar-distance", "display", config_["hideGis"] ? "none" : "inline-block");

    //hide powered by
    this.setElementStyle("vadstena-engine-logo", "display", config_["hidePoweredBy"] ? "none" : "block");

    //hide credits
    this.setElementStyle("vadstena-engine-credits", "display", config_["hideCredits"] ? "none" : "block");


    var hideInterfacePanels_ = false;

    //if interface panels were hidden before then hide tham again
    if (hideInterfacePanels_ == true){
        this.hideInterfacePanels();
    }
};

//SHOW EXPORT
Vadstena.Interface.prototype.showExport = function() {
    var j = window.open("about:blank");
    j.document.write(JSON.stringify(this.engine_.export_, function(key, val) {
        return (val != null && val.toFixed) ? Number(val.toFixed(1)) : val;
        }));
    j.document.title = "Melown Maps Export";
    j.document.close();
    j.focus();
};

//SHOW POSITION
Vadstena.Interface.prototype.showPosition = function(state_) {

    if (state_ == true) {
        if (this.placemarkCanvas_ == null) {
            this.placemarkCanvas_ = document.getElementById("vadstena-engine-canvas2-2d");
            this.placemarkCtx_ = this.placemarkCanvas_.getContext("2d");
        }

        this.showPos_ = true;
        this.setElementStyle("vadstena-engine-canvas2-2d", "display", "block");
        this.drawPosition();
    } else {
        this.showPos_ = false;
        this.setElementStyle("vadstena-engine-canvas2-2d", "display", "none");
    }
};


Vadstena.Interface.prototype.drawPosition = function(pos_) {

    var element_ = document.getElementById("vadstena-engine");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();

        if (this.placemarkCanvas_.width != rect_.width) {
            this.placemarkCanvas_.width = rect_.width;
        }

        if (this.placemarkCanvas_.height != rect_.height) {
            this.placemarkCanvas_.height = rect_.height;
        }
    }

    this.placemarkCtx_.clearRect(0 ,0, this.placemarkCanvas_.width, this.placemarkCanvas_.height);

    var pos_ = this.browser_.getPosition();
    var height_ = this.browser_.getTerrainHeight(pos_[0], pos_[1]);
    pos_[2] = height_[0] + this.browser_.getOption("cameraHeightOffset");

    var p = this.browser_.project(pos_[0], pos_[1], pos_[2]);

    var lineColor_ = "#ff0000";
    var lineShadowColor_ = 'rgba(0,0,0,0.5)';
    var lineShadowSize_ = 5;

    //if (drawShadow_ == true || drawShadow_ == null) {
        this.placemarkCtx_.beginPath();
        this.placemarkCtx_.arc(p[0], p[1], 5, 0, 2 * Math.PI, false);
        this.placemarkCtx_.lineWidth = lineShadowSize_;
        this.placemarkCtx_.strokeStyle = lineShadowColor_;
        this.placemarkCtx_.stroke();
    //}

    //if (drawColor_ == true || drawColor_ == null) {
        this.placemarkCtx_.beginPath();
        this.placemarkCtx_.arc(p[0], p[1], 5, 0, 2 * Math.PI, false);
        this.placemarkCtx_.lineWidth = 1;
        this.placemarkCtx_.strokeStyle = lineColor_;
        this.placemarkCtx_.stroke();
    //}
};



//prevet minification
Vadstena.Interface.prototype["showPosition"] = Vadstena.Interface.prototype.showPosition;




//INFO PANEL
Vadstena.Interface.prototype.showInfoPanel = function() {
    if (this.infoPanelBanned_ != true){
        this.setElementStyle("vadstena-engine-info-panel", "display", "block");
    }
};

Vadstena.Interface.prototype.hideInfoPanel = function() {
    this.setElementStyle("vadstena-engine-info-panel", "display", "none");
};

Vadstena.Interface.prototype.updateInfoPanel = function(locationIndex_) {
    //console.log("updateInfoPanel start " + locationIndex_);

    if (this.initialized_ == false) {
        return;
    }

    if (locationIndex_ == -1) {

        this.hideInfoPanel();

        var currentMapData_ = this.engine_.getCurrentMapData();

        if (this.engine_.getFlightProgress() >= 1.0) {
            var locationsData_ = this.engine_.getLocationsData();
            //this.setElementProperty("vadstena-engine-info-panel-title", "innerHTML", currentMapData_["title"]);
            this.setElementProperty("vadstena-engine-info-panel-title", "innerHTML", "");
            this.setElementProperty("vadstena-engine-info-panel-texts", "innerHTML", "");
            this.setElementProperty("vadstena-engine-info-panel-like", "innerHTML", "");
        }

        var element_ = document.getElementById("vadstena-engine-credits");

        if (element_ != null) {

            //remove credits
            while (element_.firstChild) {
                element_.removeChild(element_.firstChild);
            }

            if (currentMapData_["credits"] != null &&  currentMapData_["credits"]["htmlTemplate"] != null && this.params_.config_["hideCredits"] != true) {
                element_.innerHTML = Vadstena.simpleFmtObj(currentMapData_["credits"]["htmlTemplate"], { "title": currentMapData_["title"], "sbutitle": "", "generatedBy": currentMapData_["credits"]["generatedBy"], "aerialImaginery": currentMapData_["credits"]["aerialImagery"], "homepage": Vadstena.HomepageUrl } );
            }

        }

        this.infoPanelTotallyHidden_ = true;

        if (this.panelVisible_ == "info") {
            this.totallyHideMenu();
        }

    } else {

        if (this.infoPanelTotallyHidden_ == true) {
            this.infoPanelTotallyHidden_ = false;
            this.showMenu();
        }

        if (this.panelVisible_ == "info") {
            this.showInfoPanel();
        }

        var location_ = this.engine_.getLocationByIndex(locationIndex_);

        if (location_ == null) {
            return;
        }

        this.lastLocationId_ = location_["accessToken"];

        if (location_["title"] != null) {
            this.setElementProperty("vadstena-engine-info-panel-title", "innerHTML", location_["title"]);
        }

        var page_ = this.getInfoPanelPage();
        var showTitle_ = false;

        if (page_ <= 0) {
            this.setElementStyle("vadstena-engine-info-panel-title-block", "display", "block");
            this.setElementStyle("vadstena-engine-info-panel-up-button", "display", "none");
            this.setElementStyle("vadstena-engine-presentation-prev-button", "display", "none");
            this.setElementStyle("vadstena-engine-big-presentation-prev-button", "display", "none");
            showTitle_ = true;
        } else {
            this.setElementStyle("vadstena-engine-info-panel-title-block", "display", "none");
            this.setElementStyle("vadstena-engine-info-panel-up-button", "display", "block");
            this.setElementStyle("vadstena-engine-presentation-prev-button", "display", "block");
            this.setElementStyle("vadstena-engine-big-presentation-prev-button", "display", "block");
        }

        if (location_["descriptions"] == null || page_ >= location_["descriptions"].length-1) {
            this.setElementStyle("vadstena-engine-info-panel-down-button", "display", "none");
            this.setElementStyle("vadstena-engine-presentation-next-button", "display", "none");
            this.setElementStyle("vadstena-engine-big-presentation-next-button", "display", "none");
            this.setElementStyle("vadstena-engine-info-panel-like", "display", "block");
        } else {
            this.setElementStyle("vadstena-engine-info-panel-down-button", "display", "block");
            this.setElementStyle("vadstena-engine-presentation-next-button", "display", "block");
            this.setElementStyle("vadstena-engine-big-presentation-next-button", "display", "block");

            if (location_["descriptions"] != null && location_["descriptions"][page_] != null) {
                var html_ = location_["descriptions"][page_]["html"];
            }

            if (html_ != null && html_.indexOf("data-vta-next-explore") != -1) {
                this.setElementProperty("vadstena-engine-big-presentation-next-button-text", "innerHTML", "Explore");
            } else {
                this.setElementProperty("vadstena-engine-big-presentation-next-button-text", "innerHTML", "Continue");
            }

            this.setElementStyle("vadstena-engine-info-panel-like", "display", "none");
        }

        if (location_["likeURL"] != null && location_["likeURL"] != "") {
            var tmp_ = "<iframe src='//www.facebook.com/plugins/like.php?href="+encodeURIComponent(location_["likeURL"])+"&amp;width&amp;layout=button_count&amp;action=like&amp;show_faces=false&amp;share=false&amp;height=35' scrolling='no' frameborder='0' style='border:none; overflow:hidden; height:35px; margin-bottom: -20px; margin-top: 15px; float:left;' allowTransparency='true'></iframe>";
            this.setElementProperty("vadstena-engine-info-panel-like", "innerHTML", tmp_);
        } else {
            this.setElementProperty("vadstena-engine-info-panel-like", "innerHTML", "");
        }


        if (location_["descriptions"] != null && location_["descriptions"][page_] != null) {
            var html_ = location_["descriptions"][page_]["html"];

            if (showTitle_ == true && html_ != null && html_.indexOf("data-vta-hide-title") != -1) {
                this.setElementStyle("vadstena-engine-info-panel-title", "display", "none");
            } else {
                this.setElementStyle("vadstena-engine-info-panel-title", "display", "block");
            }

            if (html_ != null && html_.indexOf("data-vta-hide-close") != -1) {
                this.setElementStyleByClass("vadstena-all-close", "visibility", "hidden");
            } else {
                this.setElementStyleByClass("vadstena-all-close", "visibility", "visible");
            }

            /*
            if (location_["descriptions"].length < 2 && location_["descriptions"][0] == "") {
                this.setElementStyleByClass("vadstena-engine-info-panel", "visibility", "hidden");
            } else {
                this.setElementStyleByClass("vadstena-engine-info-panel", "visibility", "visible");
            }
            */

            if (html_ != null && html_.indexOf("data-vta-presentation") != -1) {
                this.hideInterfacePanels2(null, true);
                this.setElementStyle("vadstena-engine-presentation", "display", "block");
                this.setElementStyle("vadstena-engine-big-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-blank-presentation", "display", "none");
                this.setElementProperty("vadstena-engine-presentation-texts", "innerHTML", html_);
            } else if (html_ != null && html_.indexOf("data-vta-big-presentation") != -1) {
                this.hideInterfacePanels2(null, true);
                this.setElementStyle("vadstena-engine-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-big-presentation", "display", "block");
                this.setElementStyle("vadstena-engine-blank-presentation", "display", "none");
                this.setElementProperty("vadstena-engine-big-presentation-texts", "innerHTML", html_);
            } else if (html_ != null && html_.indexOf("data-vta-blank-presentation") != -1) {
                this.hideInterfacePanels2(null, true);
                this.setElementStyle("vadstena-engine-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-big-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-blank-presentation", "display", "block");
                this.setElementStyle("vadstena-engine-navigation", "display", "block");
                this.setElementProperty("vadstena-engine-blank-presentation", "innerHTML", html_);
            } else {
                this.showInterfacePanels2(true);
                this.setElementStyle("vadstena-engine-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-big-presentation", "display", "none");
                this.setElementStyle("vadstena-engine-blank-presentation", "display", "none");
            }

            this.setElementProperty("vadstena-engine-info-panel-texts", "innerHTML", html_);
        } else {
            this.setElementProperty("vadstena-engine-info-panel-texts", "innerHTML", "");
        }


        var element_ = document.getElementById("vadstena-engine-credits");

        if (element_ != null) {

            //remove credits
            while (element_.firstChild) {
                element_.removeChild(element_.firstChild);
            }

            if (location_["credits"] != null &&  location_["credits"]["htmlTemplate"] != null && this.params_.config_["hideCredits"] != true) {
                element_.innerHTML = Vadstena.simpleFmtObj(location_["credits"]["htmlTemplate"], { "title": location_["title"], "subtitle": location_["subtitle"], "generatedBy": location_["credits"]["generatedBy"], "aerialImaginery": location_["credits"]["aerialImagery"], "homepage": Vadstena.HomepageUrl } );
            }
        }
    }

    var locations_ = this.engine_.getLocations();
/*
    if (locations_ != null && locations_.length > 1) {
        this.setElementStyle("vadstena-engine-info-panel-buttons", "display", "block");
    } else {
        this.setElementStyle("vadstena-engine-info-panel-buttons", "display", "none");
    }
 */

    //console.log("updateInfoPanel end " + locationIndex_);
};

Vadstena.Interface.prototype.banInfoPanel = function(state_) {
    this.infoPanelBanned_ = state_;
    if (state_ == true) {
        this.hideInfoPanel();
    } else {
        this.showInfoPanel();
    }
};

Vadstena.Interface.prototype.getInfoPanelPage = function() {
    return this.engine_.currentLocationPage_;
};

Vadstena.Interface.prototype.setInfoPanelPage = function(page_, direct_) {
    var browser_ = this.engine_.browser_;

    if (browser_ == null || browser_.isReady() == false) {
        return;
    }


    var index_ = this.engine_.getCurrentLocationIndex();

    if (index_ == -1){
        return;
    }

    var location_ = this.engine_.getCurrentLocation();

    if (page_ < 0) {
        page_ = 0;
    }

    if (location_["descriptions"] != null && page_ >= location_["descriptions"].length) {
        page_ = location_["descriptions"].length - 1;
    }

    this.engine_.currentLocationPage_ = page_;

    if (location_["descriptions"] != null && location_["descriptions"].length > 0) {
        var placemarkAlias_ = location_["descriptions"][page_]["placemarkAlias"];

        if (placemarkAlias_ != null && placemarkAlias_ != "") {
            this.engine_.flyToPlacemark(location_, placemarkAlias_, direct_);
        }
    }
    //this.engine_.showPlacemarkGeoLayers(this.engine_.getCurrentLocation(), variable_["placemark"]);

    //GOOGLE ANALYTICS STUFF
    var token_ = location_["accessToken"];
    this.engine_.logGA('PageClick', token_);
    this.engine_.logGA('PageNumber', ""+page_);

    this.updateInfoPanel(index_);
};


Vadstena.Interface.prototype.parseInfoText = function(location_) {
    this.infoHideTitle_ = false;

    var descriptions_ = location_["descriptions"];

    if (descriptions_ == null){
        return;
    }

    for (var i = 0, li = descriptions_.length; i < li; i++) {
        var html_ = descriptions_[i]["html"];

        if (html_ != null) {
            var out_ = html_.replace(/data-vta-placemark="([^"]*)"/gi
                                                , (function(match_, arg1_) {

                var placemark_ = this.engine_.findPlacemark(location_, arg1_);

                if (placemark_ != null) {
                    return "onclick='VadstenaInterfaceCommand_(\"fly-to-placemark\""
                           + ", \"" + placemark_["alias"] + "\");'";
                           + "});'";
                } else {
                    return "";
                }

            }).bind(this));

            if (location_["resourcesURL"] != null) {
                out_ = out_.replace("{resourcesURL}", location_["resourcesURL"]);
            }

            out_ = out_.replace("data-vta-page-prev", " onclick='VadstenaInterfaceCommand_(\"info-button\",\"up\");' ");
            out_ = out_.replace("data-vta-page-next", " onclick='VadstenaInterfaceCommand_(\"info-button\",\"down\");' ");

            //out_ = out_.replace("data-vta-img-help2", "src="+"\"" + Vadstena.ImgHelp2_ +"\"");
            //out_ = out_.replace("data-vta-img-help", "src="+"\"" + Vadstena.ImgHelp_ +"\"");

            descriptions_[i]["html"] = out_;
        }
    }
};

Vadstena.Interface.prototype.parseInfoTexts = function(location_) {
    var locations_ = this.engine_.getLocations();

    for (var i = 0, li = locations_.length; i < li; i++) {
        this.parseInfoText(locations_[i]);
    }
};


Vadstena.Interface.prototype.initInput = function() {

    //mouse events
    document.onmouseup = this.onMouseUp.bind(this);
    document.onmousemove = this.onMouseMove.bind(this);

    //touch events
    document.ontouchmove = this.onTouchMove.bind(this);
    document.ontouchend = this.onTouchEnd.bind(this);

    document.onselectstart = function(){ return false; }; //removes text cusor during draging

    var element_ = document.getElementById('vadstena-engine');
    this.element_ = element_;

    if (element_ != null) {
        //touch envents
        element_.ontouchstart = this.onTouchStart.bind(this);

        //mouse events
        element_.onmousedown = this.onMouseDown.bind(this);
        element_.oncontextmenu = (function(){ return false;});
        element_.ondblclick = this.onDoubleClick.bind(this);
        element_.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), false);
        element_.addEventListener("mousewheel", this.onMouseWheel.bind(this), false);
    }

    element_ = document.getElementById('vadstena-engine-canvas-2d');

    if (element_ != null) {
        element_.onmouseover = (function(){
            this.gisShowCusor_ = true;
            }).bind(this);

        element_.onmouseout = (function(){
            this.gisShowCusor_ = false;
            }).bind(this);
    }

    element_ = document.getElementById('vadstena-engine-stats-render');

    if (element_ != null) {
        element_.onmousemove = this.onStatsMouseMove.bind(this);
        element_.onmouseout = this.onStatsMouseOut.bind(this);
    }

    element_ = document.getElementById('vadstena-engine-stats-cache');

    if (element_ != null) {
        element_.onmousemove = this.onStatsMouseMove.bind(this);
        element_.onmouseout = this.onStatsMouseOut.bind(this);
    }

    //keyboard events
    document.onkeyup = this.onKeyUp.bind(this);
    document.onkeypress = this.onKeyPress.bind(this);
    document.onkeydown = this.onKeyDown.bind(this);
};


Vadstena.Interface.prototype.onDoubleClick = function(event_, skipIgnoreMouse_)
{
    if (this.engine_ == null || this.autopilot_ == null || this.browser_ == null || (this.ignoreMouse_ == true && skipIgnoreMouse_ != true)) {
        return;
    }

    if (this.ignoreDoubleClick_ == true) {
        this.ignoreDoubleClick_ = false;
        return;
    }

    var pos_ = this.browser_.hitTest(this.mouseX_, this.mouseY_, "all");
    var height_ = this.browser_.getTerrainHeight(pos_[0], pos_[1])

    var pos2_ = this.browser_.getPosition();
    var rot_ = this.browser_.getOrientation();
    var height2_ = this.browser_.getTerrainHeight(pos2_[0], pos2_[1]);

    var ray_ = this.browser_.getCameraVector();
    var pos3_ = ray_[0];

    var dx_ = pos_[0] - pos3_[0];
    var dy_ = pos_[1] - pos3_[1];
    var dz_ = pos_[2] - pos3_[2];//(height_[0] + this.browser_.getOption("cameraHeightOffset"));
    //var height3_ = this.browser_.getTerrainHeight(pos3_[0], pos3_[1]);

    var dist_ = Math.sqrt(dx_*dx_ + dy_*dy_ + dz_*dz_);

    var dist2_ = -(pos3_[2] - pos_[2]) / ray_[1][2];
    var dist3_ = -(pos3_[2] - (height2_[0] +  this.browser_.getOption("cameraHeightOffset"))) / ray_[1][2];

    //var dist_ = Math.sqrt(dx_*dx_ + dy_*dy_ + dz_*dz_);

    if (dist2_ < 0) {
        if (dist3_ < 0) {
            dist_ = 20;
        } else {
            dist_ = dist3_;
        }
    } else {
        dist_ = dist2_;
    }

    rot_[0] = rot_[0] % 360;
    rot_[1] = rot_[1] % 360;
    rot_[2] = rot_[2] % 360;

    this.autopilot_.setSource([pos2_[0], pos2_[1], pos2_[2]], [rot_[0], rot_[1], rot_[2]], null, this.browser_.getOption("cameraHeightOffset"));
    this.autopilot_.setDestination([pos_[0], pos_[1], dist_], rot_, null, (pos_[2] - height_[0]), false);
    this.engine_.setAutorotate(0);
    this.engine_.flying_ = false;
    this.engine_.shortflight_ = true;

};

Vadstena.Interface.prototype.onMouseDown = function(event, skipIgnoreMouse_)
{
    var right_ = false;
    var e = event || window.event;

    this.altDown_ = e.altKey;
    this.ctrlDown_ = e.ctrlKey;
    this.shiftDown_ = e.shiftKey;

    if (this.ignoreMouse_ == true && skipIgnoreMouse_ != true) {
        return;
    }


    if (e.which) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        right_ = e.which == 3;
    } else if (e.button) { // IE, Opera
        right_ = e.button == 2;
    }

    if (right_ == true) {
        this.mouseRightDown_ = true;
        this.placesMouseRightDown();
    } else {
        this.mouseLeftDown_ = true;

        if (this.ignoreMouse_ != true) {
            if (this.ignoreMouseUp_ != true) {
                this.placesMouseLeftDown();
            }
        }

        if (this.panelVisible_ == "gis" && this.browser_ != null) {
            this.gisMouseLeftDown();
        }
    }
};


Vadstena.Interface.prototype.onMouseUp = function(event, skipIgnoreMouse_)
{
    if (this.ignoreMouse_ == true && skipIgnoreMouse_ != true) {
        return;
    }

    //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e3.";

    var right_ = false;
    var e = event || window.event;

    if (e.which) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        right_ = e.which == 3;
    } else if (e.button) { // IE, Opera
        right_ = e.button == 2;
    }

    if (right_ == true) {
        this.mouseRightDown_ = false;
    } else {
        this.mouseLeftDown_ = false;

        //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e4.";

        if (this.ignoreMouseUp_ != true) {
          //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e5.";

            if (this.panelVisible_ == "gis" && this.browser_ != null) {
                //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e6.";
                this.gisMouseLeftUp();
            }

            this.placesMouseLeftUp();
        }
    }

    this.compassMove_ = false;
    this.ignoreMove_ = false;
    this.ignoreMouseUp_ = false;
};


Vadstena.Interface.prototype.onMouseMove = function(event, skipIgnoreMouse_)
{
    //document.getElementById("vadstena-engine-debug-text").innerHTML = "mouse-move dx " + this.mouseX_ + " dy " + this.mouseY_ + " dx" + this.mouseDX_ + " dy " + this.mouseDY_;

    if (this.ignoreMouse_ == true && skipIgnoreMouse_ != true) {
        return;
    }

    var newX_ = event.clientX;
    var newY_ = event.clientY;

    this.mouseDX_ = (newX_ - this.mouseX_);
    this.mouseDY_ = (newY_ - this.mouseY_);

    this.mouseLX_ = this.mouseX_;
    this.mouseLY_ = this.mouseY_;
    this.mouseX_ = newX_;
    this.mouseY_ = newY_;

    var panFactor_ = 0.5;
    var rotateFactor_ = 0.4;


    if (this.ignoreMove_ == true) {
        return;
    }

    if (this.browser_ == null){
        return;
    }

    if (this.compassMove_ == true) {

        this.browser_.rotate(this.mouseDX_*rotateFactor_*2, this.mouseDY_*rotateFactor_*2);
        this.engine_.setAutorotate(0);
        this.sendWSCoords();

    } else {

        this.placesMouseMove();

        // handle position change
        if (this.mouseLeftDown_ == true && !(this.altDown_ == true || this.ctrlDown_ == true || this.shiftDown_ == true)) {
            if (this.ignorePan_ != true) {
                this.browser_.pan(this.mouseDX_*panFactor_, this.mouseDY_*panFactor_);
                this.engine_.setAutorotate(0);
                this.sendWSCoords();
            }
        }

        // handle orientation change
        if (this.mouseRightDown_ == true || (this.mouseLeftDown_ == true && (this.altDown_ == true || this.ctrlDown_ == true || this.shiftDown_ == true))) {
            this.browser_.rotate(this.mouseDX_*rotateFactor_, this.mouseDY_*rotateFactor_);
            this.engine_.setAutorotate(0);
            this.sendWSCoords();
        }

    }

    if (this.panelVisible_ == "gis") {
        this.gisMouseMove();
    }

};

Vadstena.Interface.prototype.onMouseWheel = function(event, skipIgnoreMouse_)
{
    if (this.ignoreMouse_ == true && skipIgnoreMouse_ != true) {
        return;
    }

    if (event.preventDefault) {
        event.preventDefault();
    }

    event.returnValue = false;

    if (this.ignoreWheel_ == true) {
        this.ignoreWheel_ = false;
        return;
    }

    var delta_ = 0;
    var w = event.wheelDelta;
    var d = event.detail;

    if (d) {
        if (w) delta_ = w/d/40*(d>=0?1:-1); // Opera
        else delta_ = -d/3;                 // Firefox;         TO_DO: do not /3 for OS X
    } else {
        delta_ = w/120;                     // IE/Safari/Chrome TO_DO: /3 for Chrome OS X
    }

    if (isNaN(delta_) == true) {
        delta_ = 0;
    }

    var zoomFactor = 0.35;

    //change camera distance
    delta_ = (delta_<0)?1:-1;

    if (this.browser_ == null){
        return;
    }

    this.placesMouseWheel();

    if (this.diagnosticMode_ == true && this.shiftDown_ == true && this.ctrlDown_ == true) {
        this.browser_.rotate(0, 0, delta_*5);
    } else if (this.diagnosticMode_ == true && this.shiftDown_ == true) {
        this.browser_.changeFov(delta_*50*zoomFactor);
    } else {
        if (this.browser_.getControlMode() == "observer") {
            this.browser_.zoom(delta_*50*zoomFactor);
        } else {
            this.browser_.zoom(delta_*20*zoomFactor);
        }
    }

    this.engine_.setAutorotate(0);
    this.sendWSCoords();
};

//keyboard events
Vadstena.Interface.prototype.onKeyDown = function(event)
{
    if (typeof event == 'undefined') {
        event = window.event;
    }

    this.altDown_ = event.altKey;
    this.ctrlDown_ = event.ctrlKey;
    this.shiftDown_ = event.shiftKey;

    if (this.ignoreKeyboard_ == true) {
        return;
    }


    //event.preventDefault();

    this.onKeyUp(event, true);
};

Vadstena.Interface.prototype.onKeyPress = function(event)
{
    if (this.ignoreKeyboard_ == true) {
        return;
    }

    this.onKeyUp(event, true);
};

Vadstena.Interface.prototype.onKeyUp = function(event, press_)
{
    if (typeof event == 'undefined') {
        event = window.event;
    }

    this.altDown_ = event.altKey;
    this.ctrlDown_ = event.ctrlKey;
    this.shiftDown_ = event.shiftKey;

    if (this.ignoreKeyboard_ == true) {
        return;
    }


    ///event.preventDefault();
    //var done_ = (event.preventDefault) ? event.preventDefault : (function(){});
    var done_ = (function(){});

    if (event) {
        var keyCode_;

        if (window.event) {         // eg. IE
            keyCode_ = window.event.keyCode;
        } else if (event.which) {   // eg. Firefox
            keyCode_ = event.which;
        } else {
            keyCode_ = event.charCode;
        }

        if (this.shiftDown_ == true) {

            if (this.ctrlDown_ == true) {

                switch(keyCode_) {
                    case 68:
                    case 100:
                        if (event.preventDefault) event.preventDefault(); break;  //key D pressed
                }
            }
        }

        if (this.shiftDown_ == true && press_ != true && this.browser_ != null) {

            switch(keyCode_) {
                case 76:
                case 108:
                    this.showMenu(); this.toolbarItemSelected('link'); done_();  break;  //key L pressed

                case 71:
                case 103:
                    this.showMenu(); this.toolbarItemSelected('position'); done_(); break; //key G pressed

                case 65:
                case 97:
                    this.engine_.setAutorotate(1); break;  //key A pressed
            }

            if (this.ctrlDown_ == true) {

                switch(keyCode_) {
                    case 68:
                    case 100:
                        this.diagnosticMode_ = true;   break;  //key D pressed
                }

            }

            if (this.diagnosticMode_ == true) {

                switch(keyCode_) {

                    case 49: this.browser_.setControlMode("manual"); done_();  break;  //key 1 pressed
                    case 50: this.browser_.setControlMode("drone"); done_();   break;  //key 2 pressed
                    case 51: this.browser_.setControlMode("observer"); done_(); break; //key 3 pressed

                    case 48:  //key 0 pressed
                        this.browser_.setOption("noForwardMovement" , !this.browser_.getOption("noForwardMovement"));
                        break;

                    case 84:
                    case 116:
                        var pos_ = this.browser_.hitTest(this.mouseX_, this.mouseY_, "all");
                        console.log("hit pos: " + pos_[0] + " " + pos_[1] + " " + pos_[2] + " " + pos_[3] + " d " + pos_[4]); //key T pressed
                        this.browser_.logTile(pos_);
                        break;

                    case 72:
                    case 104:
                        this.drawOnlyHeightmap_ = !this.drawOnlyHeightmap_;
                        this.browser_.setOption("drawOnlyHeightmap", this.drawOnlyHeightmap_); break;  //key H pressed

                    case 80:
                    case 112:
                        this.browser_.saveScreenshot(pos_); break;  //key P pressed

                    case 83:
                    case 115:
                        this.showMenu(); this.toolbarItemSelected('stats'); break; //key S pressed

                    case 66:
                    case 98:
                        this.browser_.setOption("drawBBoxes" , !this.browser_.getOption("drawBBoxes")); break; //key B pressed

                    case 87:
                    case 119:
                        var value_ = this.browser_.getOption("drawWireframe")+1;
                        this.browser_.setOption("drawWireframe" , value_ > 2 ? 0 : value_ ); break; //key W pressed

                    case 70:
                    case 102:
                        this.browser_.setOption("drawWireframe" , this.browser_.getOption("drawWireframe") != 3 ? 3 : 0 ); break; //key F pressed

                    case 77:
                    case 109:
                        this.browser_.setOption("drawMaxLod" , !this.browser_.getOption("drawMaxLod")); break; //key M pressed

                    case 74:
                    case 106:
                        this.browser_.setOption("blendHeightmap" , !this.browser_.getOption("blendHeightmap")); break; //key J pressed

                    case 88:
                    case 120:
                        this.browser_.setOption("drawFog" , !this.browser_.getOption("drawFog")); break; //key X pressed

                    case 82:
                    case 114:
                        this.switchStatsGraphsPanel(); break; //key R pressed

                    case 69:
                    case 101:
                        this.showExport(); break; //key E pressed

                    case 79:
                    case 111:
                        this.switchLocationsPanel(); break; //key O pressed

                    case 90:
                    case 122:
                        this.browser_.setOption("ignoreTexelSize" , !this.browser_.getOption("ignoreTexelSize")); break; //key Z pressed

                        /*
                        if (this.browser_.getOption("ignoreTexelSize") != true) {
                            //this.showPosition(true);
                            //this.ignorePan(true);
                        } else {
                            //this.showPosition(false);
                            //this.ignorePan(false);
                        }

                        break; //key Z pressed
                        */
                }

            }

        }


        if (this.diagnosticMode_ == true && this.browser_.getOption("drawBBoxes") == true && this.shiftDown_ != true && press_ != true && this.browser_ != null) {

            switch(keyCode_) {
                case 76:
                case 108:
                    this.browser_.setOption("drawLods" , !this.browser_.getOption("drawLods")); break; //key L pressed

                case 80:
                case 112:
                    this.browser_.setOption("drawPositions" , !this.browser_.getOption("drawPositions")); break; //key P pressed

                case 84:
                case 116:
                    this.browser_.setOption("drawTextureSize" , !this.browser_.getOption("drawTextureSize")); break; //key T pressed

                case 83:
                case 115:
                    this.browser_.setOption("drawTexelSize" , !this.browser_.getOption("drawTexelSize")); break; //key S pressed

                case 70:
                case 102:
                    this.browser_.setOption("drawFaceCount" , !this.browser_.getOption("drawFaceCount")); break; //key F pressed

                case 68:
                case 100:
                    this.browser_.setOption("drawDistance" , !this.browser_.getOption("drawDistance")); break; //key D pressed
            }

        }

    }

    //console.log("key" + keyCode_);

    if (this.panelVisible_ == "gis") {
        this.gisKeyUp(keyCode_);
    }
};


Vadstena.Interface.prototype.isShiftDown = function() {
    return this.shiftDown_;
};

Vadstena.Interface.prototype.ignoreInputEvents = function(state_) {
    this.ignoreMouse_ = state_;
    this.ignoreTouch_ = state_;
    this.ignoreKeyboard_ = state_;

    //removes text cusor during draging
    document.onselectstart = state_ ? null : (function(){ return false; });
    //allows default touch behaviour - ios safari scrolling
    document.ontouchmove = state_ ? null : this.onTouchMove.bind(this);
    document.ontouchend = state_ ? null : this.onTouchEnd.bind(this);

    //disable right click menu
    if (this.element_ != null) {
        this.element_.oncontextmenu = state_ ? null : (function(){ return false; });
    }
};

Vadstena.Interface.prototype.ignorePan = function(state_) {
    this.ignorePan_ = state_;
};

Vadstena.Interface.prototype.getMouseState = function() {
    return {
        "x":this.mouseX_, "y": this.mouseY_,
        "lx":this.mouseLX_, "ly": this.mouseLY_,
        "dx":this.mouseDX_, "dy": this.mouseDY_,
        "l":this.mouseLeftDown_, "r": this.mouseRightDown_
    };
};


//prevet minification
Vadstena.Interface.prototype["isShiftDown"] = Vadstena.Interface.prototype.isShiftDown;
Vadstena.Interface.prototype["ignoreInputEvents"] = Vadstena.Interface.prototype.ignoreInputEvents;
Vadstena.Interface.prototype["ignorePan"] = Vadstena.Interface.prototype.ignorePan;
Vadstena.Interface.prototype["getMouseState"] = Vadstena.Interface.prototype.getMouseState;




Vadstena.Interface.prototype.onTouchStart = function(evt_) {

    //document.getElementById("vadstena-engine-debug-text").innerHTML += "sdfdsfsdf";

    if (this.ignoreTouch_ == true) {
        return;
    }

    this.ignoreMouse_ = true;

    this.inputMode_ = "down";
    //this.controlElt_.style.zIndex = 400;
    this.lockTouch_ = "";
    this.maxTouches_ = evt_.touches.length;
    this.lastTouchDistance_ = 0;

    var touch_ = evt_.touches[0];
    var bcr_ = this.element_.getBoundingClientRect();
    var newX_ = (touch_.clientX - bcr_.left);
    var newY_ = (touch_.clientY - bcr_.top);

    if (this.inputMode_ == "down") {
        this.mouseLX_ = newX_;
        this.mouseLY_ = newY_;
        this.mouseX_ = newX_;
        this.mouseY_ = newY_;
        this.mouseDX_ = 0;
        this.mouseDY_ = 0;

        //document.getElementById("vadstena-engine-debug-text").innerHTML = "touch start:  x " + newX_ + " y " + newY_;
    }

    //document.getElementById("vadstena-engine-debug-text").innerHTML += ".s.";


    document.ontouchend = this.onTouchEnd.bind(this);

    this.onMouseDown({button:1}, true);
};

Vadstena.Interface.prototype.onTouchMove = function(evt_) {

    //document.getElementById("vadstena-engine-debug-text").innerHTML = "...iii.";
    evt_.preventDefault();

    if (this.ignoreTouch_ == true) {
        return;
    }

    if (this.inputMode_ == "") {
        return;
    }

    if (evt_.touches.length > this.maxTouches_) {
        this.maxTouches_ = evt_.touches.length;
    }

    var touch_ = evt_.touches[0];
    var bcr_ = this.element_.getBoundingClientRect();
    var newX_ = (touch_.clientX - bcr_.left);
    var newY_ = (touch_.clientY - bcr_.top);

    //two fingers are right mouse button
    if (evt_.touches.length == 2) {
        if (this.mouseRightDown_ != true) {

            var touch2_ = evt_.touches[1];
            var newX2_ = (touch2_.clientX - bcr_.left);
            var newY2_ = (touch2_.clientY - bcr_.top);

            var dx_ = (newX2_ - newX_);
            var dy_ = (newY2_ - newY_);
            var distance_ = 0;

            if (isNaN(dx_) != true && isNaN(dy_) != true) {
                distance_ = Math.sqrt(dx_*dx_ + dy_*dy_);
            }

            this.lastTouchDistance_ = distance_;

            this.onMouseDown({button:2}, true);
        }
        if (this.mouseLeftDown_ == true) {
            this.onMouseUp({button:1}, true);
        }
    } else if (evt_.touches.length == 1) {
        this.lastTouchDistance_ = 0;

        if (this.inputMode_ == "pinch") {
            this.inputMode_ = "drag";
        }

        if (this.mouseLeftDown_ != true) {
            this.onMouseUp({button:1}, true);
        }
        if (this.mouseRightDown_ == true) {
            this.onMouseUp({button:2}, true);
        }
    }

    if (this.inputMode_ == "down") {
        this.mouseLX_ = newX_;
        this.mouseLY_ = newY_;
        this.mouseX_ = newX_;
        this.mouseY_ = newY_;
        this.mouseDX_ = 0;
        this.mouseDY_ = 0;
        this.inputMode_ = "drag";
    } else if (this.inputMode_ == "drag" || this.inputMode_ == "pinch") {

        if (evt_.touches.length > 1) {

            var touch2_ = evt_.touches[1];
            var newX2_ = (touch2_.clientX - bcr_.left);
            var newY2_ = (touch2_.clientY - bcr_.top);

            var dx_ = (newX2_ - newX_);
            var dy_ = (newY2_ - newY_);
            var distance_ = 0;

            if (isNaN(dx_) != true && isNaN(dy_) != true) {
                distance_ = Math.sqrt(dx_*dx_ + dy_*dy_);
            }

            if (isNaN(distance_) != true && ((Math.abs(distance_ - this.lastTouchDistance_)  > 40.0 && this.inputMode_ == "drag") || (Math.abs(distance_ - this.lastTouchDistance_)  > 20.0 && this.inputMode_ == "pinch")) ) {

                this.inputMode_ = "pinch";
                //document.getElementById("vadstena-engine-debug-text").innerHTML = "touch pinch:  delta " + ((distance_ - this.lastTouchDistance_)*6);

                var delta_ = Math.abs(distance_ - this.lastTouchDistance_);

                if (delta_  > 60.0) {
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                } else if (delta_  > 40.0) {
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                } else {
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                    this.onMouseWheel({wheelDelta: ((distance_ - this.lastTouchDistance_)*6)}, true);
                }

                this.lastTouchDistance_ = distance_;
            }
        }

        if (this.inputMode_ == "drag") {
            this.onMouseMove({clientX: newX_, clientY: newY_}, true);
        }

    }

};

Vadstena.Interface.prototype.onTouchEnd = function(evt_) {

    //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e.";

    if (this.ignoreTouch_ == true) {
        return;
    }

    this.inputMode_ = "";

    if (this.mouseLeftDown_ == true) {
        //document.getElementById("vadstena-engine-debug-text").innerHTML += ".e2.";
        this.onMouseUp({button:1}, true);
    }

    if (this.mouseRightDown_ == true) {
        this.onMouseUp({button:2}, true);
    }

    var timer_ = (new Date()).getTime();

    if (this.maxTouches_ == 1 && (timer_ - this.lastTouchTimer_) < 300) {
        this.onDoubleClick({}, true);
    }

    this.maxTouches_ = 0;
    this.lastTouchTimer_ = timer_;
    this.lastTouchDistance_ = 0;

    document.ontouchend = null;
};


//LINK PANEL
Vadstena.Interface.prototype.showLinkPanel = function() {
    this.updateLinkPanel();
    this.setElementStyle("vadstena-engine-link-panel", "display", "block");
};

Vadstena.Interface.prototype.hideLinkPanel = function() {
    this.setElementStyle("vadstena-engine-link-panel", "display", "none");
};

Vadstena.Interface.prototype.updateLinkPanel = function() {
    if (this.browser_ == null){
        return;
    }

    var locationsData_ = this.engine_.getLocationsData();

    var pos = this.browser_.getPosition();
    var rot = this.browser_.getOrientation();
    var ho_ = this.browser_.getOption("cameraHeightOffset");
    var params_ = "x=" + Math.round(pos[0]) + "&";
    params_ += "y=" + Math.round(pos[1]) + "&";
    params_ += "d=" + Math.round(pos[2]) + "&";
    params_ += "rx=" + Math.round(rot[0]%360) + "&";
    params_ += "ry=" + Math.round(rot[1]%360) + "&";
    params_ += "ho=" + Math.round(ho_) + "&";

    if (this.linkAutorotate_ == true) {
        params_ += "rotate=1";
        this.setElementProperty("vadstena-engine-link-panel-autorotate-img", "className", "vadstena-engine-checkbox selected");
    } else {
        params_ += "rotate=0";
        this.setElementProperty("vadstena-engine-link-panel-autorotate-img", "className", "vadstena-engine-checkbox");
    }

    for (var i = 1; i < 10; i++) {
        var postfix_ = (i == 1) ? "" : ("" + i);

        if (this.params_.urlParams_["kml"+postfix_] != null){
            params_ += "&kml"+postfix_+"=" + this.params_.urlParams_["kml"+postfix_];
        }

        if (this.params_.urlParams_["osm"+postfix_] != null){
            params_ += "&osm"+postfix_+"=" + this.params_.urlParams_["osm"+postfix_];
        }

        if (this.params_.urlParams_["mgl"+postfix_] != null){
            params_ += "&mgl"+postfix_+"=" + this.params_.urlParams_["mgl"+postfix_];
        }
    }

    if (this.params_.urlParams_["osm-language"] != null){
        params_ += "&osm-language=" + this.params_.urlParams_["osm-language"];
    }

    if (this.params_.urlParams_["fov"] != null){
        params_ += "&fov=" + Math.floor(this.browser_.getOption("fov")*2);//this.params_.urlParams_["fov"];
    }

    var link_ = (this.shareLink_ != null) ? (Vadstena.simpleFmtObj(this.shareLink_, {"params":params_, "accessToken": this.lastLocationId_})) : "";

    this.setElementProperty("vadstena-engine-link-panel-text", "innerHTML", link_);
};

//STATS PANEL
Vadstena.Interface.prototype.showStatsPanel = function() {
    this.setElementStyle("vadstena-engine-stats-panel", "display", "block");
};

Vadstena.Interface.prototype.hideStatsPanel = function() {
    this.setElementStyle("vadstena-engine-stats-panel", "display", "none");
};

//LOCATIONS PANEL
Vadstena.Interface.prototype.showLocationsPanel = function() {
    this.locationsVisible_ = true;

    var locations_ = this.engine_.getLocations();

    var html_ = "<ul>";

    for (var i = 0, li = locations_.length; i < li; i++) {
        html_ += '<li onclick="VadstenaInterfaceCommand_(\'locations-button\', '+i+')">';
        html_ += locations_[i]["title"] + "</li>";
    }

    html_ += "</ul>";

    this.setElementProperty("vadstena-engine-locations-panel", "innerHTML", html_);
    this.setElementStyle("vadstena-engine-locations-panel", "display", "block");
};

Vadstena.Interface.prototype.hideLocationsPanel = function() {
    this.locationsVisible_ = false;
    this.setElementStyle("vadstena-engine-locations-panel", "display", "none");
};

Vadstena.Interface.prototype.switchLocationsPanel = function() {
    if (this.locationsVisible_ == true) {
        this.hideLocationsPanel();
    } else {
        this.showLocationsPanel();
    }
};




//MENU PANELS
Vadstena.Interface.prototype.hideAllPanels = function(itemName_) {
    this.hideInfoPanel();
    this.hideLinkPanel();
    this.hideStatsPanel();
    this.hideGisPanel();
};

//MENU
Vadstena.Interface.prototype.showMenu = function() {
    //this.menuItemSelected(this.lastPanelVisible_);
    this.infoMenuClosed_ = false;
    this.setElementStyle("vadstena-engine-tools", "display", "block");
    this.setElementStyle("vadstena-engine-tools-button", "display", "none");
};

Vadstena.Interface.prototype.hideMenu = function() {
    //this.menuItemSelected("none");
    this.infoMenuClosed_ = true;
    this.setElementStyle("vadstena-engine-tools", "display", "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", "block");
};

Vadstena.Interface.prototype.totallyHideMenu = function() {
    this.infoPanelTotallyHidden_ = true;
    this.setElementStyle("vadstena-engine-tools", "display", "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", "none");
};

Vadstena.Interface.prototype.menuItemSelected = function(itemName_) {
    this.hideAllPanels();

    this.panelVisible_ = itemName_;

    if (itemName_ != "none") {
        this.lastPanelVisible_ = this.panelVisible_;
    }

    switch(itemName_) {
        case 'info':
            if (this.infoPanelTotallyHidden_ != true) {
                this.showMenu();
            } else {
                this.totallyHideMenu();
            }

            this.showInfoPanel();
            break;

        case 'gis':      this.showMenu(); this.engine_.setAutorotate(0); this.showGisPanel();   break;
        case 'location': this.showMenu(); this.engine_.setAutorotate(0); this.showLinkPanel();  break;
        case 'stats':    this.showMenu(); this.showStatsPanel(); break;
    }
};

Vadstena.Interface.prototype.hideMenuAndButton = function() {
    this.setElementStyle("vadstena-engine-tools", "display", "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", "none");
};

Vadstena.Interface.prototype.hideAdvanceTabs = function() {
    this.setElementStyle("vadstena-engine-tools-menu", "display", "none");
};

//TOOLBAR
Vadstena.Interface.prototype.hideToolbar = function(itemName_) {
    this.setElementStyle("vadstena-engine-toolbar", "display", "none");
};

Vadstena.Interface.prototype.showToolbar = function(itemName_) {
    this.setElementStyle("vadstena-engine-toolbar", "display", "block");
};


Vadstena.Interface.prototype.toolbarItemSelected = function(itemName_) {
    if (itemName_ == "streets") {
        var config_ = this.params_.config_;
        config_["hideStreets"] = !config_["hideStreets"];
        this.setElementProperty("vadstena-engine-toolbar-streets", "className", config_["hideStreets"] ? "" : "selected");
        this.browser_.setOption("drawLayers" , !this.browser_.getOption("drawLayers"));
        return;
    }

    var hideInterfacePanels_ = false;

    //check if interface panels are hidden
    if (this.interfacePanelsState_ != null){
        this.showInterfacePanels();
        hideInterfacePanels_ = true;
    }

    this.hideAllPanels();

    this.setElementProperty("vadstena-engine-toolbar-view", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-length", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-distance", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-position", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-stats", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-link", "className", "");
    this.setElementProperty("vadstena-engine-toolbar-streets", "className", "");

    this.toolbarVisible_ = itemName_;

    if (itemName_ != "none") {
        this.lastToolbarVisible_ = this.toolbarVisible_;
    }

    //show gis buttons
    switch(itemName_) {
    case 'length':
    case 'distance':
    case 'position':
        this.setElementStyle("vadstena-engine-toolbar-length", "display", "inline-block");
        this.setElementStyle("vadstena-engine-toolbar-distance", "display", "inline-block");
        this.setElementStyle("vadstena-engine-toolbar-position", "display", "inline-block");
        break;
    }

    //apply tool action
    switch(itemName_) {
    case 'view':     this.menuItemSelected("info"); this.setElementProperty("vadstena-engine-toolbar-view", "className", "selected");     break;
    case 'length':   this.menuItemSelected("gis"); this.lengthPressed(); this.setElementProperty("vadstena-engine-toolbar-length", "className", "selected");   break;
    case 'distance': this.menuItemSelected("gis"); this.distancePressed(); this.setElementProperty("vadstena-engine-toolbar-distance", "className", "selected"); break;
    case 'position': this.menuItemSelected("gis"); this.positionPressed(); this.setElementProperty("vadstena-engine-toolbar-position", "className", "selected");    break;

    case 'stats':    this.menuItemSelected("stats");
                     this.setElementStyle("vadstena-engine-toolbar-break", "display", "inline-block");
                     this.setElementStyle("vadstena-engine-toolbar-stats", "display", "inline-block");
                     this.setElementProperty("vadstena-engine-toolbar-stats", "className", "selected");
                     break;

    case 'link':     this.menuItemSelected("location");
                     this.setElementStyle("vadstena-engine-toolbar-break", "display", "inline-block");
                     this.setElementStyle("vadstena-engine-toolbar-link", "display", "inline-block");
                     this.setElementProperty("vadstena-engine-toolbar-link", "className", "selected");
                     break;
    }

    if (itemName_ == "view" && this.infoPanelBanned_ == true) {
        this.infoMenuClosed_ = false;
        this.hideMenuAndButton();
    } else {
        /*
        if (this.infoMenuClosed_ == true) {
            this.showMenu();
        } else {
            this.hideMenu();
        }*/

        if (this.infoPanelTotallyHidden_ != true) {
            this.showMenu();
        }
    }

    //if interface panels were hidden before then hide tham again
    if (hideInterfacePanels_ == true){
        this.hideInterfacePanels();
    }
};

//INTERFACE PANELS
Vadstena.Interface.prototype.hideInterfacePanels = function(keepNavigation_, keepCredits_) {

    //console.log("hideInterfacePanels 1");


    if (this.interfacePanelsState_ != null){
        return;
    }

    this.interfacePanelsState_ = {};
    this.interfacePanelsState_.toolPanel_ = (this.getElementStyle("vadstena-engine-tools", "display") != "none");
    this.interfacePanelsState_.toolPanelButoon_ = (this.getElementStyle("vadstena-engine-tools-button", "display") != "none");
    this.interfacePanelsState_.navigation_ = (this.getElementStyle("vadstena-engine-navigation", "display") != "none");
    this.interfacePanelsState_.toolbar_ = (this.getElementStyle("vadstena-engine-toolbar", "display") != "none");
    this.interfacePanelsState_.credits_ = (this.getElementStyle("vadstena-engine-credits", "display") != "none");
    this.interfacePanelsState_.presentationPanel_ = (this.getElementStyle("vadstena-engine-presentation", "display") != "none");
    this.interfacePanelsState_.presentationPanel2_ = (this.getElementStyle("vadstena-engine-big-presentation", "display") != "none");

    this.setElementStyle("vadstena-engine-tools", "display", "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", "none");
    this.setElementStyle("vadstena-engine-presentation", "display", "none");
    this.setElementStyle("vadstena-engine-big-presentation", "display", "none");

    if (keepNavigation_ != true) {
        this.setElementStyle("vadstena-engine-navigation", "display", "none");
    }

    this.setElementStyle("vadstena-engine-toolbar", "display", "none");

    if (keepCredits_ != true) {
        this.setElementStyle("vadstena-engine-credits", "display", "none");
    }

    //console.log("hideInterfacePanels 2");

};

Vadstena.Interface.prototype.showInterfacePanels = function(noInfoPanelUpdate_) {

    //console.log("showInterfacePanels 1");

    if (this.interfacePanelsState_ == null){
        this.updateInfoPanel(this.engine_.getCurrentLocationIndex());
        return;
    }

    this.setElementStyle("vadstena-engine-tools", "display", this.interfacePanelsState_.toolPanel_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", this.interfacePanelsState_.toolPanelButoon_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-navigation", "display", this.interfacePanelsState_.navigation_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-toolbar", "display", this.interfacePanelsState_.toolbar_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-credits", "display", this.interfacePanelsState_.credits_ ? "block" : "none");

    //this.setElementStyle("vadstena-engine-presentation", "display", this.interfacePanelsState_.credits_ ? "block" : "none");
    //this.setElementStyle("vadstena-engine-big-presentation", "display", this.interfacePanelsState_.credits_ ? "block" : "none");

    this.interfacePanelsState_ = null;

    //if (noInfoPanelUpdate_ != true) { //prevent loop
        this.updateInfoPanel(this.engine_.getCurrentLocationIndex());
    //}

    //console.log("showInterfacePanels 2");

};


//INTERFACE PANELS2
Vadstena.Interface.prototype.storeInterfacePanels2 = function(keepNavigation_, keepCredits_) {
    this.interfacePanelsState2_ = {};
    this.interfacePanelsState2_.toolPanel_ = (this.getElementStyle("vadstena-engine-tools", "display") != "none");
    this.interfacePanelsState2_.toolPanelButoon_ = (this.getElementStyle("vadstena-engine-tools-button", "display") != "none");
    this.interfacePanelsState2_.navigation_ = (this.getElementStyle("vadstena-engine-navigation", "display") != "none");
    this.interfacePanelsState2_.toolbar_ = (this.getElementStyle("vadstena-engine-toolbar", "display") != "none");
    this.interfacePanelsState2_.credits_ = (this.getElementStyle("vadstena-engine-credits", "display") != "none");
    this.interfacePanelsState2_.presentationPanel_ = (this.getElementStyle("vadstena-engine-presentation", "display") != "none");
    this.interfacePanelsState2_.presentationPanel2_ = (this.getElementStyle("vadstena-engine-big-presentation", "display") != "none");
};

Vadstena.Interface.prototype.hideInterfacePanels2 = function(keepNavigation_, keepCredits_) {

    //console.log("hideInterfacePanels2 1");

    this.setElementStyle("vadstena-engine-tools", "display", "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", "none");
    this.setElementStyle("vadstena-engine-presentation", "display", "none");
    this.setElementStyle("vadstena-engine-big-presentation", "display", "none");

    if (keepNavigation_ != true) {
        this.setElementStyle("vadstena-engine-navigation", "display", "none");
    }

    this.setElementStyle("vadstena-engine-toolbar", "display", "none");

    if (keepCredits_ != true) {
        this.setElementStyle("vadstena-engine-credits", "display", "none");
    }

    //console.log("hideInterfacePanels2 2");

};

Vadstena.Interface.prototype.showInterfacePanels2 = function(noInfoPanelUpdate_) {

    //console.log("showInterfacePanels2 1");

    if (this.interfacePanelsState2_ != null) {
        this.setElementStyle("vadstena-engine-tools", "display", this.interfacePanelsState2_.toolPanel_ ? "block" : "none");
        this.setElementStyle("vadstena-engine-tools-button", "display", this.interfacePanelsState2_.toolPanelButoon_ ? "block" : "none");
        this.setElementStyle("vadstena-engine-navigation", "display", this.interfacePanelsState2_.navigation_ ? "block" : "none");
        this.setElementStyle("vadstena-engine-toolbar", "display", this.interfacePanelsState2_.toolbar_ ? "block" : "none");
        this.setElementStyle("vadstena-engine-credits", "display", this.interfacePanelsState2_.credits_ ? "block" : "none");
    }

/*
    this.setElementStyle("vadstena-engine-tools", "display", this.interfacePanelsState2_.toolPanel_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-tools-button", "display", this.interfacePanelsState2_.toolPanelButoon_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-navigation", "display", this.interfacePanelsState2_.navigation_ ? "block" : "none");
    this.setElementStyle("vadstena-engine-toolbar", "display", this.interfacePanelsState2_.toolbar_ ? "block" : "none");
*/
    //this.setElementStyle("vadstena-engine-presentation", "display", this.interfacePanelsState_.credits_ ? "block" : "none");
    //this.setElementStyle("vadstena-engine-big-presentation", "display", this.interfacePanelsState_.credits_ ? "block" : "none");

    //this.interfacePanelsState2_ = null;

    if (noInfoPanelUpdate_ != true) { //prevent loop
        this.updateInfoPanel(this.engine_.getCurrentLocationIndex());
    }

    //console.log("showInterfacePanels2 2");

};

//prevet minification
Vadstena["Interface"] = Vadstena.Interface;
Vadstena.Interface.prototype["showInterfacePanels"] = Vadstena.Interface.prototype.showInterfacePanels;
Vadstena.Interface.prototype["hideInterfacePanels"] = Vadstena.Interface.prototype.hideInterfacePanels;
Vadstena.Interface.prototype["isShiftDown"] = Vadstena.Interface.prototype.isShiftDown;



Vadstena.Interface.prototype.initCompass = function() {
    this.setElementProperty("vadstena-engine-compass-main", "onmousedown", this.onVadstenaCompass.bind(this));
    this.setElementProperty("vadstena-engine-plus", "onclick", this.onVadstenaZoomIn.bind(this));
    this.setElementProperty("vadstena-engine-minus", "onclick", this.onVadstenaZoomOut.bind(this));

    this.setElementProperty("vadstena-engine-compass", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-compass2", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-compass3", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-compass-frame", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-compass-frame2", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-compass-frame3", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-plus", "ondragstart", (function() { return false; }));
    this.setElementProperty("vadstena-engine-minus", "ondragstart", (function() { return false; }));
};

Vadstena.Interface.prototype.compassUpdate = function() {
    if (this.browser_ == null){
        return;
    }

    var compass = document.getElementById("vadstena-engine-compass");
    var compass2 = document.getElementById("vadstena-engine-compass2");
    var compass3 = document.getElementById("vadstena-engine-compass3");
    var orientation = this.browser_.getOrientation();

    var value = "rotateX("+((orientation[1]+90)*0.7)+"deg) " + "rotateZ("+(orientation[0]-45)+"deg)";

    if (compass != null && compass2 != null && compass3 != null) {

        compass.style.transform = value;
        compass.style.webkitTransform = value;
        compass.style.msTransform = value;

        compass2.style.transform = value;
        compass2.style.webkitTransform = value;
        compass2.style.msTransform = value;

        compass3.style.transform = value;
        compass3.style.webkitTransform = value;
        compass3.style.msTransform = value;

    }
};

Vadstena.Interface.prototype.onVadstenaCompass = function() {
    this.compassMove_ = true;
    this.compassFirst_ = false;
};

Vadstena.Interface.prototype.onVadstenaZoomIn = function() {
    if (this.browser_ == null){
        return;
    }

    setTimeout((function(){ this.browser_.zoom(-5); setTimeout((function(){ this.browser_.zoom(-10); setTimeout((function(){ this.browser_.zoom(-10); setTimeout((function(){ this.browser_.zoom(-10); setTimeout((function(){ this.browser_.zoom(-10); setTimeout((function(){ this.browser_.zoom(-10); }).bind(this),60); }).bind(this),60);}).bind(this),60); }).bind(this),60); }).bind(this),60); }).bind(this),60);

};

Vadstena.Interface.prototype.onVadstenaZoomOut = function() {
    if (this.browser_ == null){
        return;
    }

    setTimeout((function(){ this.browser_.zoom(5); setTimeout((function(){ this.browser_.zoom(10); setTimeout((function(){ this.browser_.zoom(10); setTimeout((function(){ this.browser_.zoom(10); setTimeout((function(){ this.browser_.zoom(10); setTimeout((function(){ this.browser_.zoom(10); }).bind(this),60); }).bind(this),60);}).bind(this),60); }).bind(this),60); }).bind(this),60); }).bind(this),60);
};

Vadstena.Interface.prototype.showGisPanel = function() {
    this.gisShowCusor_ = false;
    this.setElementStyle("vadstena-engine-canvas-2d", "display", "block");
    this.setElementStyle("vadstena-engine-gis-panel", "display", "block");
};

Vadstena.Interface.prototype.hideGisPanel = function() {
    this.setElementStyle("vadstena-engine-canvas-2d", "display", "none");
    this.setElementStyle("vadstena-engine-gis-panel", "display", "none");
};

Vadstena.Interface.prototype.projectedPressed = function() {
    this.gisDisplayCoords_ = "Projected";
    this.gisCoordinateSystem_ = this.gisProjectedCoordinateSystem_;
    this.updatePanel();
    this.gisUpdate();
};

Vadstena.Interface.prototype.geographicPressed = function() {
    this.gisDisplayCoords_ = "Geographic";
    this.gisCoordinateSystem_ = this.gisGeographicCoordinateSystem_;
    this.updatePanel();
    this.gisUpdate();
};

Vadstena.Interface.prototype.positionPressed = function() {
    this.gisCurrentTool_ = "position";
    this.gisToolData_ = { phase_: 0, first_: true };
    this.updatePanel();
    this.gisUpdate();
};

Vadstena.Interface.prototype.lengthPressed = function() {
    this.gisCurrentTool_ = "length";
    this.gisToolData_ = { phase_: 0, first_: true };
    this.updatePanel();
    this.gisUpdate();
};

Vadstena.Interface.prototype.distancePressed = function() {
    this.gisCurrentTool_ = "distance";
    this.gisToolData_ = { p:[], phase_: 0, first_: true };
    this.updatePanel();
    this.gisUpdate();
};


Vadstena.Interface.prototype.clearPressed = function() {
    this.setElementProperty("vadstena-engine-gis-panel-texts", "value", "");
    this.newDistancePressed();
};

Vadstena.Interface.prototype.newDistancePressed = function() {

    switch (this.gisCurrentTool_){

        case "position":
            this.positionPressed();
            break;

        case "length":
            this.lengthPressed();
            break;

        case "distance":
            this.distancePressed();
            break;
    }
};

Vadstena.Interface.prototype.removeLastPressed = function() {

    switch (this.gisCurrentTool_){

        case "position":
            this.gisToolData_ = { phase_: 0, first_: true };
            this.gisUpdate();
            break;

        case "length":
            if (this.gisToolData_.phase_ > 0) {
                this.gisToolData_.phase_--;
                this.gisUpdate();
            }
            break;

        case "distance":
            this.gisToolData_.p.pop();

            if (this.gisToolData_.p.length == 0) {
                this.gisToolData_.phase_ = 0;
            }

            this.updatePanel();
            this.gisUpdate();
            break;
    }

};


Vadstena.Interface.prototype.updatePanel = function() {

    this.setElementProperty("vadstena-engine-gis-panel-button-projected", "className", "vadstena-engine-button-left");
    this.setElementProperty("vadstena-engine-gis-panel-button-geographic", "className", "vadstena-engine-button-right");

    switch(this.gisDisplayCoords_) {
        case "Projected": this.setElementProperty("vadstena-engine-gis-panel-button-projected", "className", "vadstena-engine-button-left-pressed"); break;
        case "Geographic": this.setElementProperty("vadstena-engine-gis-panel-button-geographic", "className", "vadstena-engine-button-right-pressed"); break;
    }

    this.setElementProperty("vadstena-engine-gis-panel-button-remove-last", "className","vadstena-engine-button");

    /*
    if (this.gisCurrentTool_ == "distance") {

        if (this.gisToolData_.p != null &&  this.gisToolData_.p.length > 0) {
            this.setElementProperty("vadstena-engine-gis-panel-button-remove-last", "className","vadstena-engine-button");
            //this.setElementProperty("vadstena-engine-gis-panel-button-new-distance", "className", "vadstena-engine-button");
        } else {
            //this.setElementProperty("vadstena-engine-gis-panel-button-new-distance", "className", "vadstena-engine-button-disabled");
            this.setElementProperty("vadstena-engine-gis-panel-button-remove-last", "className", "vadstena-engine-button-disabled");
        }

    } else {
        //this.setElementProperty("vadstena-engine-gis-panel-button-new-distance", "className", "vadstena-engine-button-disabled");
        this.setElementProperty("vadstena-engine-gis-panel-button-remove-last", "className", "vadstena-engine-button-disabled");
    }*/

    this.setElementProperty("vadstena-engine-gis-panel-coord-system", "innerHTML", "Coordinate system: " + this.gisCoordinateSystem_);
};


Vadstena.Interface.prototype.gisInit = function() {

    this.gisCanvas_ = document.getElementById("vadstena-engine-canvas-2d");

    if (this.gisToolData_ != null) {
        this.gisCtx_ = this.gisCanvas_.getContext("2d");
    }

    this.updatePanel();
};


Vadstena.Interface.prototype.roundRect = function(ctx, x, y, width_, height_, radius_, fill_, stroke_) {
    if ( typeof stroke_ == "undefined") {
        stroke_ = true;
    }
    if ( typeof radius_ === "undefined") {
        radius_ = 5;
    }

    ctx.beginPath();
    ctx.moveTo(x + radius_, y);
    ctx.lineTo(x + width_ - radius_, y);
    ctx.quadraticCurveTo(x + width_, y, x + width_, y + radius_);
    ctx.lineTo(x + width_, y + height_ - radius_);
    ctx.quadraticCurveTo(x + width_, y + height_, x + width_ - radius_, y + height_);
    ctx.lineTo(x + radius_, y + height_);
    ctx.quadraticCurveTo(x, y + height_, x, y + height_ - radius_);
    ctx.lineTo(x, y + radius_);
    ctx.quadraticCurveTo(x, y, x + radius_, y);
    ctx.closePath();

    if (stroke_) {
        ctx.stroke();
    }
    if (fill_) {
        ctx.fill();
    }
};

Vadstena.Interface.prototype.drawTooltip = function(x, y, text_, text2_, result_) {

    this.gisCtx_.font = "12px Arial";
    var textSize_ = this.gisCtx_.measureText(text_);

    var lx_ = textSize_.width;

    if (text2_ != null) {
        var textSize2_ = this.gisCtx_.measureText(text2_);

        if (textSize2_.width > lx_) {
            lx_ = textSize2_.width;
        }
    }

    if (result_ == true) {
        this.gisCtx_.fillStyle = "rgba(252,233,168,0.8)";
        this.gisCtx_.strokeStyle = "rgba(0,0,0,0.9)";
    } else {
        this.gisCtx_.fillStyle = "rgba(180,180,180,0.8)";
        this.gisCtx_.strokeStyle = "rgba(0,0,0,0.9)";
    }


    this.roundRect(this.gisCtx_, x, y, lx_ + 10, (text2_ != null) ? 40 : 20, 5, true, true);

    this.gisCtx_.fillStyle = '#000000';
    this.gisCtx_.fillText( text_, x+5, y+15);

    if (text2_ != null) {
        this.gisCtx_.fillText( text2_, x+5, y+35);
    }

};

Vadstena.Interface.prototype.drawPoint = function(x, y, drawColor_, drawShadow_) {

    var lineColor_ = "#ff0000";
    var lineShadowColor_ = 'rgba(0,0,0,0.5)';
    var lineShadowSize_ = 5;

    if (drawShadow_ == true || drawShadow_ == null) {
        this.gisCtx_.beginPath();
        this.gisCtx_.arc(x, y, 5, 0, 2 * Math.PI, false);
        this.gisCtx_.lineWidth = lineShadowSize_;
        this.gisCtx_.strokeStyle = lineShadowColor_;
        this.gisCtx_.stroke();
    }

    if (drawColor_ == true || drawColor_ == null) {
        this.gisCtx_.beginPath();
        this.gisCtx_.arc(x, y, 5, 0, 2 * Math.PI, false);
        this.gisCtx_.lineWidth = 1;
        this.gisCtx_.strokeStyle = lineColor_;
        this.gisCtx_.stroke();
    }
};

Vadstena.Interface.prototype.getUtmRegion = function(x, y) {
    var xx = x + 186;

    //clip just in case
    if (xx < 0){
        xx = 0;
    }

    if (xx > 359){
        xx = 359;
    }

    return Math.floor(xx/6);
};

Vadstena.Interface.prototype.adjustHeight = function(x, y, height_) {

    var mapConfig_ = this.browser_.getMapConfig()["json"];

    if (mapConfig_ != null && mapConfig_["verticalAdjustment"] != true) {
        return height_;
    }

    var distance_ = 1000;

    var geoPos_ =  proj4_(this.gisProj4String_)["inverse"]([x, y]);
    var geoPos2_ =  proj4_(this.gisProj4String_)["inverse"]([x + distance_, y]);

    var utmRegion_ = this.getUtmRegion(geoPos_[0], geoPos_[1]);

    var newProj4String_ = "+proj=utm +zone=" + utmRegion_ + " +ellps=WGS84 +datum=WGS84";

    var projPos_ =  proj4_(newProj4String_)["forward"]([geoPos_[0], geoPos_[1]]);
    var projPos2_ =  proj4_(newProj4String_)["forward"]([geoPos2_[0], geoPos2_[1]]);


    var dx_ = projPos_[0] - projPos2_[0];
    var dy_ = projPos_[1] - projPos2_[1];

    var newDistance_ = Math.sqrt(dx_*dx_ + dy_*dy_);


    return height_ * (newDistance_ / distance_);
};

Vadstena.Interface.prototype.getCoordsString = function(x, y, height_) {

    var text_ = "";

    if (this.gisDisplayCoords_ == "Projected") {
        text_ = "x:" + x.toFixed(1) + " y:" + y.toFixed(1) + " a:" + height_.toFixed(1) + "m";
    }

    if (this.gisDisplayCoords_ == "Geographic") {

        text_ = "";

        if (pos2[1] < 0) {
            text_ += y.toFixed(7) + "\xB0S "
        } else {
            text_ += y.toFixed(7) + "\xB0N "
        }

        if (pos2[0] < 0) {
            text_ += x.toFixed(7) + "\xB0W "
        } else {
            text_ += x.toFixed(7) + "\xB0E "
        }

        text_ += " " + height_.toFixed(1) + "m";
    }


    return text_;
};

Vadstena.Interface.prototype.getDistanceString = function(distance_) {
    var text_ = "";

    if (distance_ > 1000) {
        text_ += (distance_/1000).toFixed(2) + "km";
    } else {
        text_ += distance_.toFixed(2) + "m";
    }

    return text_;
};


Vadstena.Interface.prototype.gisUpdate = function() {
    if (this.browser_ == null){
        return;
    }

    if (this.gisCanvas_ == null) {
        this.gisInit();
    }

    var screenFactor_ = window["VadstenaScreenScaleFactor_"];
    var element_ = document.getElementById("vadstena-engine");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();
        var lx_ = Math.floor(rect_.width  * screenFactor_);
        var ly_ = Math.floor(rect_.height  * screenFactor_);

        if (this.gisCanvas_.width != lx_) {
            this.gisCanvas_.width = lx_;
        }

        if (this.gisCanvas_.height != ly_) {
            this.gisCanvas_.height = ly_;
        }
    }

    this.gisCtx_.clearRect(0 ,0, this.gisCanvas_.width, this.gisCanvas_.height);

    var pos = this.browser_.hitTest(this.mouseX_*screenFactor_, this.mouseY_*screenFactor_, "all");

    this.gisCurrentPos_ = pos;

    var p = this.browser_.project(pos[0], pos[1], pos[2]);

    var text2_ = "";
    var lineColor_ = "#ff0000";
    var lineShadowColor_ = 'rgba(0,0,0,0.5)';
    var lineShadowSize_ = 5;

    switch(this.gisCurrentTool_) {
        case "position":

            if (this.gisToolData_.first_ != true) {
                var p1 = this.browser_.project(this.gisToolData_.p1[0], this.gisToolData_.p1[1], this.gisToolData_.p1[2]);
                this.drawPoint(p1[0], p1[1]);
                this.drawTooltip(Math.round(p1[0]), Math.round(p1[1]), this.gisToolData_.text_, null, true);
            }

            break;

        case "length":

            if (this.gisToolData_.first_ == true) {
                break;
            }

            var p1 = this.browser_.project(this.gisToolData_.p1[0], this.gisToolData_.p1[1], this.gisToolData_.p1[2]);
            var p2 = this.browser_.project(this.gisToolData_.p2[0], this.gisToolData_.p2[1], this.gisToolData_.p2[2]);


            if (this.gisToolData_.phase_ == 1 || this.gisToolData_.phase_ == 2) {
                this.drawPoint(p1[0], p1[1]);
            }

            if (this.gisToolData_.phase_ == 2) {
                this.drawPoint(p2[0], p2[1]);
            }


            if (this.gisToolData_.phase_ == 2) {
                this.gisCtx_.beginPath();
                this.gisCtx_.moveTo(p1[0], p1[1]);
                this.gisCtx_.lineTo(p2[0], p2[1]);
                this.gisCtx_.lineCap = 'round';
                this.gisCtx_.lineWidth = lineShadowSize_;

                this.gisCtx_.strokeStyle = lineShadowColor_;
                this.gisCtx_.stroke();

                this.gisCtx_.beginPath();
                this.gisCtx_.arc(p2[0], p2[1], 5, 0, 2 * Math.PI, false);
                this.gisCtx_.moveTo(p1[0], p1[1]);
                this.gisCtx_.lineTo(p2[0], p2[1]);
                this.gisCtx_.lineCap = 'butt';
                this.gisCtx_.lineWidth = 1;

                this.gisCtx_.strokeStyle = lineColor_;
                this.gisCtx_.stroke();
            }

            var dx = pos[0]-this.gisToolData_.p1[0];
            var dy = pos[1]-this.gisToolData_.p1[1];
            var dz = pos[2]-this.gisToolData_.p1[2];

            var l = Math.sqrt(dx*dx + dy*dy + dz*dz);

            var azimut_ = Math.atan2(dx,dy);
            azimut_ = (azimut_ / Math.PI * 180.0);

            if (azimut_ < 0) {
                azimut_ = 360 + azimut_;
            }

            if (this.gisToolData_.phase_ == 1) {
                //text2_ = "azimuth: " + azimut_.toFixed(2) + "  L: " + l.toFixed(2);
            }

            if (this.gisToolData_.phase_ == 2) {
                this.drawTooltip(Math.round(p2[0]), Math.round(p2[1]), this.gisToolData_.text_, null, true);
            }

            break;

        case "distance":

            if (this.gisToolData_.phase_ == 0) {
                break;
            }

            //draw shadow points
            for (var i = 0, li = this.gisToolData_.p.length; i < li; i++) {
                var p1 = this.browser_.project(this.gisToolData_.p[i][0], this.gisToolData_.p[i][1], this.gisToolData_.p[i][2]);
                this.drawPoint(p1[0], p1[1], false, true);
            }

            //draw shadow lines
            for (var i = 0, li = this.gisToolData_.p.length - 1; i < li; i++) {
                var p1 = this.browser_.project(this.gisToolData_.p[i][0], this.gisToolData_.p[i][1], this.gisToolData_.p[i][2]);
                var p2 = this.browser_.project(this.gisToolData_.p[i+1][0], this.gisToolData_.p[i+1][1], this.gisToolData_.p[i+1][2]);

                this.gisCtx_.beginPath();
                this.gisCtx_.moveTo(p1[0], p1[1]);
                this.gisCtx_.lineTo(p2[0], p2[1]);
                this.gisCtx_.lineWidth = lineShadowSize_;
                this.gisCtx_.strokeStyle = lineShadowColor_;
                this.gisCtx_.stroke();
            }

            //draw color points
            for (var i = 0, li = this.gisToolData_.p.length; i < li; i++) {
                var p1 = this.browser_.project(this.gisToolData_.p[i][0], this.gisToolData_.p[i][1], this.gisToolData_.p[i][2]);
                this.drawPoint(p1[0], p1[1], true, false);
            }

            var ll = 0;

            //draw color lines
            for (var i = 0, li = this.gisToolData_.p.length - 1; i < li; i++) {
                var p1 = this.browser_.project(this.gisToolData_.p[i][0], this.gisToolData_.p[i][1], this.gisToolData_.p[i][2]);
                var p2 = this.browser_.project(this.gisToolData_.p[i+1][0], this.gisToolData_.p[i+1][1], this.gisToolData_.p[i+1][2]);

                this.gisCtx_.beginPath();
                this.gisCtx_.moveTo(p1[0], p1[1]);
                this.gisCtx_.lineTo(p2[0], p2[1]);
                this.gisCtx_.lineWidth = 1;
                this.gisCtx_.strokeStyle = lineColor_;
                this.gisCtx_.stroke();

                var dx = this.gisToolData_.p[i+1][0]-this.gisToolData_.p[i][0];
                var dy = this.gisToolData_.p[i+1][1]-this.gisToolData_.p[i][1];
                var dz = this.gisToolData_.p[i+1][2]-this.gisToolData_.p[i][2];

                ll += Math.sqrt(dx*dx + dy*dy + dz*dz);
            }



            var p1 = this.browser_.project(this.gisToolData_.p[li][0], this.gisToolData_.p[li][1], this.gisToolData_.p[li][2]);
            var p2 = p;

            var dx = pos[0]-this.gisToolData_.p[li][0];
            var dy = pos[1]-this.gisToolData_.p[li][1];
            var dz = pos[2]-this.gisToolData_.p[li][2];

            var l = Math.sqrt(dx*dx + dy*dy + dz*dz);
            ll += l;

            var azimut_ = Math.atan2(dx,dy);
            azimut_ = (azimut_ / Math.PI * 180.0);

            if (azimut_ < 0) {
                azimut_ = 360 + azimut_;
            }

            //text2_ = "azimuth: " + azimut_.toFixed(2) + " l"+ li +": " + l.toFixed(2) +  " L: " + ll.toFixed(2);

            if (this.gisToolData_.p.length > 1) {
                this.drawTooltip(Math.round(p1[0]), Math.round(p1[1]), this.gisToolData_.text_, null, true);
            }


            break;
    }

    //draw cross
    if (this.gisShowCusor_ == true && this.ignoreMouse_ != true) {

        var crossSize_ = 40;

        var xx = Math.floor(p[0]);
        var yy = Math.floor(p[1]);

        this.gisCtx_.fillStyle = 'rgba(0,0,0,0.4)';
        this.gisCtx_.fillRect(xx-crossSize_, yy-1, crossSize_*2, 3);
        this.gisCtx_.fillRect(xx-1, yy-crossSize_, 3, crossSize_*2);

        this.gisCtx_.fillStyle = '#ffffff';
        this.gisCtx_.fillRect(xx-crossSize_, yy, crossSize_*2, 1);
        this.gisCtx_.fillRect(xx, yy-crossSize_, 1, crossSize_*2);
    }


    pos2 = proj4_(this.gisProj4String_)["inverse"]([pos[0], pos[1]]);

    var text_ = "";

    if (this.gisDisplayCoords_ == "Projected") {
        text_ = this.getCoordsString(pos[0], pos[1], this.adjustHeight(pos[0], pos[1], pos[2]));
    }

    if (this.gisDisplayCoords_ == "Geographic") {
        text_ = this.getCoordsString(pos2[0], pos2[1], this.adjustHeight(pos[0], pos[1], pos[2]));
    }

    //debug - get heigh from height feild
    //var hh = this.browser_.getTerrainHeight(pos[0], pos[1]);
    //text_ += "  " + hh[0].toFixed(1);

    this.drawTooltip(xx+20, yy+17, text_, text2_ != "" ? text2_ : null);

};


Vadstena.Interface.prototype.gisMouseMove = function() {

    if (this.mouseLeftDown_ == true) {
        this.gisIgnoreMouseUp_ = true;
    }

    this.gisUpdate();
};


Vadstena.Interface.prototype.gisMouseLeftDown = function() {
    this.gisUpdate();
};


Vadstena.Interface.prototype.gisMouseLeftUp = function() {

    if (this.gisShowCusor_ == false && this.ignoreMouse_ != true) {
        return;
    }

    //document.getElementById("vadstena-engine-debug-text").innerHTML += ".i.";

    var pos = this.gisCurrentPos_;
    //var pos2 = proj4(gisProj4String_).inverse([pos[0], pos[1]]);
    var pos2 = proj4_(this.gisProj4String_)["inverse"]([pos[0], pos[1]]);

    var text_ = "";

    switch(this.gisDisplayCoords_) {
        case "Projected":   text_ = this.getCoordsString(pos[0], pos[1], this.adjustHeight(pos[0], pos[1], pos[2])); break;
        case "Geographic": text_ = this.getCoordsString(pos2[0], pos2[1], this.adjustHeight(pos[0], pos[1], pos[2])); break;
    }

    switch(this.gisCurrentTool_) {
        case "position":

            if (this.gisIgnoreMouseUp_ != true) {
                this.gisToolData_.first_ = false;
                this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "\nPosition:\n" + text_ + "\n");
                this.gisToolData_.p1 = pos.slice();
                this.gisToolData_.text_ = text_;
            }

            break;


        case "length":

            if (this.gisIgnoreMouseUp_ != true) {

                this.gisToolData_.first_ = false;

                if (this.gisToolData_.phase_ == 0 || this.gisToolData_.phase_ == 2) {

                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "\nDistance:\np1: " + text_ + "\n");
                    this.gisToolData_.phase_ = 1;

                    this.gisToolData_.p1 = pos.slice();
                    this.gisToolData_.p2 = pos.slice();

                } else if(this.gisToolData_.phase_ == 1) {

                    this.gisToolData_.p2 = pos.slice();

                    var dx = this.gisToolData_.p2[0]-this.gisToolData_.p1[0];
                    var dy = this.gisToolData_.p2[1]-this.gisToolData_.p1[1];
                    var dz = this.gisToolData_.p2[2]-this.gisToolData_.p1[2];

                    var l = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    var azimut_ = Math.atan2(dx,dy);
                    azimut_ = (azimut_ / Math.PI * 180.0);

                    if (azimut_ < 0) {
                        azimut_ = 360 + azimut_;
                    }

                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "p2: " + text_ + "\n");
                    //document.getElementById("gisPanelTexts").value += "L = " + l.toFixed(2) + "m\n";
                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "    dx: " + this.getDistanceString(Math.abs(dx)) + " dy: " + this.getDistanceString(Math.abs(dy)) + " dz: " + this.getDistanceString(Math.abs(dz)) + "\n");
                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "    L: " + this.getDistanceString(l) + " azimuth: " + azimut_.toFixed(2) + "\xB0\n");

                    this.gisToolData_.text_ = "L: " + this.getDistanceString(l) + " azimuth: " + azimut_.toFixed(2) + "\xB0";
                    this.gisToolData_.phase_ = 2;
                }
            }

            break;

        case "distance":

            if (this.gisIgnoreMouseUp_ != true) {

                if (this.gisToolData_.phase_ == 0) {

                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "\nTrack\np1: " + text_ + "\n");
                    this.gisToolData_.phase_++;

                    this.gisToolData_.p = [];
                    this.gisToolData_.p.push(pos.slice());

                } else {

                    this.gisToolData_.p.push(pos.slice());

                    var li = this.gisToolData_.p.length - 1;

                    var l = 0;
                    var ll = 0;

                    for (var i = 0; i < li; i++) {

                        var dx = this.gisToolData_.p[i+1][0]-this.gisToolData_.p[i][0];
                        var dy = this.gisToolData_.p[i+1][1]-this.gisToolData_.p[i][1];
                        var dz = this.gisToolData_.p[i+1][2]-this.gisToolData_.p[i][2];

                        var azimut_ = Math.atan2(dx,dy);
                        azimut_ = (azimut_ / Math.PI * 180.0);

                        if (azimut_ < 0) {
                            azimut_ = 360 + azimut_;
                        }

                        l = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        ll += Math.sqrt(dx*dx + dy*dy + dz*dz);
                    }

                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "p"+ li +": " + text_ + "\n");
                    this.addToElementProperty("vadstena-engine-gis-panel-texts", "value", "    azimuth: " + azimut_.toFixed(2) + "\n    L:= " + this.getDistanceString(ll) + " l"+ li +": " + this.getDistanceString(l) + "\n");

                    this.gisToolData_.text_ = "L: " + this.getDistanceString(ll);

                }

                this.updatePanel();
            }

            break;
    }

    //scroll to new line
    var obj_ = document.getElementById("vadstena-engine-gis-panel-texts");

    if (obj_ != null) {
        var currentScrollHeight = obj_.scrollHeight;
        obj_.scrollTop = (obj_.scrollTop + 100000); //set the scroll height to scroll by here.
    }

    this.gisIgnoreMouseUp_ = false;

    this.gisUpdate();

};

Vadstena.Interface.prototype.gisKeyUp = function(keyCode_) {

    //console.log("key" + keyCode_);

    switch (keyCode_) {

    case 27: //ESC KEY

        switch(this.gisCurrentTool_) {

            case "length":
                this.gisToolData_.phase_ = 0;
                break;

            case "distance":

                this.newDistancePressed();
                break;
        }

        break;


    case 8: //BACSPACE KEY

        switch(this.gisCurrentTool_) {

            case "length":
                this.gisToolData_.phase_ = 0;
                break;

            case "distance":
                this.removeLastPressed();
                break;
        }


        break;

    }
};

Vadstena.Interface.prototype.getLonLat = function(utmPos_) {
    return proj4_(this.gisProj4String_)["inverse"]([utmPos_[0], utmPos_[1]]);
};

//prevet minification
var proj4_ = window["proj4"];
Vadstena.Interface.prototype["getLonLat"] = Vadstena.Interface.prototype.getLonLat;



/*
"+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84"
cat /mnt/vadstena/input/seznam.cz-praha/1_old_town/old_town.prj

TODO: better depth map resolution
 */

//LINK PANEL
Vadstena.Interface.prototype.placesMouseMove = function() {
    var places_ = this.layerPlaces_;

    var hoverElement_ = document.getElementById("vadstena-engine-place-hover");

    if (hoverElement_ == null) {
        return;
    }

    var hit_ = -1;
    var hitDepth_ = 9999;
    for (var i = 0, li = places_.length; i < li; i++) {
        var place_ = places_[i];
        var rect_ = place_["rect"];

        if (this.mouseX_ >= rect_[0] && this.mouseX_ <= rect_[2] &&
            this.mouseY_ >= rect_[1] && this.mouseY_ <= rect_[3] &&
            hitDepth_ > place_["pos"][2]) {
            hit_ = i;
            hitDepth_ = place_["pos"][2];
        }
    }

    if (hit_ != -1) {

        var place_ = places_[hit_];
        var rect_ = place_["rect"];

        hoverElement_.style.display = "block";
        hoverElement_.style.left = Math.round(rect_[0]) + "px";
        hoverElement_.style.top = Math.round(rect_[1]) + "px";
        hoverElement_.style.width = Math.round(rect_[2]-rect_[0]) + "px";
        hoverElement_.style.height = Math.round(rect_[1]-rect_[3]) + "px";

        this.hoverPlace_ = place_;
    } else {
        this.hoverPlace_ = null;
        hoverElement_.style.display = "none";
    }

};

Vadstena.Interface.prototype.placesMouseWheel = function(place_) {
    this.hidePlacePanel();
};

Vadstena.Interface.prototype.placesMouseRightDown = function(place_) {
    this.hidePlacePanel();
};

Vadstena.Interface.prototype.placesMouseLeftDown = function(place_) {
    this.hidePlacePanel();
};

Vadstena.Interface.prototype.placesMouseLeftUp = function(place_) {
    if (this.hoverPlace_ != null) {
        this.showPlacePanel(this.hoverPlace_);
    } else {
        this.hidePlacePanel();
    }
};


Vadstena.Interface.prototype.showPlacePanel = function(place_) {
    var panelElement_ = document.getElementById("vadstena-engine-place-panel");

    if (panelElement_ == null || place_ == null) {
        return;
    }

    panelElement_.style.display = "block";
    panelElement_.innerHTML = place_["html"];

    var pos_ = place_["pos"];

    var x = Math.round(pos_[0]);
    var y = Math.round(pos_[1]);

    var width_ = panelElement_.offsetWidth;
    var height_ = panelElement_.offsetHeight;

    var positions_ = [[x+20, y-20],
                      [x-20-width_, y-20],
                      [x+20, y-height_],
                      [x-20-width_, y-height_],
                      [x-20, y+5],
                      [x-20, y-height_-25],
                      [x-Math.round(width_*0.5), y+5],
                      [x-Math.round(width_*0.5), y-height_-25],
                      [10, 30]
                      ];

    for (var i = 0, li = positions_.length; i < li; i++) {
        if (this.checkPlacePanelPosition(positions_[i][0], positions_[i][1], width_, height_) == true){
            x = positions_[i][0];
            y = positions_[i][1];
            break;
        }
    }

    panelElement_.style.left = x + "px";
    panelElement_.style.top = y + "px";

    this.placePanelVisible_ = true;

//    placeElement_.style.width = Math.round(rect_[2]-rect_[0]) + "px";
//    placeElement_.style.height = Math.round(rect_[1]-rect_[3]) + "px";

};

Vadstena.Interface.prototype.checkPlacePanelPosition = function(x, y, width_, height_) {

    var element_ = document.getElementById("vadstena-engine");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();

        if (x < 0 || y < 20 || (x+width_) > rect_.width || (y+height_) > rect_.height) {
            return false;
        }
    }

    //info panel
    element_ = document.getElementById("vadstena-engine-info-panel");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();

        if (!(x > rect_.right || (x+width_) < rect_.left ||
            y > rect_.bottom || (y+height_) < rect_.top)) {
                return false;
        }
    }

    //navigation controls
    element_ = document.getElementById("vadstena-engine-compass-main");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();

        if (!(x > rect_.right || (x+width_) < rect_.left ||
            y > (rect_.bottom+55) || (y+height_) < rect_.top)) {
                return false;
        }
    }

    //toolbar panel
    element_ = document.getElementById("vadstena-engine-toolbar-bottons");

    if (element_ != null) {
        var rect_ = element_.getBoundingClientRect();

        if (!(x > rect_.right || (x+width_) < rect_.left ||
            y > rect_.bottom || (y+height_) < rect_.top)) {
                return false;
        }
    }

    return true;
};

Vadstena.Interface.prototype.hidePlacePanel = function() {
    if (this.placePanelVisible_ == false) {
        return;
    }

    var panelElement_ = document.getElementById("vadstena-engine-place-panel");

    if (panelElement_ == null ) {
        return;
    }

    panelElement_.style.display = "none";
    this.placePanelVisible_ = false;
};


Vadstena.Interface.prototype.showStatsGraphsPanel = function() {
    this.statsGraphsVisible_ = true;
    this.browser_.setOption("recordStats", true);
    this.setElementStyle("vadstena-engine-stats-graphs", "display", "block");
};

Vadstena.Interface.prototype.hideStatsGraphsPanel = function() {
    this.statsGraphsVisible_ = false;
    this.setElementStyle("vadstena-engine-stats-graphs", "display", "none");
};

Vadstena.Interface.prototype.switchStatsGraphsPanel = function() {
    if (this.statsGraphsVisible_ == true) {
        this.hideStatsGraphsPanel();
    } else {
        this.showStatsGraphsPanel();
    }
};

Vadstena.Interface.prototype.statsRecordingPressed = function() {
    if (this.browser_ == null) {
        return;
    }

    this.browser_.setOption("recordStats", !this.browser_.getOption("recordStats"));

    this.updateStatsGraphsPanel();
};

Vadstena.Interface.prototype.statsRefreshPressed = function() {

    this.statsRefresh_ = !this.statsRefresh_;

    this.updateStatsGraphsPanel();
    this.updateStatsGraphs();
};

Vadstena.Interface.prototype.statsResetPressed = function() {
    if (this.browser_ == null) {
        return;
    }

    var stats_ = this.browser_.getData("statsSamples");

    var samples_ = stats_["samples"];
    var valuesFrame_ = stats_["frame"];
    var valuesRender_ = stats_["render"];
    var valuesTextures_ = stats_["textures"];
    var valuesMeshes_ = stats_["meshes"];
    var valuesGpuMeshes_ = stats_["gpumeshes"];
    var valuesTotal_ = stats_["cache"];
    var valuesUsed_ = stats_["cache-used"];
    var valuesMemTextures_ = stats_["cache-textures"];
    var valuesMemMeshes_ = stats_["cache-meshes"];
    var valuesPolygons_ = stats_["polygons"];
    var valuesLODs_ = stats_["lods"];
    var valuesFluxTextures_ = stats_["flux-textures"];
    var valuesFluxMeshes_ = stats_["flux-meshes"];

    for (var i = 0; i < samples_; i++) {
        valuesFrame_[i] = 0;
        valuesRender_[i] = 0;
        valuesTextures_[i] = 0;
        valuesMeshes_[i] = 0;
        valuesGpuMeshes_[i] = 0;
        valuesTotal_[i] = 0;
        valuesUsed_[i] = 0;
        valuesMemTextures_[i] = 0;
        valuesMemMeshes_[i] = 0;
        valuesPolygons_ = 0;
        valuesLODs_ = [0,[]];
        valuesFluxTextures_[i] = [[0,0],[0,0]];
        valuesFluxMeshes_[i] = [[0,0],[0,0]];
    }
};

Vadstena.Interface.prototype.statsZoomPressed = function() {

    switch (this.statsZoom_) {
        case "max":     this.statsZoom_ = "120avrg"; break;
        case "120avrg": this.statsZoom_ = "180avrg"; break;
        case "180avrg": this.statsZoom_ = "max"; break;
    }

    this.updateStatsGraphsPanel();
    this.updateStatsGraphs();
};

Vadstena.Interface.prototype.statsGraphPressed = function() {

    switch (this.statsGraph_) {
        case "Cache":     this.statsGraph_ = "Polygons"; break;
        case "Polygons":  this.statsGraph_ = "LODs"; break;
        case "LODs":      this.statsGraph_ = "Flux"; break;
        case "Flux":      this.statsGraph_ = "Cache"; break;
    }

    this.updateStatsGraphsPanel();
    this.updateStatsGraphs();
};


Vadstena.Interface.prototype.statsMagnifyPressed = function() {

    this.statsMagnify_ = !this.statsMagnify_;

    if (this.statsMagnify_ == true) {
        this.setElementStyle("vadstena-engine-stats-render", "width", "900px");
        this.setElementStyle("vadstena-engine-stats-render", "height", "150px");
        this.setElementStyle("vadstena-engine-stats-cache", "width", "900px");
        this.setElementStyle("vadstena-engine-stats-cache", "height", "150px");
        this.setElementProperty("vadstena-engine-stats-magnify", "innerHTML", "Magnify On");
    } else {
        this.setElementStyle("vadstena-engine-stats-render", "width", "500px");
        this.setElementStyle("vadstena-engine-stats-render", "height", "100px");
        this.setElementStyle("vadstena-engine-stats-cache", "width", "500px");
        this.setElementStyle("vadstena-engine-stats-cache", "height", "100px");
        this.setElementProperty("vadstena-engine-stats-magnify", "innerHTML", "Magnify Off");
    }

    this.updateStatsGraphsPanel();
    this.updateStatsGraphs();
};

Vadstena.Interface.prototype.updateStatsGraphsPanel = function() {

    if (this.browser_.getOption("recordStats") == true) {
        this.setElementProperty("vadstena-engine-stats-rec", "innerHTML", "Recording On");
    } else {
        this.setElementProperty("vadstena-engine-stats-rec", "innerHTML", "Recording Off");
    }

    if (this.statsRefresh_ == true) {
        this.setElementProperty("vadstena-engine-stats-ref", "innerHTML", "Refresh On");
    } else {
        this.setElementProperty("vadstena-engine-stats-ref", "innerHTML", "Refresh Off");
    }

    switch (this.statsZoom_) {
        case "max":
            this.setElementProperty("vadstena-engine-stats-zoom", "innerHTML", "Scale: Max value");
            break;

        case "120avrg":
            this.setElementProperty("vadstena-engine-stats-zoom", "innerHTML", "Scale: 100% Avrg");
            break;

        case "180avrg":
            this.setElementProperty("vadstena-engine-stats-zoom", "innerHTML", "Scale: 50% Avrg");
            break;
    }

    this.setElementProperty("vadstena-engine-stats-graph", "innerHTML", "Graph: " + this.statsGraph_);
};

Vadstena.Interface.prototype.onStatsMouseMove = function(event_) {

    var x = event_.clientX;
    this.statsShowCursor_ = true;

    if (this.statsCanvasRender_ != null) {
        x -= this.statsCanvasRender_.getBoundingClientRect().left;
    }

    if (this.statsMagnify_ == true) {
        x = Math.floor(x * 500/900);
    }

    this.statsCursorIndex_ = x;

    if (this.browser_.getOption("recordStats") != true) {
        this.updateStatsGraphs();
    }

};

Vadstena.Interface.prototype.onStatsMouseOut = function() {
    this.statsShowCursor_ = false;
    this.updateStatsGraphs();
};


Vadstena.Interface.prototype.updateStatsGraphs = function() {

    if (this.browser_ == null || this.statsRefresh_ == false || this.statsGraphsVisible_ == false) {
        return;
    }

    if (this.statsCanvasRender_ == null) {
        this.statsCanvasRender_ = document.getElementById("vadstena-engine-stats-render");
    }

    var stats_ = this.browser_.getData("statsSamples");


    if (this.statsCanvasRender_ != null) {

        if (this.statsCanvasRenderCtx_ == null) {
            this.statsCanvasRenderCtx_ = this.statsCanvasRender_.getContext("2d");
        }

        var width_ = this.statsCanvasRender_.width;
        var height_ = this.statsCanvasRender_.height;
        var ctx_ = this.statsCanvasRenderCtx_;

        var samples_ = stats_["samples"];
        var samplesIndex_ = stats_["index"];

        var factorX_ = width_ / samples_;

        ctx_.clearRect(0, 0, width_, height_);

        var maxValue_ = 0;
        var totalFrame_ = 0;
        var totalRender_ = 0;
        var totalTexture_ = 0;
        var totalMeshes_ = 0;
        var totalGpuMeshes_ = 0;
        var realCount_ = 0;

        var valuesFrame_ = stats_["frame"];
        var valuesRender_ = stats_["render"];
        var valuesTextures_ = stats_["textures"];
        var valuesMeshes_ = stats_["meshes"];
        var valuesGpuMeshes_ = stats_["gpumeshes"];

        for (var i = 0; i < samples_; i++) {
            totalFrame_ += valuesFrame_[i];
            totalRender_ += valuesRender_[i];
            totalTexture_ += valuesTextures_[i];
            totalMeshes_ += valuesMeshes_[i];
            totalGpuMeshes_ += valuesGpuMeshes_[i];

            var v = valuesFrame_[i];

            if (v > maxValue_) {
                maxValue_ = v;
            }

            if (v > 0) {
                realCount_++;
            }
        }

        if (this.statsZoom_ == "120avrg") {
            maxValue_ = (totalFrame_ / realCount_) * 1.0;
        }

        if (this.statsZoom_ == "180avrg") {
            maxValue_ = (totalFrame_ / realCount_) * 0.5;
        }

        var factorY_ = height_ / maxValue_;

        for (var i = 0; i < samples_; i++) {
            var index_ = samplesIndex_ + i;
            index_ %= samples_;

            ctx_.fillStyle="#000000";
            ctx_.fillRect(i*factorX_, height_, 1, -(valuesFrame_[index_])*factorY_);
            ctx_.fillStyle="#ff0000";
            ctx_.fillRect(i*factorX_, height_, 1, -(valuesRender_[index_])*factorY_);

            ctx_.fillStyle="#0000ff";
            ctx_.fillRect(i*factorX_, height_, 1, -(valuesTextures_[index_])*factorY_);

            var y = height_ -(valuesTextures_[index_])*factorY_;

            ctx_.fillStyle="#007700";
            ctx_.fillRect(i*factorX_, y, 1, -(valuesMeshes_[index_])*factorY_);

            y -= (valuesMeshes_[index_])*factorY_;

            ctx_.fillStyle="#00ff00";
            ctx_.fillRect(i*factorX_, y, 1, -(valuesGpuMeshes_[index_])*factorY_);

        }

        if (this.statsShowCursor_ == true) {
            ctx_.fillStyle="#aa00aa";
            var index_ = (this.statsCursorIndex_) % samples_;
            ctx_.fillRect(Math.floor(index_*factorX_)-1, 0, 1, height_);
            ctx_.fillRect(Math.floor(index_*factorX_)+1, 0, 1, height_);
            index_ = (this.statsCursorIndex_ + samplesIndex_) % samples_;

            var str_ = '&FilledSmallSquare; Frame: ' + valuesFrame_[index_].toFixed(2) +
                       ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + valuesRender_[index_].toFixed(2) +
                       ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + valuesTextures_[index_].toFixed(2) +
                       ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + valuesMeshes_[index_].toFixed(2) +
                       ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + valuesGpuMeshes_[index_].toFixed(2) + '</div>';
        } else {
            var str_ = '&FilledSmallSquare; Frame: ' + Math.round(totalFrame_) +
                       ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + Math.round(totalRender_) +
                       ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + Math.round(totalTexture_) +
                       ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + Math.round(totalMeshes_) +
                       ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + Math.round(totalGpuMeshes_) +'</div>';
        }

        this.setElementProperty("vadstena-engine-stats-info", "innerHTML", str_);

    }

   if (this.statsCanvasCache_ == null) {
        this.statsCanvasCache_ = document.getElementById("vadstena-engine-stats-cache");
    }


    if (this.statsCanvasCache_ != null) {

        if (this.statsCanvasCacheCtx_ == null) {
            this.statsCanvasCacheCtx_ = this.statsCanvasCache_.getContext("2d");
        }

        var width_ = this.statsCanvasCache_.width;
        var height_ = this.statsCanvasCache_.height;
        var ctx_ = this.statsCanvasCacheCtx_;

        var samples_ = stats_["samples"];
        var samplesIndex_ = stats_["index"];

        var factorX_ = width_ / samples_;

        ctx_.clearRect(0, 0, width_, height_);

        switch (this.statsGraph_) {
        case "Cache":
            {
                var factorY_ = height_ / (stats_["cache-size"]/1024/1024);

                var maxTotal_ = 0;
                var maxUsed_ = 0;
                var maxTextures_ = 0;
                var maxMeshes_ = 0;

                var valuesTotal_ = stats_["cache"];
                var valuesUsed_ = stats_["cache-used"];
                var valuesTextures_ = stats_["cache-textures"];
                var valuesMeshes_ = stats_["cache-meshes"];

                for (var i = 0; i < samples_; i++) {
                    maxTotal_ = valuesTotal_[i] > maxTotal_ ? valuesTotal_[i] : maxTotal_;
                    maxUsed_ = valuesUsed_[i] > maxUsed_ ? valuesUsed_[i] : maxUsed_;
                    maxTextures_ = valuesTextures_[i] > maxTextures_ ? valuesTextures_[i] : maxTextures_;
                    maxMeshes_ = valuesMeshes_[i] > maxMeshes_ ? valuesMeshes_[i] : maxMeshes_;
                }

                for (var i = 0; i < samples_; i++) {
                    var index_ = samplesIndex_ + i;
                    index_ %= samples_;

                    ctx_.fillStyle="#000000";
                    ctx_.fillRect(i*factorX_, height_, 1, -(valuesTotal_[index_])*factorY_);
                    ctx_.fillStyle="#ff0000";
                    ctx_.fillRect(i*factorX_, height_, 1, -(valuesUsed_[index_])*factorY_);
                    ctx_.fillStyle="#0000ff";
                    ctx_.fillRect(i*factorX_, height_, 1, -(valuesTextures_[index_])*factorY_);
                    ctx_.fillStyle="#00bb00";
                    ctx_.fillRect(i*factorX_, height_, 1, -(valuesMeshes_[index_])*factorY_);
                }

                if (this.statsShowCursor_ == true) {
                    var index_ = (this.statsCursorIndex_ + samplesIndex_) % samples_;
                    var str_ = '&FilledSmallSquare; Cache: ' + Math.round(valuesTotal_[index_]) +
                               ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Used: ' + Math.round(valuesUsed_[index_]) +
                               ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + Math.round(valuesTextures_[index_]) +
                               ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + Math.round(valuesMeshes_[index_]) +'</div>';
                } else {
                    var str_ = '&FilledSmallSquare; Cache: ' + Math.round(maxTotal_) +
                               ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Used: ' + Math.round(maxUsed_) +
                               ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + Math.round(maxTextures_) +
                               ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + Math.round(maxMeshes_) +'</div>';
                }

            }
            break;


        case "Polygons":
            {
                var max_ = 0;
                var min_ = 99999999999;
                var total_ = 0;
                var realCount_ = 0;
                var values_ = stats_["polygons"];

                for (var i = 0; i < samples_; i++) {
                    max_ = values_[i] > max_ ? values_[i] : max_;

                    if (values_[i] > 0) {
                        min_ = values_[i] < min_ ? values_[i] : min_;
                        total_ += values_[i];
                        realCount_++;
                    }
                }

                var factorY_ = height_ / max_;

                for (var i = 0; i < samples_; i++) {
                    var index_ = samplesIndex_ + i;
                    index_ %= samples_;

                    ctx_.fillStyle="#007700";
                    ctx_.fillRect(i*factorX_, height_, 1, -(values_[index_])*factorY_);
                }

                if (this.statsShowCursor_ == true) {
                    var index_ = (this.statsCursorIndex_ + samplesIndex_) % samples_;
                    var str_ = '<span style="color:#007700">&FilledSmallSquare;</span> Polygons: ' + Math.round(values_[index_]) +'</div>';
                } else {
                    var str_ = '<span style="color:#007700">&FilledSmallSquare;</span> Polygons Max: ' + max_ +'</div>';
                    str_ += ' &nbsp Min: ' + min_;
                    str_ += ' &nbsp Avrg: ' + Math.round(total_ / realCount_) +'</div>';
                }
            }
            break;

        case "LODs":
            {
                var max_ = 0;
                var values_ = stats_["lods"];

                for (var i = 0; i < samples_; i++) {
                    max_ = values_[i][0] > max_ ? values_[i][0] : max_;
                }

                var factorY_ = height_ / max_;

                ctx_.fillStyle="#000000";
                ctx_.fillRect(0, 0, width_, height_);

                for (var i = 0; i < samples_; i++) {
                    var index_ = samplesIndex_ + i;
                    index_ %= samples_;

                    //ctx_.fillStyle="#000000";
                    //ctx_.fillRect(i*factorX_, height_, 1, -(values_[index_][0])*factorY_);

                    var y = height_;

                    for (var j in values_[index_][1]) {
                        ctx_.fillStyle="hsl("+((j*23)%360)+",100%,50%)";
                        var value_ = Math.round((values_[index_][1][j])*factorY_);
                        ctx_.fillRect(i*factorX_, y, 1, -value_);
                        y -= value_;
                    }

                }

                if (this.statsShowCursor_ == true) {
                    var index_ = (this.statsCursorIndex_ + samplesIndex_) % samples_;

                    var str_ = "LODs:" + values_[index_][0];

                    for (var j in values_[index_][1]) {
                        str_ += '<span style="color:hsl('+((j*23)%360)+',100%,50%)">&FilledSmallSquare;</span>'+j+':'+values_[index_][1][j];
                    }

                } else {
                    var str_ = "LODs:" + values_[index_][0];
                }

                str_ += '</div>';
            }
            break;

        case "Flux":
            {
                var maxCount_ = 0;
                var maxSize_ = 0;

                var maxTexPlusCount_ = 0;
                var maxTexPlusSize_ = 0;
                var maxTexMinusCount_ = 0;
                var maxTexMinusSize_ = 0;

                var maxMeshPlusCount_ = 0;
                var maxMeshPlusSize_ = 0;
                var maxMeshMinusCount_ = 0;
                var maxMeshMinusSize_ = 0;

                var valuesTextures_ = stats_["flux-textures"];
                var valuesMeshes_ = stats_["flux-meshes"];

                for (var i = 0; i < samples_; i++) {
                    var tmp_ = valuesTextures_[i][0][0] + valuesMeshes_[i][0][0];
                    maxCount_ = tmp_ > maxCount_ ? tmp_ : maxCount_;
                    tmp_ = valuesTextures_[i][1][0] + valuesMeshes_[i][1][0];
                    maxCount_ = tmp_ > maxCount_ ? tmp_ : maxCount_;

                    tmp_ = valuesTextures_[i][0][1] + valuesMeshes_[i][0][1];
                    maxSize_ = tmp_ > maxSize_ ? tmp_ : maxSize_;
                    tmp_ = valuesTextures_[i][1][1] + valuesMeshes_[i][1][1];
                    maxSize_ = tmp_ > maxSize_ ? tmp_ : maxSize_;

                    maxTexPlusCount_ = valuesTextures_[i][0][0] > maxTexPlusCount_ ? valuesTextures_[i][0][0] : maxTexPlusCount_;
                    maxTexPlusSize_ = valuesTextures_[i][0][1] > maxTexPlusSize_ ? valuesTextures_[i][0][1] : maxTexPlusSize_;
                    maxTexMinusCount_ = valuesTextures_[i][1][0] > maxTexMinusCount_ ? valuesTextures_[i][1][0] : maxTexMinusCount_;
                    maxTexMinusSize_ = valuesTextures_[i][1][1] ? valuesTextures_[i][1][1] : maxTexMinusSize_;

                    maxMeshPlusCount_ = valuesMeshes_[i][0][0] > maxMeshPlusCount_ ? valuesMeshes_[i][0][0] : maxMeshPlusCount_;
                    maxMeshPlusSize_ = valuesMeshes_[i][0][1] > maxMeshPlusSize_ ? valuesMeshes_[i][0][1] : maxMeshPlusSize_;
                    maxMeshMinusCount_ = valuesMeshes_[i][1][0] > maxMeshMinusCount_ ? valuesMeshes_[i][1][0] : maxMeshMinusCount_;
                    maxMeshMinusSize_ = valuesMeshes_[i][1][1] > maxMeshMinusSize_ ? valuesMeshes_[i][1][1] : maxMeshMinusSize_;
                }

                var factorY_ = (height_*0.25-2) / maxCount_;
                var factorY2_ = (height_*0.25-2) / maxSize_;

                var base_ = Math.floor(height_*0.25);
                var base2_ = Math.floor(height_*0.75);

                for (var i = 0; i < samples_; i++) {
                    var index_ = samplesIndex_ + i;
                    index_ %= samples_;

                    ctx_.fillStyle="#0000aa";
                    ctx_.fillRect(i*factorX_, base_, 1, -(valuesTextures_[index_][0][0])*factorY_);
                    ctx_.fillRect(i*factorX_, base_+1, 1, (valuesTextures_[index_][1][0])*factorY_);

                    ctx_.fillRect(i*factorX_, base2_, 1, -(valuesTextures_[index_][0][1])*factorY2_);
                    ctx_.fillRect(i*factorX_, base2_+1, 1, (valuesTextures_[index_][1][1])*factorY2_);

                    ctx_.fillStyle="#007700";

                    ctx_.fillRect(i*factorX_, base_-(valuesTextures_[index_][0][0])*factorY_, 1, -(valuesMeshes_[index_][0][0])*factorY_);
                    ctx_.fillRect(i*factorX_, base_+1+(valuesTextures_[index_][1][0])*factorY_, 1, (valuesMeshes_[index_][1][0])*factorY_);

                    ctx_.fillRect(i*factorX_, base2_-(valuesTextures_[index_][0][1])*factorY2_, 1, -(valuesMeshes_[index_][0][1])*factorY2_);
                    ctx_.fillRect(i*factorX_, base2_+1+(valuesTextures_[index_][1][0])*factorY2_, 1, (valuesMeshes_[index_][1][1])*factorY2_);

                    ctx_.fillStyle="#aaaaaa";
                    ctx_.fillRect(0, Math.floor(height_*0.5), width_, 1);
                    ctx_.fillStyle="#dddddd";
                    ctx_.fillRect(0, base_, width_, 1);
                    ctx_.fillRect(0, base2_, width_, 1);
                }


                if (this.statsShowCursor_ == true) {
                    var index_ = (this.statsCursorIndex_ + samplesIndex_) % samples_;
                    var str_ = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + valuesTextures_[index_][0][0] + "/" + valuesTextures_[index_][1][0];
                    str_ += ' &nbsp Size +/-: ' + (valuesTextures_[index_][0][1]/1024/1024).toFixed(2) + "/" + (valuesTextures_[index_][1][1]/1024/1024).toFixed(2);
                    str_ += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + valuesMeshes_[index_][0][0] + "/" + valuesMeshes_[index_][1][0];
                    str_ += ' &nbsp Size +/-: ' + (valuesMeshes_[index_][0][1]/1024/1024).toFixed(2) + "/" + (valuesMeshes_[index_][1][1]/1024/1024).toFixed(2);
                    str_ += '</div>';
                } else {
                    var str_ = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + maxTexPlusCount_ + "/" + maxTexMinusCount_;
                    str_ += ' &nbsp Size +/-: ' + (maxTexPlusSize_/1024/1024).toFixed(2) + "/" + (maxTexMinusSize_/1024/1024).toFixed(2);
                    str_ += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + maxMeshPlusCount_ + "/" + maxMeshMinusCount_;
                    str_ += ' &nbsp Size +/-: ' + (maxMeshPlusSize_/1024/1024).toFixed(2) + "/" + (maxMeshMinusSize_/1024/1024).toFixed(2);
                    str_ += '</div>';
                }

            }
            break;

        }

        if (this.statsShowCursor_ == true) {
            ctx_.fillStyle="#aa00aa";
            var index_ = (this.statsCursorIndex_) % samples_;
            ctx_.fillRect(Math.floor(index_*factorX_)-1, 0, 1, height_);
            ctx_.fillRect(Math.floor(index_*factorX_)+1, 0, 1, height_);
        }

        this.setElementProperty("vadstena-engine-stats-info2", "innerHTML", str_);

    }

};

Vadstena.Interface.prototype.initWS = function(group_) {
    this.wsConnected_ = false;
    this.wsConnection_ = new WebSocket(decodeURIComponent(group_), ['soap', 'xmpp']);
    this.wsConnection_.onopen = this.onWSOpen.bind(this);
    this.wsConnection_.onerror = this.onWSError.bind(this);
    this.wsConnection_.onmessage = this.onWSMessage.bind(this);
    this.wsLastMessage_ = "";
};


Vadstena.Interface.prototype.onWSOpen = function() {
    //this.sendWS("test");
    this.wsConnected_ = true;
};


Vadstena.Interface.prototype.onWSError = function(error_) {
};


Vadstena.Interface.prototype.onWSMessage = function(event_) {
    var msg_ = event_.data;
    this.processWSCoords(msg_);
};


Vadstena.Interface.prototype.sendWS = function(message_) {
    if (this.wsConnection_ == null && this.wsConnected_ == true) {
        return;
    }

    this.wsConnection_.send(message_);
};

Vadstena.Interface.prototype.sendWSCoords = function() {
    if (this.browser_ == null || this.wsConnection_ == null) {
        return;
    }

    var pos_ = this.browser_.getPosition();
    var rot_ = this.browser_.getOrientation();
    var heightOffset_ = this.browser_.getOption("cameraHeightOffset");
    heightOffset_ = (heightOffset_ != null) ? heightOffset_ : 0;

    var msg_ = "" + pos_[0].toFixed(3) + " " + pos_[1].toFixed(3) + " " + pos_[2].toFixed(3) + " " + rot_[0].toFixed(4) + " " + rot_[1].toFixed(4) + " 0 " + heightOffset_.toFixed(3);

    if (msg_ != this.wsLastMessage_) {
        this.wsLastMessage_ = msg_;
        this.sendWS(msg_);
    }

    //this.engine_.setAutorotate(0);
};

Vadstena.Interface.prototype.processWSCoords = function(message_) {
    if (this.browser_ == null || message_ == null || message_ == "" || this.wsConnection_ == null) {
        return;
    }

    var coords_ = message_.split(" ");

    var pos_ = this.browser_.getPosition();
    var rot_ = this.browser_.getOrientation();
    var heightOffset_ = this.browser_.getOption("cameraHeightOffset");

    if (coords_[0] != null){ pos_[0] = parseFloat(coords_[0]); }
    if (coords_[1] != null){ pos_[1] = parseFloat(coords_[1]); }
    if (coords_[2] != null){ pos_[2] = parseFloat(coords_[2]); }

    if (coords_[3] != null){ rot_[0] = parseFloat(coords_[3]); }
    if (coords_[4] != null){ rot_[1] = parseFloat(coords_[4]); }
    if (coords_[5] != null){  } //skip

    if (coords_[6] != null){ heightOffset_ = parseFloat(coords_[6]); }

    this.browser_.setPosition(pos_[0], pos_[1], pos_[2]);
    this.browser_.setOrientation(rot_[0], rot_[1], rot_[2]);
    this.browser_.setOption("cameraHeightOffset", heightOffset_);

    this.engine_.setAutorotate(0);
};

/**
 * @constructor
 */
Vadstena.KmlLoader = function(id_, engine_, path_, onLoaded_, onUpdate_)
{
    this.id_ = id_;
    this.engine_ = engine_;
    this.path_ = path_;
    this.onLoaded_ = onLoaded_;
    this.onUpdate_ = onUpdate_;
    this.xml_ = null;
    this.layer_ = [];

    this.defaultStyle_ = {
        lineStyle_ : {
            color_ :  [255,255,255,255],
            colorMode_ :  "normal",
            width_ :  1.0
        },

        polyStyle_ : {
            color_ :  [255,255,255,255],
            colorMode_ :  "normal",
            fill_ :  true,
            outline_ :  true
        },

        iconStyle_ : {
            icon_ :  "default",
            color_ :  [255,255,255,255],
            colorMode_ :  "normal",
            scale_ :  1,
            x_ :  0.5,
            y_ :  0,
            xunits_ :  "fraction",
            yunits_ :  "fraction"
        },

        labelStyle_ : {
            color_ :  [255,255,255,255],
            colorMode_ :  "normal",
            scale_ :  1
        }

    };

    this.currentStyle_ = {
        lineStyle_ : this.defaultStyle_.lineStyle_,
        polyStyle_ : this.defaultStyle_.polyStyle_,
        iconStyle_ : this.defaultStyle_.iconStyle_,
        labelStyle_ : this.defaultStyle_.labelStyle_
    };

    this.styles_ = [];
    this.styleMaps_ = [];

//    this.exportLayer_ = {"id":id_, "optimize":true, "bbox":this.bbox_, "origin":this.origin_, "places":[], "ways":[], "borders":[]};

    this.exportLayer_ = {"id":id_, "places":[], "ways":[], "borders":[]};

    this.pointsWaitingForHeight_ = [];

    var mapConfig_ = this.engine_.browser_.getMapConfig()["json"];

    if (mapConfig_ != null & mapConfig_["version"] != null && parseInt(mapConfig_["version"], 10) >= 2) {
        this.gisProj4String_ = mapConfig_["srs"];
    } else {
        return;
    }

    this.load(this.path_);
};

Vadstena.KmlLoader.prototype.load = function(path_) {

    var onLoaded_ = (function(string_){
        this.xml_ = (new window.DOMParser()).parseFromString(string_, "text/xml");
        this.parseKml();
    }).bind(this);


    var onError_ = (function(configName_){

    }).bind(this);


    Vadstena.loadJSON(path_, onLoaded_, onError_, true);
};

Vadstena.KmlLoader.prototype.parseKml = function() {
    var xml_ = this.xml_;
    var root_ = xml_.documentElement;

    if (root_.nodeName != "kml") {
        return;
    }

    //this.engine_.browser_.setData("layer-begin", {"id":this.id_});
    this.layer_.push(["layer-begin", {"id":this.id_}]);

    var children_ = root_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "Document":
                this.parseDocument(child_);
                break;
        }
    }

    if (this.pointsWaitingForHeight_.length > 0) {
        this.removePointsUpdate_ = this.engine_.on("tick", this.getPointsHeights.bind(this));
    } else {
        this.layer_.push(["layer-end",{}]);
        //this.engine_.browser_.setData("layer-end");
        this.compile();

        if (this.onLoaded_ != null) {
            this.onLoaded_({id_:this.id_, path_:this.path_});
        }
    }
};

Vadstena.KmlLoader.prototype.getPointsHeights = function() {
    var maxProcessedPoints_ = 3;
    var li = this.pointsWaitingForHeight_.length;

    if (li > maxProcessedPoints_) {
        li = maxProcessedPoints_;
    }

    for (var i = 0; i < li; i++) {
        var p = this.pointsWaitingForHeight_[i];
        var result_ = this.engine_.browser_["getTerrainHeight"](p[0], p[1]);

        if (result_[1] == true) {
            p[2] += result_[0];
            this.pointsWaitingForHeight_.splice(i, 1);
            i--;

            li = this.pointsWaitingForHeight_.length;

            if (li > maxProcessedPoints_) {
                li = maxProcessedPoints_;
            }

            if (li == 0) {
                break;
            }
        }
    }

    if (li == 0) {
        if (this.removePointsUpdate_ != null) {
            this.removePointsUpdate_();
        }

        //hack for export borders
        //var mgl_ = new Vadstena.MglLoader("osm", this.engine_, null, this.exportLayer_);

        //this.engine_.browser_.setData("layer-end");
        this.layer_.push(["layer-end", {}]);
        this.compile();

        if (this.onLoaded_ != null) {
            this.onLoaded_({id_:this.id_, path_:this.path_ });
        }
    }
};

Vadstena.KmlLoader.prototype.parseDocument = function(document_) {
    var children_ = document_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "Style":         this.parseStyle(child_);         break;
            case "StyleMap":      this.parseStyleMap(child_);      break;
            case "Folder":        this.parseFolder(child_);        break;
            case "MultiGeometry": this.parseMultiGeometry(child_); break;
            case "Placemark":     this.parsePlacemark(child_);     break;
        }
    }
};

Vadstena.KmlLoader.prototype.parseFolder = function(folder_) {
    this.parseDocument(folder_);
};

Vadstena.KmlLoader.prototype.parseMultiGeometry = function(folder_) {
    this.parseDocument(folder_);
};

Vadstena.KmlLoader.prototype.parsePlacemark = function(placemark_) {
    var children_ = placemark_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "styleUrl":   this.parseStyleUrl(child_.textContent);   break;
            case "LineString": this.parseLineString(child_);             break;
            case "LineRing":   this.parseLineString(child_);             break;
            case "Point":      this.parsePoint(child_, placemark_);      break;
        }
    }
};


Vadstena.KmlLoader.prototype.parseStyle = function(style_) {
    if (style_ == null) {
        return;
    }

    var newStyle_ = {
        lineStyle_ : {
            color_ : this.defaultStyle_.lineStyle_.color_,
            colorMode_ : this.defaultStyle_.lineStyle_.colorMode_,
            width_ : this.defaultStyle_.lineStyle_.width_
        },

        polyStyle_ : {
            color_ : this.defaultStyle_.polyStyle_.color_,
            colorMode_ : this.defaultStyle_.polyStyle_.colorMode_,
            fill_ :  this.defaultStyle_.polyStyle_.fill_,
            outline_ :  this.defaultStyle_.polyStyle_.outline_
        },

        iconStyle_ : {
            icon_ :  this.defaultStyle_.iconStyle_.icon_,
            color_ :  this.defaultStyle_.iconStyle_.color_,
            colorMode_ :  this.defaultStyle_.iconStyle_.colorMode_,
            scale_ :  this.defaultStyle_.iconStyle_.scale_,
            x_ :  this.defaultStyle_.iconStyle_.x_,
            y_ :  this.defaultStyle_.iconStyle_.y_,
            xunits_ :  this.defaultStyle_.iconStyle_.xunits_,
            yunits_ :  this.defaultStyle_.iconStyle_.yunits_
        },

        labelStyle_ : {
            color_ :  this.defaultStyle_.labelStyle_.color_,
            colorMode_ :  this.defaultStyle_.labelStyle_.colorMode_,
            scale_ :  this.defaultStyle_.labelStyle_.scale_
        }
    };

    var children_ = style_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "LineStyle":  this.parseLineStyle(child_, newStyle_);  break;
            case "PolyStyle":  this.parsePolyStyle(child_, newStyle_);  break;
            case "IconStyle":  this.parseIconStyle(child_, newStyle_);  break;
            case "LabelStyle": this.parseLabelStyle(child_, newStyle_); break;
        }
    }

    var id_ = style_.getAttribute("id");

    this.styles_[id_] = newStyle_;
};


Vadstena.KmlLoader.prototype.parseStyleUrl = function(styleUrl_) {
    if (styleUrl_ == null) {
        return;
    }

    if (styleUrl_.charAt(0) == "#") {
        styleUrl_= styleUrl_.substring(1);
    }

    var style_ = this.styles_[styleUrl_];

    if (style_ == null) {
        var mapStyle_ = this.styleMaps_[styleUrl_];

        if (mapStyle_ != null && mapStyle_["normal"] != null) {
            styleUrl_ = mapStyle_["normal"];

            if (styleUrl_.charAt(0) == "#") {
                styleUrl_= styleUrl_.substring(1);
            }

            style_ = this.styles_[styleUrl_];
        }
    }

    if (style_ != null) {
        this.currentStyle_.lineStyle_ = style_.lineStyle_;
        this.currentStyle_.polyStyle_ = style_.polyStyle_;
        this.currentStyle_.iconStyle_ = style_.iconStyle_;
        this.currentStyle_.labelStyle_ = style_.labelStyle_;
    } else {
        this.currentStyle_.lineStyle_ = this.defaultStyle_.lineStyle_;
        this.currentStyle_.polyStyle_ = this.defaultStyle_.polyStyle_;
        this.currentStyle_.iconStyle_ = this.defaultStyle_.iconStyle_;
        this.currentStyle_.labelStyle_ = this.defaultStyle_.labelStyle_;
    }
};

Vadstena.KmlLoader.prototype.parseStyleMap = function(styleMap_) {
    if (styleMap_ == null) {
        return;
    }

    var newStyleMap_ = [];

    var children_ = styleMap_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "Pair":  this.parseStyleMapPair(child_, newStyleMap_);  break;
        }
    }

    var id_ = styleMap_.getAttribute("id");

    this.styleMaps_[id_] = newStyleMap_;
};

Vadstena.KmlLoader.prototype.parseStyleMapPair = function(styleMap_, styleMapPair_) {
    if (styleMapPair_ == null) {
        return;
    }

    if (styleMap_.getElementsByTagName("key")[0] != null) {
        if (styleMap_.getElementsByTagName(["styleUrl"])[0] != null) {
            styleMapPair_[styleMap_.getElementsByTagName("key")[0].textContent] = styleMap_.getElementsByTagName(["styleUrl"])[0].textContent;
        }
    }
};


Vadstena.KmlLoader.prototype.parseLineStyle = function(lineStyle_, style_) {
    if (lineStyle_ == null || style_ == null) {
        return;
    }

    var children_ = lineStyle_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "color":
                style_.lineStyle_.color_ = Vadstena.getABGRFromHexaCode("#"+child_.textContent);
                break;
            case "colorMode":
                style_.lineStyle_.colorMode_ = child_.textContent;
                break;
            case "width":
                style_.lineStyle_.width_ = parseFloat(child_.textContent);
                break;
        }
    }
};

Vadstena.KmlLoader.prototype.parsePolyStyle = function(polyStyle_, style_) {
    if (polyStyle_ == null || style_ == null) {
        return;
    }

    var children_ = polyStyle_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "color":
                style_.polyStyle_.color_ = Vadstena.getABGRFromHexaCode("#"+child_.textContent);
                break;
            case "colorMode":
                style_.polyStyle_.colorMode_ = child_.textContent;
                break;
            case "fill":
                style_.polyStyle_.fill_ = (child_.textContent == "1");
                break;
            case "outline":
                style_.polyStyle_.outline_ = (child_.textContent == "1");
                break;
        }
    }
};


Vadstena.KmlLoader.prototype.parseIconStyle = function(iconStyle_, style_) {
    if (iconStyle_ == null || style_ == null) {
        return;
    }

    var children_ = iconStyle_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "color":
                style_.iconStyle_.color_ = Vadstena.getABGRFromHexaCode("#"+child_.textContent);
                break;
            case "colorMode":
                style_.iconStyle_.colorMode_ = child_.textContent;
                break;
            case "scale":
                style_.iconStyle_.scale_ = parseFloat(child_.textContent);
                break;
            case "Icon":

                if (child_.getElementsByTagName("href")[0] != null) {
                    style_.iconStyle_.icon_ = child_.getElementsByTagName("href")[0].textContent;
                } else {
                    style_.iconStyle_.icon_ = "none";
                }

                break;

            case "hotSpot":

                if (child_.getElementsByTagName("x")[0] != null) {
                    style_.iconStyle_.x_ = parseFloat(child_.getElementsByTagName("x")[0].textContent);
                }

                if (child_.getElementsByTagName("y")[0] != null) {
                    style_.iconStyle_.x_ = parseFloat(child_.getElementsByTagName("y")[0].textContent);
                }

                if (child_.getElementsByTagName("xunits")[0] != null) {
                    style_.iconStyle_.x_ = child_.getElementsByTagName("xunits")[0].textContent;
                }

                if (child_.getElementsByTagName("yunits")[0] != null) {
                    style_.iconStyle_.x_ = child_.getElementsByTagName("yunits")[0].textContent;
                }

                break;

        }
    }

};

Vadstena.KmlLoader.prototype.parseLabelStyle = function(labelStyle_, style_) {
    if (labelStyle_ == null || style_ == null) {
        return;
    }

    var children_ = labelStyle_.childNode;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "color":
                style_.labelStyle_.color_ = Vadstena.getABGRFromHexaCode("#"+child_.textContent);
                break;
            case "colorMode":
                style_.labelStyle_.colorMode_ = child_.textContent;
                break;
            case "scale":
                style_.labelStyle_.scale_ = parseFloat(child_.textContent);
                break;
        }
    }
};

Vadstena.KmlLoader.prototype.parseLineString = function(lineString_) {
    var coords_ = [];
    var coords2_ = [];
    var correction_ = [0,0,0];
    var extrude_ = false;
    var lineStyle_ = this.currentStyle_.lineStyle_;
    var polyStyle_ = this.currentStyle_.polyStyle_;
    var altitudeMode_ = "clampToGround";

    var children_ = lineString_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "extrude":         extrude_ = (child_.textContent == "1");  break;
            case "gx:altitudeMode":
            case "altitudeMode":    altitudeMode_ = child_.textContent;      break;

            case "correction": //hack for jerusalem

                if (child_.textContent != null) {
                    correction_ = child_.textContent;
                } else if (child_.firstChild != null && child_.firstChild.textContent != null) {
                    correction_ = child_.firstChild.textContent;
                }

                correction_ = correction_.trim();
                correction_ = correction_.split(",");

                for (var j = 0, lj = correction_.length; j < lj; j++) {
                    correction_[j] = parseFloat(correction_[j]);
                }

                if (correction_[2] == null) {
                    correction_[2] = 0;
                }
                break;

            case "coordinates":

                if (child_.textContent != null) {
                    coords_ = child_.textContent;
                } else if (child_.firstChild != null && child_.firstChild.textContent != null) {
                    var subnodes_ = child_.childNodes;

                    coords_ = "";

                    for (var j = 0, lj = subnodes_.length; j < lj; j++) {
                        coords_ += subnodes_[j].textContent;
                    }
                }

                coords_ = coords_.trim();
                //remove tabs, newlines
                coords_ = coords_.replace(/\s/g," ");

                //reduce white spaces
                while(coords_.indexOf("  ") != -1) {
                    coords_ = coords_.replace(/\s\s/g," ");
                }

                coords_ = coords_.split(" ");
                break;
        }
    }

    for (var i = 0, li = coords_.length; i < li; i++) {

        var pos_ = coords_[i].split(",");

        for (var j = 0, lj = pos_.length; j < lj; j++) {
            pos_[j] = parseFloat(pos_[j]);
        }

        if (pos_[2] == null) {
            pos_[2] = 0;
        }

        var pos2_ = proj4_(this.gisProj4String_)["forward"]([pos_[0], pos_[1]]);
        pos2_[2] = pos_[2];

        pos2_[0] += correction_[0];
        pos2_[1] += correction_[1];
        pos2_[2] += correction_[2];

        coords_[i] = pos2_;
        coords2_[i] = [pos2_[0], pos2_[1], 0];
    }

    switch(altitudeMode_) {
        case "clampToSeaFloor":
        case "clampToGround":

            for (var i = 0, li = coords_.length; i < li; i++) {
                coords_[i][2] = 0;
            }

        case "relativeToSeaFloor":
        case "relativeToGround":

            this.pointsWaitingForHeight_ = this.pointsWaitingForHeight_.concat(coords_);
            break;
    }

    //hack for state borders
    //this.exportLayer_["borders"].push({"type":"state", "border":coords_});

    //for (var i = 0, li = coords_.length; i < li; i++) {
        //var pos_ = coords_[i].split(",");
    //}


    //if (polyStyle_.fill_ == true) {
        if (extrude_ == true) {
            //this.engine_.browser_.setData("polygon-wall", { "points":coords_, "points2":coords2_, "color": polyStyle_.color_});
            this.layer_.push(["polygon-wall", { "points":coords_, "points2":coords2_, "color": polyStyle_.color_}]);

        }
    //}

    //if (polyStyle_.outline_ == true) {
        //this.engine_.browser_.setData("pixel-line", { "points":coords_, "size":lineStyle_.width_, "color": lineStyle_.color_});
        this.layer_.push(["pixel-line", { "points":coords_, "size":lineStyle_.width_, "color": lineStyle_.color_}]);

        if (extrude_ == true) {
            //this.engine_.browser_.setData("pixel-wall", { "points":coords_, "points2":coords2_, "size":lineStyle_.width_, "color": lineStyle_.color_});
            this.layer_.push(["pixel-wall", { "points":coords_, "points2":coords2_, "size":lineStyle_.width_, "color": lineStyle_.color_}]);
        }
    //}

    coords_ = coords_;
};

Vadstena.KmlLoader.prototype.parsePoint = function(point_, placemark_) {
    var pos_ = [0,0,0];
    var correction_ = [0,0,0];
    var extrude_ = false;
    var name_ = "";
    var lineStyle_ = this.currentStyle_.lineStyle_;
    var iconStyle_ = this.currentStyle_.iconStyle_;
    var labelStyle_ = this.currentStyle_.labelStyle_;
    var altitudeMode_ = "relativeToGround";

    if (placemark_ != null && placemark_.getElementsByTagName("name")[0] != null) {
        name_ = placemark_.getElementsByTagName("name")[0].textContent;
    }

    var children_ = point_.childNodes;

    if (children_ == null) {
        return;
    }

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "extrude":         extrude_ = (child_.textContent == "1");  break;
            case "gx:altitudeMode":
            case "altitudeMode":    altitudeMode_ = child_.textContent;      break;
            case "name":            name_ = name_.textContent;               break;

            case "correction": //hack for jerusalem

                if (child_.textContent != null) {
                    correction_ = child_.textContent;
                } else if (child_.firstChild != null && child_.firstChild.textContent != null) {
                    correction_ = child_.firstChild.textContent;
                }

                correction_ = correction_.trim();
                correction_ = correction_.split(",");

                for (var j = 0, lj = correction_.length; j < lj; j++) {
                    correction_[j] = parseFloat(correction_[j]);
                }

                if (correction_[2] == null) {
                    correction_[2] = 0;
                }
                break;

            case "coordinates":

                if (child_.textContent != null) {
                    coords_ = child_.textContent;
                } else if (child_.firstChild != null && child_.firstChild.textContent != null) {
                    coords_ = child_.firstChild.textContent;
                }

                coords_ = coords_.trim();
                coords_ = coords_.split(",");

                for (var j = 0, lj = coords_.length; j < lj; j++) {
                    coords_[j] = parseFloat(coords_[j]);
                }

                if (coords_[2] == null) {
                    coords_[2] = 0;
                }

                var pos_ = proj4_(this.gisProj4String_)["forward"]([coords_[0], coords_[1]]);
                pos_[2] = coords_[2];

                pos_[0] += correction_[0];
                pos_[1] += correction_[1];
                pos_[2] += correction_[2];

                break;
        }
    }

    var pos2_ = [pos_[0], pos_[1], 0];

    switch(altitudeMode_) {
        case "clampToSeaFloor":
        case "clampToGround":

            for (var i = 0, li = coords_.length; i < li; i++) {
                pos_[i][2] = 0;
            }

        case "relativeToSeaFloor":
        case "relativeToGround":

            this.pointsWaitingForHeight_.push(pos_);
            break;
    }

    if (extrude_ == true) {
        //this.engine_.browser_.setData("pixel-wall", { "points":[pos_], "points2":[pos2_], "size":lineStyle_.width_, "color": lineStyle_.color_});
        this.layer_.push(["pixel-wall", { "points":[pos_], "points2":[pos2_], "size":lineStyle_.width_, "color": lineStyle_.color_}]);
    }

    var imageData_ = { "point":pos_, "scale":iconStyle_.scale_,
                       "x":iconStyle_.x_, "y":iconStyle_.y_, "xunits":iconStyle_.xunits_, "yunits":iconStyle_.yunits_,
                       "icon": iconStyle_.icon_, "color": iconStyle_.color_};

    if (iconStyle_.icon_ != "none") {
        //this.engine_.browser_.setData("flat-image", imageData_);
        this.layer_.push(["flat-image", imageData_]);
    }

    if (name_ != "") {
        //this.engine_.browser_.setData("flat-text", { "text":name_, "point":pos_, "scale":labelStyle_.scale_, "color": labelStyle_.color_, "image":imageData_});
        this.layer_.push(["flat-text", { "text":name_, "point":pos_, "scale":labelStyle_.scale_, "color": labelStyle_.color_, "image":imageData_}]);
    }
};


Vadstena.KmlLoader.prototype.compile = function() {

    for (var i = 0, li = this.layer_.length; i < li; i++) {
        this.engine_.browser_.setData(this.layer_[i][0], this.layer_[i][1]);
    }

};

/*
Vadstena.KmlLoader.prototype.updateBBox = function(point_) {
    var min_ = this.bbox_[0];
    var max_ = this.bbox_[1];

    if (point_[0] < min_[0]) { min_[0] = point_[0]; }
    if (point_[1] < min_[1]) { min_[1] = point_[1]; }
    if (point_[2] < min_[2]) { min_[2] = point_[2]; }

    if (point_[0] > max_[0]) { max_[0] = point_[0]; }
    if (point_[1] > max_[1]) { max_[1] = point_[1]; }
    if (point_[2] > max_[2]) { max_[2] = point_[2]; }
};

Vadstena.KmlLoader.prototype.getLayerBBox = function(layer_) {
    var borders_ = layer_["borders"];

    if (borders_ != null) {
        for (var i = 0, li = borders_.length; i < li; i++) {
            var borderPoints_ = borders_[i]["border"];

            for (var j = 0, lj = borderPoints_.length; j < lj; j++) {
                this.updateBBox(borderPoints_[j]);
            }
        }
    }

    var min_ = this.bbox_[0];
    var max_ = this.bbox_[1];

    this.origin_[0] = min_[0]; //(max_[0] + min_[0])*0.5;
    this.origin_[1] = min_[1]; //(max_[1] + min_[1])*0.5;
    this.origin_[2] = min_[2]; //(max_[2] + min_[2])*0.5;
};

Vadstena.KmlLoader.prototype.makePointsRelative = function(layer_) {
    var points_ = this.points_;
    var origin_ = this.origin_;

    for (var i = 0, li = points_.length; i < li; i++) {
        var pos_ = points_[i];
        pos_[0] -= origin_[0];
        pos_[1] -= origin_[1];
        pos_[2] -= origin_[2];
    }
};

*//**
 * @constructor
 */
Vadstena.OsmLoader = function(id_, engine_, path_, language_, onLoaded_, onUpdate_)
{
    this.id_ = id_;
    this.engine_ = engine_;
    this.path_ = path_;
    this.onLoaded_ = onLoaded_;
    this.onUpdate_ = onUpdate_;
    this.xml_ = null;
    this.nodes_ = [];
    this.ways_ = [];
    this.relations_ = [];
    this.language_ = language_;

    //bbox defined by min and max points respectively
    this.bbox_ = [[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],
                  [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]];

    this.origin_ = [0,0,0];
    this.shift_ = [0,0];

    if (this.engine_.params_.urlParams_["osm-shift-x"] != null) {
        this.shift_[0] = parseFloat(this.engine_.params_.urlParams_["osm-shift-x"]);
    }

    if (this.engine_.params_.urlParams_["osm-shift-y"] != null) {
        this.shift_[1] = parseFloat(this.engine_.params_.urlParams_["osm-shift-y"]);
    }

    //this.totalLayers_ = 8;
    this.exportLayer_ = {"id":id_, "optimize":true, "bbox":this.bbox_, "origin":this.origin_, "places":[], "ways":[], "borders":[]};

    this.points_ = [];
    this.pointsWaitingForHeight_ = [];

    var mapConfig_ = this.engine_.browser_.getMapConfig()["json"];

    if (mapConfig_ != null & mapConfig_["version"] != null && parseInt(mapConfig_["version"], 10) >= 2) {
        this.gisProj4String_ = mapConfig_["srs"];
    } else {
        return;
    }

    this.load(this.path_);
};

Vadstena.OsmLoader.prototype.load = function(path_) {

    var onLoaded_ = (function(string_){
        this.xml_ = (new window.DOMParser()).parseFromString(string_, "text/xml");
        this.parseOsm();
    }).bind(this);


    var onError_ = (function(configName_){

    }).bind(this);


    Vadstena.loadJSON(path_, onLoaded_, onError_, true);
};

Vadstena.OsmLoader.prototype.parseOsm = function(language_) {
    var xml_ = this.xml_;
    var root_ = xml_.documentElement;

    if (root_.nodeName != "osm") {
        return;
    }

    var nameTag_ = "name";

    if (this.language_ != null) {
        nameTag_ = "name:" + this.language_;
    }

    /*
    this.layers_ = [];

    for (var i = 0, li = this.totalLayers_; i < li; i++) {
        this.layers_[i] = [];
    }*/


    var children_ = root_.childNodes;

    for (var i = 0, li = children_.length; i < li; i++) {
        var child_ = children_[i];

        if (child_.nodeType != 1) {
            continue;
        }

        switch (child_.nodeName) {
            case "node":
                var id_ = child_.getAttribute("id");
                var visible_ = child_.getAttribute("visible");
                visible_ = visible_ == "true";

                var lat_ = child_.getAttribute("lat");
                var lon_ = child_.getAttribute("lon");

                if (lat_ != null && lon_ != null) {

                    var pos_ = proj4_(this.gisProj4String_)["forward"]([parseFloat(lon_), parseFloat(lat_)]);
                    //pos_[2] = 10000.0;
                    pos_[0] += this.shift_[0];
                    pos_[1] += this.shift_[1];
                    pos_[2] = 0.0;

                    this.points_.push(pos_);
                    this.pointsWaitingForHeight_.push(pos_);

                    this.nodes_[id_] = {
                        visible_ : visible_,
                        position_ : pos_
                    };


                    var nodeChildren_ =  child_.childNodes;
                    var nodeTags_ = [];

                    for (var j = 0, lj = nodeChildren_.length; j < lj; j++) {
                        var nodeChild_ = nodeChildren_[j];

                        if (nodeChild_.nodeType != 1) {
                            continue;
                        }

                        switch(nodeChild_.nodeName) {
                            case "tag":
                                var key_ = nodeChild_.getAttribute("k");
                                var value_ = nodeChild_.getAttribute("v");
                                if (key_ != null && value_ != null) {
                                    nodeTags_[key_] = value_;
                                }
                                break;
                        }
                    }

                    //EXPORT
                    var type_ = null;
                    var name_ = nodeTags_[nameTag_];
                    var population_ = null;

                   switch(nodeTags_["place"]) {
                        case "country": name_ = nodeTags_["int_name"] || nodeTags_["name:en"] || nodeTags_["name"];
                        case "city": name_ = nodeTags_["name:en"] || nodeTags_[nameTag_];
                        case "town": population_ = nodeTags_["population"];
                        case "suburb":
                        case "locality":  type_ = nodeTags_["place"]; break;
                    }

                    switch(nodeTags_["amenity"]) {
                        case "cafe":
                        case "restaurant":
                        case "fast_food":
                        case "bar":
                        case "pub":
                        case "townhall":
                        case "post_office":
                        case "toilets":
                        case "bus_station":  type_ = nodeTags_["amenity"]; break;
                        case "place_of_worship":

                            if (name_ != null) {
                                switch(nodeTags_["religion"]) {
                                    case "christian":
                                    case "muslim":
                                    case "jewish": type_ = nodeTags_["religion"]; break;
                                }
                            }

                            break;
                    }

                    switch(nodeTags_["tourism"]) {
                        case "hotel":
                        case "hostel":
                        case "guest_house":
                        case "museum":
                        case "information":  type_ = nodeTags_["tourism"]; break;
                    }


                    switch(nodeTags_["historic"]) {
                        case "castle":  type_ = nodeTags_["historic"]; break;
                    }

                    switch(nodeTags_["railway"]) {
                        case "station": type_ = nodeTags_["railway"]; break;
                    }

                    if (type_ != null) {
                        pos_[2] = 15.0;
                        var place_ = {"type":type_, "name":name_, "pos":pos_};

                        if (population_ == "population") {
                            place_["population"] = population_;
                        }

                        if (nodeTags_["website"] != null) { place_["website"] = nodeTags_["website"]; }
                        if (nodeTags_["contact:website"] != null) { place_["website"] = nodeTags_["contact:website"]; }
                        if (nodeTags_["phone"] != null) { place_["phone"] = nodeTags_["phone"]; }
                        if (nodeTags_["contact:phone"] != null) { place_["phone"] = nodeTags_["contact:phone"]; }
                        if (nodeTags_["opening_hours"] != null) { place_["opening_hours"] = nodeTags_["opening_hours"]; }

                        this.exportLayer_["places"].push(place_);
                    }

                }


                break;

            case "way":

                var wayChildren_ =  child_.childNodes;
                var wayPoints_ = [];
                var wayTags_ = [];

                for (var j = 0, lj = wayChildren_.length; j < lj; j++) {
                    var wayChild_ = wayChildren_[j];

                    if (wayChild_.nodeType != 1) {
                        continue;
                    }

                    switch(wayChild_.nodeName) {
                        case "nd":
                            var ref_ = wayChild_.getAttribute("ref");
                            var node_ = this.nodes_[ref_];

                            if (node_ != null) {
                                wayPoints_.push(node_.position_);
                            }

                            break;

                        case "tag":
                            try {
                                var key_ = wayChild_.getAttribute("k");
                                var value_ = wayChild_.getAttribute("v");
                                if (key_ != null && key_ != "length" && value_ != null) {
                                    wayTags_[key_] = value_;
                                }
                            } catch(e) {
                                e = e;
                            }
                            break;
                    }
                }

                //state borders
                if (wayTags_["boundary"] == "administrative" &&
                    wayTags_["admin_level"] == "2" ) {
                    this.exportLayer_["borders"].push({"type":"state", "border":wayPoints_});
                }

                //piste
                if (wayTags_["piste:type"] == "downhill") {
                    //piste:difficulty intermediate easy
                    this.exportLayer_["borders"].push({"type":"state", "border":wayPoints_});
                }

                //ways
                if (wayTags_["highway"] != null && wayTags_["area"] != "yes") {

                    //EXPORT
                    switch(wayTags_["highway"]) {
                        case "primary":
                        case "secundary":
                        case "tertiary":
                        case "residential":
                        case "pedestrian":
                        case "footway":
                            this.exportLayer_["ways"].push({"type":wayTags_["highway"], "name":wayTags_[nameTag_], "way":wayPoints_});
                            break;
                    }

                }

                break;

            case "relation":
                break;
        }
    }


    if (this.pointsWaitingForHeight_.length > 0) {
        this.removePointsUpdate_ = this.engine_.on("tick", this.getPointsHeights.bind(this));
    } else {
        this.getLayerBBox(this.exportLayer_);
        this.makePointsRelative(this.exportLayer_);

        this.exportLayer_["bbox"] = this.bbox_;
        this.exportLayer_["origin"] = this.origin_;

        var mgl_ = new Vadstena.MglLoader("osm", this.engine_, null, this.exportLayer_);
    }

};

Vadstena.OsmLoader.prototype.getPointsHeights = function() {
    var maxProcessedPoints_ = 30;
    var li = this.pointsWaitingForHeight_.length;

    if (li > maxProcessedPoints_) {
        li = maxProcessedPoints_;
    }

    for (var i = 0; i < li; i++) {
        var p = this.pointsWaitingForHeight_[i];
        var result_ = this.engine_.browser_["getTerrainHeight"](p[0], p[1]);

        if (result_[1] == true) {
            if (p[2] != 0) {
                p[2] = p[2];
            }

            p[2] += result_[0];
            this.pointsWaitingForHeight_.splice(i, 1);
            i--;

            li = this.pointsWaitingForHeight_.length;

            if (li > maxProcessedPoints_) {
                li = maxProcessedPoints_;
            }

            if (li == 0) {
                break;
            }
        }
    }

    if (li == 0) {
        if (this.removePointsUpdate_ != null) {
            this.removePointsUpdate_();
        }

        this.getLayerBBox(this.exportLayer_);
        this.makePointsRelative(this.exportLayer_);

        this.exportLayer_["bbox"] = this.bbox_;
        this.exportLayer_["origin"] = this.origin_;

        var mgl_ = new Vadstena.MglLoader("osm", this.engine_, null, this.exportLayer_);
    }
};

Vadstena.OsmLoader.prototype.updateBBox = function(point_) {
    var min_ = this.bbox_[0];
    var max_ = this.bbox_[1];

    if (point_[0] < min_[0]) { min_[0] = point_[0]; }
    if (point_[1] < min_[1]) { min_[1] = point_[1]; }
    if (point_[2] < min_[2]) { min_[2] = point_[2]; }

    if (point_[0] > max_[0]) { max_[0] = point_[0]; }
    if (point_[1] > max_[1]) { max_[1] = point_[1]; }
    if (point_[2] > max_[2]) { max_[2] = point_[2]; }
};

Vadstena.OsmLoader.prototype.getLayerBBox = function(layer_) {
    var places_ = layer_["places"];

    if (places_ != null) {
        for (var i = 0, li = places_.length; i < li; i++) {
            this.updateBBox(places_[i]["pos"]);
        }
    }

    var ways_ = layer_["ways"];

    if (ways_ != null) {
        for (var i = 0, li = ways_.length; i < li; i++) {
            var wayPoints_ = ways_[i]["way"];

            for (var j = 0, lj = wayPoints_.length; j < lj; j++) {
                this.updateBBox(wayPoints_[j]);
            }
        }
    }

    var min_ = this.bbox_[0];
    var max_ = this.bbox_[1];

    this.origin_[0] = min_[0]; //(max_[0] + min_[0])*0.5;
    this.origin_[1] = min_[1]; //(max_[1] + min_[1])*0.5;
    this.origin_[2] = min_[2]; //(max_[2] + min_[2])*0.5;
};

Vadstena.OsmLoader.prototype.makePointsRelative = function(layer_) {
    var points_ = this.points_;
    var origin_ = this.origin_;

    for (var i = 0, li = points_.length; i < li; i++) {
        var pos_ = points_[i];
        pos_[0] -= origin_[0];
        pos_[1] -= origin_[1];
        pos_[2] -= origin_[2];
    }
};

//place=country
//admin_level=2
//border_type=nation
//boundary=administrative


/**
 * @constructor
 */
Vadstena.MglLoader = function(id_, engine_, path_, mglLayer_, onLoaded_, onUpdate_)
{
    this.id_ = id_;
    this.engine_ = engine_;
    this.path_ = path_;
    this.onLoaded_ = onLoaded_;
    this.onUpdate_ = onUpdate_;
    this.layers_ = [];
    this.totalLayers_ = 11;
    this.mgl_ = null;

    this.engine_.browser_.setData("layer-icon", {"id":"cafe", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1MjYxM0U2RjE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NzU0MTYyM0E4NjgxMUU0OTEyNzgwNTAyMTAwNjYzNSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NzU0MTYyMkE4NjgxMUU0OTEyNzgwNTAyMTAwNjYzNSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NTI2MTNFNkYxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NTI2MTNFNkYxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Ae8X1AAADoUlEQVR42sSXy08TURTG59EHSCuKlPpCYhBjlWAxBKIJBpbsWbHCDQn/g0tY8SewYAnsDGHjBnZKTMAHgiQg+AKRlhahFKaPGb/TfNM0BIiFjt7kl7mFyZxzzz33O+cqyn8e6jF/04EblAEPcJ3w3knD4tMEGZACBudmwf+PdUCMV4ArIAgu0RG1yIVZNHgIdkGcJOiQab/oOuKMFwTAA3KLDulFGhcDabAHIuA7WAPfQBQc2E4cdeACuAnCoBXcBuXniIAY2gE/wCfwDiyBn7YTxzlQA+rD4XDj1NRU3VmTyzAMZXl52RwbGzscHh6+kU6nq7kYhdH5xdxQCrfjDngGXjQ3N29ZJRozMzPZmpqaDXz3JXgOnnKrde1IBDTut4vzM4+VlZX8vK2tTZuYmAi63W5Z4H1urSS4S3PqfDc0NCgtLS3K2tpa3om+vr6rzLFaUCVJrzkpMrOzs0p3d7eCXcj97unpKePKJfwXRWc0p5Vubm5OWVxczM0bGxs16oqfT5f2L+Q2mUzmnh6Px861PI47EAwGlaamptwc+WBRCQ/4zDrqgN/vV0ZHRxWv15v7PTk5KUZ/Uw1FJVMup4yPjIwoXV1duQjIWF9ft4aGhrYw3aAySm0wHHOgt7c3P49EIhZOQxzPVUryZxATRdScTr7x8fEMNGATavhRDgV4D76ySmYdi0AoFMqsrq7upVKpTVbCD+AtWABbLNWW65SGwjqPA0tLS4csOLZhWblsgTi0X1iOtYJGxMeKqJcgCAfsBWS/V1iCkwWNj2WXYy/lUdK1HlwXZ6LRqGqapqJpxafJ9va23ZKZXORFfreS2R9ln2Do1GWpUo9ISArG7u5uJRzwdnR0qBhF9QH9/f3m/Px8mk2J9JfV7K5q6USW0TDkyw/BE/AY3CsoFLIVnkAgoImg/O2IxWLKzs6OyWZjn4JjsAlJcDteg1eSExKey6zPd6enp8PZbFa3WzBUMfWM+68hamUsOFX5jlfXs52dnRoTUfTAY+eArNbX3t7uxkulbvnzi8DiNCZ6Be3mMmzfbpsHBgaS8XjcEV2Q7w4ODiZpK8YcyKhMulbmgbTiAZ/PV44CUuyF5MQOGYmZSSQS9rFc4P6/EUVUmaF1NN4ArjFM7lI5UJCAogXLQDqUL3IUVV6//Mz+ADWhnGJRilph8tjZd4QIkdORtjsTnY547VaJxksVAfueaLAGpOjUscdMPeXieh4nzl1fHBl/BBgA1teFO49T4IIAAAAASUVORK5CYII="});
    this.engine_.browser_.setData("layer-icon", {"id":"restaurant", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1MDYxM0U2RjE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NjcxNjIxNkE4NzIxMUU0QTQ1NEYyNTI2NDM3QUNCNiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NjcxNjIxNUE4NzIxMUU0QTQ1NEYyNTI2NDM3QUNCNiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NTA2MTNFNkYxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NTA2MTNFNkYxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5HYBLWAAADRUlEQVR42ryXS08TURTHOy2lqBHxTRqfK4yJOxONccPKyAo/A2HJF/BDsEHiAsLKBXtWsmzQEOPGxKpBomJa2wIWpa+ZYR7+D/6HXOqddootJ/nldmZu7z333HPOvceI6SUOkiDFVp4N4CutB/aAzd99oB8k+N0mDr9rxQiZ/CQ4By6CM4oSntLK5BWwy0lOgEG2Dt9vgx3QAK5OgT7NuyQnvwVugyscNJg4wcFMsElkpUPgMjjN5yL4TH6Auk4JnQIDHOgOuA9u8l28aQtEgZ/EoaUugFO0jihwiXOIQoUwKzSL/OkReAbebWxs7K8WrazezOVyHp9dDrouq0ylUvmZmRlzbW3NW1lZcUZHR0t4/xI8BfdooUiSBk/AC/DVh8iKQ1qb+2tOTU25viKFQkEUzYLn4DEXFskH4tznJNtW0heMkU6nDzn08PCwQWcOHDMZVYEgOoyQKGkXRaokOEc8rG881ltpu5BeK9BWwhQIMt1+Bvvrb/+2Sj//qArofMBlHFuM71ayx/4JwzCSEXwikgVk0Coog9+IaW3yWF5elvc1puMGFPC6tQUWJ/8O8mNjY5uTk5OHlJiYmHDGx8d3mOuFWrcV2GQOX69UKqX5+fm62mFhYaEBkRScZ9/qUf1Ap4DDEywnmRBsMe+rYrJPnmdBvZtR4HGCXxy8Sr9o9pMa+8h3C1vgdysKAiWcFhcKj99q9Hyrm1sQVRyaXqywm8lk6qurq8euQI3bVF5aWipDCbdbWxBFXFrAZNgGoZg4Lgv4dMYGsY/iB/97GPmKw3rH7YQ9PQ07tUJPFAjM64bkAfXbfqtJRmofv1MFgmQjXm67rqveBQ4uo4oTmpZlHYSh4zhqPzvsSt5KAZvVjVyvt+fm5sxqtRqbnZ01eQKWGH5lHkilxcXF7Ww26+EAi01PTzd4jhQ5jt3ppVIKjBssTh6AEd5wZbBP4DV4y7PgOngI7oJrrBHlsPoIXoE34Jvu0GqViCyu4D33r8CySxT4wjt/kdvgs5CVzHiVCpRZtHxQyreOLGBwoEEWqedZojU4+FZTYXqWxccQFxak6S3emrSJKsq9P8HV9SuFqU0LuRw0zkkH2M+gYpbigNoo+CPAABk+hNn4QyiIAAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"fast_food", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NTczM0Q3QTA4MjA2ODExODA4MzlCMjg0NTNCOUYzMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNjI5MkQyNUE4NzkxMUU0ODZEQ0U3OTAwQ0UzOEY0QiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNjI5MkQyNEE4NzkxMUU0ODZEQ0U3OTAwQ0UzOEY0QiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NzU3MzNEN0EwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzU3MzNEN0EwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4uQRksAAAEF0lEQVR42sxXzU9TWRS/fX0tbfkQBXX8ilIxUeOQqGBmwYRkSCAkhgxbEsBAwpod4S9g44q1G9waFrCEhEzYuCBMMgESTCzfoiIzxaltfe1773oO/q65vrT1CaLe5BduH/e+8zvf5wnxg1fgO8gwCCYhjL1LyBFs3ge/g/AooZZwgXCOUIn/MQHnuAlECKcJNwh38JfJSEKa8N48Zu0rCJcJjYTbhFOEbbg+SfjfOEYCIcIJELgZj8dvz8/P/077OFzB5EzzGwRxANoGPEFdDvMzgUttbW3nEokEPy/TzgvzCOZlDWNABO/SCbD21wh17PeOjo6yiYmJLO3fsekJGULePIJ5TyKyz2Ov0kytSmhfH4lEalpaWoIDAwNM4D1IWJwF5hGimwU3EW5hH/ZYIAIr/NLc3Fy9tLQk9/b2HM2CB244CgFOp+umad5tbGyMSyk/exf9PihAruuGu7u7QwsLCwEKxOjq6molLFYOSx5qscZ/Eh4Hg8FELpeTftba2hpXwb8JDwl/EGoOm4ZcSNictuM47vb2tvRziQhIBGtIueCwBGzUc45ka3193S8BtkAegZj3BqFKrTBgFshtgWZShTNMJE8EXE8GFFwbGxs2hKf1LAhAWAzBUQMB3ESCHgISBMKIA65mBr3Y9WMBImpDcBpEbBNC+EUXUTiucurgWaiABWz4P6pKKplW+HRBXiNgKQIRCGwg3OPUIpzB82ARF9h4zmeq6cW+5goqxRY0z+guKIf2TOBOX1/fr729vRV1dXVFfZpKpcTs7KwzOjpq7+7uBonAF9t6NpsVOzs7LDyryjCUOTD7A8KT1tbWV1Q4pN81NzfHMSENw5CWZZU8u7y8zMKeER4R7sPqB8FXBZPXUrkMNzU1Sb+jGtWAjz5xXbG5uSnq6+tLBaD0BqAiUIGyWjU4OFje2dkZoOUrqJLJpOjv7xdbW1scYCUJUKY43gAU2rDIPTo0MjISjkajX1WRurq6xNjYGGvoJwU/qwGKgK2q0vj4uE2Dg+8GlclkxPT0tBLwpRS0i7kgjfksNTQ09C4Wi1X7bghSiv39fV8EqAvmPC74ZAGeTnYJ/7a3tzuTk5O+zb+4uCgaGhps+NgoVY6JgIX0y6CPOKr+M4EXbKWpqanE8PBwemVlRVKLLSqYtZ6ZmXF6enrYcq8JbygQ0yWCVRLewtJv4QJXDZU8IFzB6PwbKmGt1guMAr2AYyalXIeSfQq9JKrdUeeZ3HPCU8JfqAdJ5QKuTC8J/8A3L1AkKrW+7Z0DWIP/WHNoxFl0FvWkwkPAgZU5SBZhsax3rA7hYg20P1Fk0hXat10awrPaN0AV7ul3HJxR7tpDHDj6x2lAmwfKALNIUCmt8tpHpoE74QKjvsQZSx9ExM+yPggwADQwCmTS2nFKAAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"bar", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpBQjMxQzZGQjEzMjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3RDQwNEM2RkE4ODAxMUU0ODQ5OUJEREUwQUZBNEE3RCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3RDQwNEM2RUE4ODAxMUU0ODQ5OUJEREUwQUZBNEE3RCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QUIzMUM2RkIxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QUIzMUM2RkIxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7a7c5yAAAExUlEQVR42uyXSUgkVxzGrerqJS7jOhMzYzaR0SHEECeoBEHEQyJCjh48Rj14kOQUEAIBPYgSCMGgJ3P0piQG8RJIAioS98yo4zaTyXTUJN2O7TL2VvXy/eErKXq61YFALj740VXdb/nef3uv09Ku2v/ctP9oHh24gBsYfJemEtaR9ziIAhNYmqODiwN1vl8kTjmePeAayAEZFJEoQOPiRyAIDkBEY2cfyCJexw4uahYnTgevgFsgn5ZIFCBzhsEOWAdbIGAv/jJ4kxNk0xqXsYDJfpmgKEGAcgiwrXoCHvL5KTg0aLpiUA3ugAIKuEwz+SlWy2tsbCxsaWnJ3t7eVsk6V1RUpNXX14uYJ9yo26B6UX6nqampxjCM7BcIThUOh9Xo6KgI8WZmZvqGhoZc4+PjSTsPDw+b3HAWLe8yGAMvyQ/FxcU5PT09WS8S/p2dnRYtoefk5OjHx8cp+7rdbjvmPHbQaw7zN7hcruqpqaniqqqqSwXhwsKCQt+TOJpM2t7e7m1ubnbt7u4m7V9eXq7Kyso28PgL+B7MG0yLP8G2aZpF8GHe3Nxcns/nO3fxWCyW1traeoi19yWdxIKhUCi/pqYmZfwEAgE7G+xaoekUIEGxAh6srKz4u7q6Ihftvq+vL7q4uCgptc3IDkBA9LwxwWBQMXVNfiqdVSkANsF9yU9Mvjs7O6tSTbS6uqq6u7v3mMv3mNf/bG1thc8T4Pf7Fdc7tauhTiXPgDhuTSwBVzxua2s7iEaf3xB+S8NvoUgk8piC79kW2NjYOD46OkopYG1tLc5aEOKaMd2Rz/Ll75z0wfLysr+3t/c5V/T398emp6f90gf8RtEiZk8pFZqfnzdTCZiZmTlhGf6bro8lHiiSo++CDvCdx+N5srS0ZCm2zc1NKz09XQL2B/ApuMsKKJ+fSGSXlJT4R0ZG4uJvaUhLNTExYSK4ZcFfwdfgI/Cqo2SfNYnOQvAh+FIyrbKy8sQW0NDQIGZbBF+BRtb/dBayD0A3+JFZFZYxg4ODYhHJlCXwLfhYMpKb1Y2Eo1nxwDhgYB7CrxEuIj6MJp5mNOMBgziDlTWXz15N0xR/36L4+xQogWjpjsUNlsh8kuk4VhOtlME+Bexn0q+PSJBRbh9a4vu/wB88DQ95NJ8toHHSm6AUvA3KuIDnrPAr5ebCpVzAwxTc4bvlOAVVkouPldDnTIBBs90G74N3wBsiAIs6BcjzDUfAXuPkFk16i0GZawvHGJ2bu86YyWXGidWULcDNyV6TnXd0dNytra3NlsE4Hc9OxoGBAeP09DQbfs1Cul3HwRWjPwOc8DatU4gyLa5Jq6ur00tLS3PX19eLeOfYpLtOnVYS378HPpMoHhsbC6sL2uTkZJSHyudykJEvIPgnCD1x9t3f37eQQRKE3zB7btq3Lnt3EuWv81SsAW/R/+4k1zOLARRkMZrkOaLRddW0gu0Gxar3iHXgZ6nmHG/ZLojxirTBQfv0mS+FgAjN/pAidriQi67Y4wZ8/P6IGbDCvs9s8ztvxT5ek24w0q/RAlqSu6AIPnaU1UN+n0XhBXx2O2rLU6ZigGlpJv4vsGuBl3jOuRuaFBEhcYcFvNyMx2G9OPuFOc68+kt21ez2rwADAH9SG5wV6cLDAAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"hotel", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5MURDMUVFODEzMjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDOEIxMzRGMkE4ODExMUU0OUQ0NTg3RDQ5MjI1NUEwMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDOEIxMzRGMUE4ODExMUU0OUQ0NTg3RDQ5MjI1NUEwMSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTFEQzFFRTgxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTFEQzFFRTgxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7kOhBoAAADN0lEQVR42uyWS08TURiGz0ynlqbaAC2NRhLaBYjlGhcsDAtYsDLBHb+AFf+B38CGnWFN+AnsWWLQFqlaNfHSu6XSAr1MZ8b31HfISFpjocSFnOTJXDJzznu+73wXIW7H/z4U4gJ3iHw2QB3owLxJARrwgHsgCAb47gwcgzKogSaRYqxeC5CLh0EUjAAvF/8KsuCEgiTVS0IMYl5VnMadPwZPwSMKKIFvFFAiRfCDrrEXbtBNusNKxiVMXpvthGo0e0QuvrW1Nbe4uOiZnZ0tlMvlEbrg1CHgmC6xF605qFNQwyHMeZXfnNOS5/b5kgJ8ICCZm5vri0QiSjgcDsZiMf/KyoqYmZkR29vbJ4eHhyX+rDt21G4RJ1XH9ZSbkFZN874qBbh5EDXbLJZluZaXl707Ozut59XVVe/o6Gj/0tKSWFhYUHO5nJnJZIxsNmuk02kdV0kD/zU77L7BXRdAErwCCZDTGHYquRgTExMX96FQSAQCgb719fWWRdoNXddFPp8XEGIRE0INvDNSqVQTghv7+/vFer0e5C/ycFfkzTPwAryLx+MmdmFNTU1ZQ0NDFtxgNZtNa3NzUx6a1vN1RiKRMH0+X4LrPQcPtU7hUSgUxPT0tHC73a3d9WKMj48rY2NjgwcHB4N49EvXdxSAMyA2NjZ+ezc8PNyr7KvaWbijgGQyKXZ3d4XL5epd3lcUq1gsOnOF2VEA/CXW1tZ6nfotRxi3ElJbAXt7e8IwjJuoPSrC2IPD7GLYq20F+P3+G6t+cKnKxTsLmJ+fN4+OjnT4rApsk3W9W0SenN+LqxtW1aLRqOAB1NgCtBdQqVT0Uqkk834GfGcW67bSeVhnHsiCB5fe7VQNLUeV+iVdVWushi/Be4rotjHxs8g9kY0OLOlj6JmXo6DGlHgmw0R+BAGycHwBMfBa5uwruGGAVVQKCWLu+5y7yirbKmwaP/oMPkxOTipsy+Tu34C38j0rV7cuKNHfIdCPuQ3H3J9AXrrWDgeTFUs2HClWqjj4yMUbFNAtwtG4tJv7WGE/MECldk9YocIC6/iVooDd1R/nVhxh0UcTqcxWdXKdRvRv5r4dt+Pfjp8CDADpb8yIWevDewAAAABJRU5ErkJggg=="});
    this.engine_.browser_.setData("layer-icon", {"id":"pub", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0RDMzMTY1NzA4MjA2ODExODIyQUQ3RDIzRDA0NEE5NSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0RkI1OUQ0NkE4ODYxMUU0OTY3NUIxNTAzOTNCMDU2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0RkI1OUQ0NUE4ODYxMUU0OTY3NUIxNTAzOTNCMDU2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NEQzMzE2NTcwODIwNjgxMTgyMkFEN0QyM0QwNDRBOTUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NEQzMzE2NTcwODIwNjgxMTgyMkFEN0QyM0QwNDRBOTUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5V3gm+AAAD/klEQVR42uyXzUtUURjG59yZO96xmRzHSSsbyawh0MqhhL4WtRMCv3Yt+kDQTbgxQULBkGih4j4Ion8ggv6Aoha1ahNYUZC2iLFsajJtrJm5Pa89V463O6OraOGBH36cc973Oe8973vOUb71TYEg2A52kAj7voFP4CNYBL+AzT4DVHBsFIRBAKxw7Bew5Jqz2vwuAQE63wtS4Dg4Bg6CnRQnRn+An5oxcV4DDoBD4DBIgt0UUwQ5zim6HboFyQr2gTYaqqOjNFe4xBV9BwVGLQT2gKMUnqBYidobChTRyyCvOzQ8BIjiXSJienq61bbtAyA5NjbWiv81MhJhLXoioJJCD8ZisdTExMTxqampYyMjI6e4CIlMnELKtjBDfg085kpt8hk8BENcZaUmWiJ2AdxLpVLzNlsmk5F5L8EtcI7iVbkIGDRoys/JyckQ7PiE0dHRSr1Pm+tnuKXfmp2dVblcbrVjbm7O5uepIpZ73xkeUTA0fB5Z4vQ5KzHpXDZvqLm5ucKyrNUO/K7q6+slqtWgliKC5QQozYnCylUJcUobb9G5fONIT09PyBlsmqavr68vwr56pvU23a/hcu6EM+jOEIoJsM/5DH4ajHMTVnV1da2b19vbCx2mpGgD07JKt21ozk2mmQyOSVjh1NAEGAx1jGMidF7FzVXb1tZW3djYuC5qiURCdXR01HBMgmJDThQNTUiEYdpPtVEPAdUsUvs5Nk4kbWu6u7sjXqmFz1DJ8CcoJOLejCFWrovgrqTO+Pj4yuLiopNR9sLCgj04OCjbewbcAZfAGXAe3AavZ2ZmirZHKxQKdjKZnMeYB+AKaKHPtSbV7yS4Dp4MDw8v2yXawMDAd9aIm+AyuArut7S0pO0yDYVJxD8DN8Bp+lz7BEHtW8b7+/utUpVqaGjICecebipJr0h7e3u4XIXr7Ox0fMT5CYK6gADTSYxY7o2kt4aGBif1oky/1QJTV1cXKCegqalJsRSHOT/g3oRrVU4ptVHJ1tPVLFG01heYPzYD7kpqeBShDb27xqoSRWujeSVL8T9tWwK2BGwJ+O8E2O6Hw2YbKt1m5v1l39A6CqS4SUPO+F/8uZlW1ObZuoA8Xy7ykFjKZrNlVxONRlc49ivIgGw6nV4pN0fuE3zMZPlIyfu0mhzl8+ssOCGHl3Z5VK4VyOR34Dl4xZNNnmNHeDwHXZ/W5jxx/hY8BY/kAiMLcI5QWb3cWF7w7w88av0eAsTQe96M5njCLTMiu3lvNDw+l6x8lj7m6XPNuJ8TndttzOsRQWM5vpjmaVRxvHPvr/A4UQuMXIbzPlN0QbnOeJOOK7gyryM2z1eu89p1blSW13VeE57nyzqnb9zfAgwAUB5gZCDcBXEAAAAASUVORK5CYII="});

    this.engine_.browser_.setData("layer-icon", {"id":"christian", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpCQjk0MzA0ODE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCMEFGOEY5NUE4OEMxMUU0QUQwNEE2NTQzREE2NTVCNiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCMEFGOEY5NEE4OEMxMUU0QUQwNEE2NTQzREE2NTVCNiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkI5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkI5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz459tXhAAAEAUlEQVR42uyXTUhcVxTH33szHb+SScZo+mFhgolpksZES2upxY1kNwVLiQQJ2UiqZpUsshBX2SgaCAS6KKTUiAjuXJTiQmlLEYottDZailKHxDghYcxzjFg7ec57N/8j/yfTYcaZ8YNueuAHT+fO/5x353zcq2v5mwE8wMdnB1jA5nNepue5XhwXgsOglM8vQYz8w0D2JQAvKAZvgOOgEvjBGngEwuAp/97IRzTXdQfB2+AMqAWnwCE6/Is78gd4DF4wCJXLlmbbIR+3/BioAR+BD4LB4NmRkZFT8/PzZYuLixJcEdcnmBMJ5oTSdmgGRd8CH4Nr4GvwS21trRmJRBwFW1tbU01NTav4/zQYBjfBBQZcQp0dOS+hyAWKiviDUCi0ClPJtrGxoTo6Otbx+Rz4BtwCnzBX8g7CdX6cIrcoOtfe3r4uzjJZd3e3pev6Q6wdA92gCZwAB3INwsNkOwk+BT0iBtFHvb29lsrBBgcHEz6fL4LvfQf6wGfgHVaMJ1umS1afBhfBbfB9YWFhZHh4OKHysLGxMdvv9z/B938Ad8Al8C6T2Zsu019jGZ0Hl8Fd8GNZWdnTiYkJW+3ApqamnIqKimfQmQBfgCusoiP0t9WDpMzKwfugFXwJfqqqqorOzs466cRt21bhcHgT0zQzBrGwsOBUV1eb0PsZ3ANXpYTpz+cGEWBj+Rz0g1/r6+tj0WjUySS8srKiWN+qs7Nz251YXl5WjY2N0ph+A/dBG3iPfj0Gk8NtMueam5tPjo+PHy4vL9e1PbBAIKCNjo76W1paJLHP0c8x+jUMboVkfgBvE0TCHSguLtb20goKCrShoaGSrq6uIN/8oDtNDbZN6WTPUWphr9drouysmZmZbLoql1YrOqLn8XjMnp4eGVjPOSvEr+Olc2keDzjtpP0GGeGWLS0taf39/ZvP8XjcDUBNTk7qfX19W+taW1s1/HypcciYfsJh9Tun56p7fvCxND4E18G3IILI/5WE09PTW4nHmZ88dGz3M1mXbKIjetS9QT9H3Crwcmy+4CyXKJflJVNfobS0VGtra9t8tixLHxgY2GzbNTU1el1dnZ68Lo3FqSv6z+jPTv35Xgch8JX0/dQdSFOG8mY2EtfZrgy5A3PUDdFP3geSTGeFXZeqof3H9n8AO8oBNBatsrJyu6zf3wAw6zVMwn35CdzycvZ4p51MbTs5gAQbhpzz17HNai88U2edunH6SfsTSFtd4cXiYUNDQ5FhGFnPcVnMdhzHnTWPqW9lCkDueFHwp/TpWCxmcnTuplkleGecp26UftLeDd2LiAyKN8FRHs93tQPgbzqWWWNyMjqZLqfuAaWIN1/fLtut4pbH6dhKTfBXAgwAPJK7qk7A85wAAAAASUVORK5CYII="});
    this.engine_.browser_.setData("layer-icon", {"id":"muslim", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5MTU1QzQ1MTE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRUQzNEM4Q0E4OEMxMUU0QjFCODkxQTg2RDUwMUFEOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRUQzNEM4QkE4OEMxMUU0QjFCODkxQTg2RDUwMUFEOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTE1NUM0NTExNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTE1NUM0NTExNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5II0HiAAAG30lEQVR42pyXW0wUZxTHZ2YvsMvNXUCllXJVKK02QSBQoWiiWBNsJTY2RiRpiIkpovbFJk2qTz708lBqi6kapTUNmsZKSlpIgJRqo4JpCVDBUkQElzsIIsuyuzPT/5mctcuyIPVLftnd2Zk55zv3TxQWXyKQQAAwgxAQyp9BfF0HZOAEdjANHjMzfJ3+V5cS4m+RYCMLjACrwGqGfq9gJfTAzcKnwBgYBkNgkH+TMnNAWa4CtCsTC4oFa0ECiAYrQZiXBSR+sZN37FGiH3SBu+AeGGclFiy9H+H08hdAMngNvEKKGI3GyPz8fMvWrVvNmzZt0q9Zs0YMCwsTpqamhL6+PrW1tdVdV1fnuHLlyoTD4SCFo3gjdmZOeMbSsclTwLvgc1BvMBjuHzlyZHZgYEBRF1lQQp2bm9O+j42NqcePH5+Fwn/g+S9AHltOWMoCEmtLWq8HWSAtMTFx7eXLlyNTU1PnuYp2ff78ebmqqkpuamoSIVxnsVikwMBANSsrS9m8ebPkcrk8Lha9AlpdLCADQQx4C3wGrqelpY2NjIzM26miKOqZM2dcoaGhFGj3Qa/Hv1BG1ev1MpvbBn4Fn4ICsIHdamFZkq/pKeBywMegLiYmZnhwcHCeyd1ut1pYWOjA/w/ALbqPFAU9kZGRM6TcwYMHZQ5ECsAadsEHoAjkg3S2cqDv7pPAe6BSFMXuxsZG2dfPhw8fpnQbAX+CKvA9+IWE7d69e5buQZyoZrN5hi3QAhrAT+AH8BV4n1zLlhA9vjdznlPkxu7fvz8qNzd3nokaGhqEU6dOuTjn3VwjwvhF5pycHC2WoqKihKNHjwZwsSKTJwUEBKTCopkRERHpnNLh/PzTRb7fA76j3Xd0dCyI9szMTI9vyd89oINz/CEETLe0tCjeGVFbW6u2t7erw8PD2rWrV6+6cV877v8avMkbfhrYFPWloBY5PuErvK2tTWHhE5IkTWC3U3DHbEVFhQu5rzidTnWpVVlZ6dbpdFSYfgYfggyupE/TkMwVSRdRaIJ806O+vt7N5XQSgaaHlaz79u0zZmRkSM8qLBcuXFAOHDgwKsvyfa+qOAlcbAFV4sqn1fb09HTfyih0dXXJ/BBFf+e1a9fuwCUPioqK7P39/Ys2GdQPobi42A7hk9wXxrkxBXPB09LRu9sFxMbGLugNVOHw8QT0cQbcgmVbL168+CA5Ofnx2bNn/SoRFxcnUPbybiW2sqe8JwIrMOj5T+0zKChogQLIcY+pKb3+4ZpOu9Hb7XZzT09PMNeSeQsuEnbu3BlYXV1Nu32JFaBnB9gKFFdPJDYLaSmPj48v2M3GjRv1XKYD+QWDXAGpJjiSkpK8za6Wl5eraEba7xMnTgQgZihVY1GmU86dO5eNgKReE88WMEr8Uq1bDQ0NLVBgy5YtOqTQCs7rVRwzKrdhdd26dZqFUCfce/fufVRSUjKMHjJRVlbmgotEWIF2a0V/iNi+fbsJMRHKLjd4YmCGg2zmxo0bLj8uEBD1Fp4HXuaq+SJnjwFCaKdOpGYffE6R3m6z2f5GQXoYHx8/A+W1bDt06JDIKT3HMh1c1P6rA9Dwkb9cRrQrISEh1IB+AxXgG7rfarV24cVTXJiqwZfgE/AtaAKj5N4dO3Zo7yktLZ3hd3zEfSFE5EqYSc0Cheb13t7euOjo6AXBiGBSCgoKBmHCEZ79TF7uGOYAtfHtNEm9Sr5GZlmam5t1wcHBAr7b0GFvcQ/5nVJb4hSjGa4fhWb05MmTDn9pBV9KSL3VJpMplgVYWDg9P8v1fTWnWBx12JSUFDMam47cePr0aSeEj/C4ZuOuqbnAxPlZDC4hau8hFuTFSmtnZ6eybds2B6eijXfeyiZvBneg5MCxY8cc09PT2jPd3d0KLEB15EdQwvMBBacocg5beRTLBW8kJCSsv3nz5krSfLGFgFLhFvft27edSF830kyE6wzZ2dmGXbt26REf2n1QQqDYwvva2OyN4C8eXt3eMwGZ9W2eBbWJaKk5cDmLLABrTfIAQwH6Drd9k+9ELrFJknkgpUnmOk1GmPnk5xGOHqJglhxj4eWgkCfsUN+RzN9UvIdnwzpkxj0Ul1nk9rKsMTo6SlOxAy7p5bmwjIVv4KanW+pg4jkXRPmeCzCer0QaWvPy8kzUNTH9iOHh4QKVXT4XyDU1NQ6UYzoXjHD37OAAvcsB+8Tb78s5GcXwGJXo1VBWeLon36t4nQ2nuPhQxHdzhvTyNTv3nf91NgxhRaL8nA099VzmOjDpdTYc4Noy+jxnQ9/TsZHdEupzOjayBVSvhuZ7Op573tOxP4voeMdGL+Ge047niO7k1u5ebMe+618BBgAGNBuaFBqSVQAAAABJRU5ErkJggg=="});
    this.engine_.browser_.setData("layer-icon", {"id":"jewish", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNEY1RjYwMzA5MjA2ODExODA4M0NFREUyNjE3RDJFNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEM0E5NTFFRkE4OEMxMUU0QjU4NkEyRDgyOUFBNDkxNSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEM0E5NTFFRUE4OEMxMUU0QjU4NkEyRDgyOUFBNDkxNSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MzRGNUY2MDMwOTIwNjgxMTgwODNDRURFMjYxN0QyRTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MzRGNUY2MDMwOTIwNjgxMTgwODNDRURFMjYxN0QyRTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Kx0nFAAAFhElEQVR42sRXW0wjVRie6bSltFxaXBDYdYU1UZBLou6iiT4QroGQCAtvvHCLCfDIg0t8JYEEgfAAPAHvBkJMNiEpl/CgMeAiyGXVNS6IXLp015YFyq3T8fvHf5pJBaGKcZIv58ycc/7/nP98/2VEIfzHCFiAaMDK33zAPnAM+MMRJoWp3ADYgCTgTeAt4BZ/CwAnwBmghHOaqz4iEAEkABnAXSCVx9aAR7yJM7aEct0bIGvFAK8D7wA5lZWVtBFhdHQ0Ho3M17DPm/Bf9VRXnRcF3AE+AgosFst7y8vLZH4hKytr8/j4eB7dSeAr4ClwcBUrSCFKJDZzJN+rjYlGyhOBdOAe6WxtbU2BBYxxcXGiLMuWmZkZmU2vkVFkslq5NTGHlPMsQK2ZFcUBsbxQ4jFa/CrwNpk+NTU1c2VlJd5q/dMJfD6fkJmZ6V5bW1vB67fAKvBMR0iZPWUP+J2tc0pjRh27SfltZvZt3oiJN0Dz7MBrQEpnZ2ccKXe73eri+Ph4gb5VVVWl8nzyEi/zQOGNkOIN4CduaVzWLBDB7kTk+pBNfUNnAYPm+/n5+fbJyUnqC3V1derioaEhtS0oKDiempry6q4hoLPAc+AH4GtgAdgkt9VbgIQSm1O7uro+SElJsSmKEiSp1s/JyTHwu1BdXa2NCaIoCsPDw5bZ2Vly0wS8B++a+uvr64ctLS20qSesy6DnQgSf+hPgy4qKihfKNT8kk2SzjnTWGYwDMhODLvXZ2NiYa3x8PLakpEQCw4Xm5mbBbrcLHR0d6uTBwcHAxMSEHyeT2QJSYWGhsb6+Xj0VPETweDxCX1+fIEmSAFkyyWRiulmXHOoNRLL3gU8BZ1pamhu+re5+YGBAgQC1v7W1FYiKivKwKR8xnthsNg+N0Rya29/fr84/PT1V0tPTSakTeMA67OfFIDOz/z7QD3wPLpyQEFghaMqGhgZyJ3K3L4DPGdRfASl92rxAQN2L0tPTQ+62xDLvsw7zRdGO/D+HrTAZGxvr3tnZCSqfn58PGAyGHT7NZ8DHDOo7aYzmaPNpLcnA2BTLzGEdoj67BYnO2eyAA4Zvb2/vFC4WZDOZFSejE70EdoFtBvVf0hjN0ebTWpKB7iHLDAag8zagj4aUdKzR0dHm2tra4G6bmppEnNLM4+RuyQzqx9BYY2NjcD6uRIQFzBzSY1m2WW8BKYQDNzgSvkuu0tbWdrO4uFjS/DwpKUnc2NiQFhYW/LzWztmR1typqalJwgZMWmzAAQSTyWR0Op0+ttpzjohHf+cFDy7zAmL8ZV5Aa+ghGSTrIi8w6uqCGA7Hb1Db3d3tiIiIECgOLC4uCg6HQygvLxeSk5PF3t7eGMQBa2gcoDF6n5ubU+MArSUZJKu0tFST/TOww7w40ywQyVVOE/DwP4yED1lHBusMWkCrBdT3srIy8/T0tKzPBdq8jIwMMTExUb1jzFE/5uXlqRxxuVzC6uqq8pecj1xAMnE1mk4tyQXZaOFUe1eXDV8JyYYUu22cDdU4Dg9RFyMJqW1RUdEJrsbL5j0JyYYvdNmQePMbZUxRxwEH5XogjZnt0FUxErvRTRobGRm5hWpI0tcDqAtl1AOUYn8FttjvZV2h6uGxH4F1fveLIRVvNJ/cfk5FFM8V0T1URBkXVESrXBE95qQTWhF52RL7bCFFHwdk/rjPuyMBLh08XOHYvF6vw2w2O3Jzc1XOtLe3n+B+qTT/DvgGWAR+4Si5w+t3OQYc6v8drqUqzs7O3jw6OvrXVfFlT4BBayL9fn/k9va2FYQ8WFpaInLNswWectQLXOd/gaArs4mIWRf8GS0zAa/8ZxTOBvTVcyJ7SgJ/32WGu9j0gXBO9b/+Hf+TDQi64GQI4YcSrqA/BBgAbL5DnJogYlAAAAAASUVORK5CYII="});

    this.engine_.browser_.setData("layer-icon", {"id":"castle", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpCRTk0MzA0ODE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0MzE2RTREQ0E4OTAxMUU0OTk4MEVDRjk2OEEwOTI3QyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0MzE2RTREQkE4OTAxMUU0OTk4MEVDRjk2OEEwOTI3QyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkU5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkU5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4Jy/jzAAAEBUlEQVR42uyXzUtUURjG771ndMxpNCdLk5qwZqxsKO0DCmqjkOAmWokbpZ2EK/GP0AhxYUj79m3ERRuRioQkBRXMNLNsmj5Myxm783l7jjxHLsOMOpPSpgM/hjn33vM+57wf5xyHllvTQSE4CDzgECgGBrBAFJjgN4kQ2Z/KNKAjRwGCxr3gLH897E/RaBj8Aj/AZ7AMvoONTCJyFSDfLwM14DpF2AXEuAIRGp0Dr8EMn8X2QkAJOA78fX1912pra4uDwaBVVVWlLy4uJkdGRmKTk5Omy+Van5iYKOWqfAVreyFA+toJ3NL/yWSysKmpSdhd1NHRsRkjMzMznkAgsEaxhxg7GQfMNQh1fqdblqVne5HPihikhXTTXwvQtjGYqTvBZU/sRRaomTs4m03xo6OjWnd3dwL+jlVXV6caGhqMuro6EQqFTPpesg7ifyNAcDllxB+hT+V/fWxszBofH5eDR+bn58Ngg5kgs+ANWGBKRvMRoPMdmfuVwAfOM/9L6GeLs5OptwK+cdbvKWCW/XmtgGDEnwQBcJG/1XIV3G63gUyQIgoYbMUUvQoWwVvwicUppeWRcjKPL4C74BF4WVNTE+rv748tLS1Zqi0sLKR6enqiPp9PznwCPAb3wBUWLpGPcRc4A1rBIBhva2tbN03TytYikYjV3t4uA+4VeAhaWDVdu8k4FeUFrHbS33fAA/Ciubl5LZFIWDs1+U5jY6N0wXNwH9zmWCUc26CtLR/bg83NKJdBVguugsuGYfiHh4cPo+k7Lp1haPX19c7BwUEHDQoGqrDZS7Jvq0NQ4QlwDtSDSzLohBC+rq6uypaWll37saKiQl9eXi5COXYiSA8wi0pYxtW2LQuUpbLAyZkHOGu5y1XJPhSXsvLyckdvb29OQeT3+wsQsEenp6flKhwGpzhBl+3csKGW1MP8vgVudnZ21kF5EVwqUqmUsPss1woNlyR1XU9iJc2BgYFJ9D0DT7lF/1ADV3LmMuhuwLBf24cGIW8ZnE+YKSHDVpCcLCRObf+a3YYjfTdUaWjsowAjPQ3309iuFf0X8E9brodSLRwOa/F4xq1dKy0t3SzF+QqwuGdvu2+3trYmh4aGTF404lxFWW6LsEU7vV7vdp+r8a10AQmWxjDP8dlPKEJs8LYT5PvyxFshixkKzbEdqqa6OZm0uSUgxlPMB/AOA2mclZGmXn74hSedWZ71ZGE5Lc8OmP0Kd9T08q2ube9oY1VdUpQANfAU/we5g6ULiPDZHEWsUsBH3gO9PEUVZBAQpvEp2jLtAqI8TE7xQFmmTr1pMWLyivWF7/+msRWe/TwUJLJ8u2r7NmoXoBTGuayFWTIkYbuAqit3nPy01Xhjl99qfwQYAM77oUbmflOkAAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"museum", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5RDJCQTI3MDA4MjA2ODExODA4MzlCMjg0NTNCOUYzMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDMUNDQ0EzRUE4OTExMUU0QTk4M0EwQjAxNURGOEI0RCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDMUNDQ0EzREE4OTExMUU0QTk4M0EwQjAxNURGOEI0RCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OUQyQkEyNzAwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OUQyQkEyNzAwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6etkdzAAAEdElEQVR42uSXz09jVRTH+15fX0tL+dF2hoEy0hipMYhiVEIghgW6IGxkQaJbILCBf2DGQGQNOzYgIeKKHW4IQcPCjQkxbIwk/uoADiMg6ZQKQlt4ffM9z3PKHWbQGZjGhTf55L3ed98533vu7Tn3uVz/cdOuMN4NTIbuLZBj6N4uhgAdGKAEBEEIlLEIcvwneAgOwQk4A/nrCtDYsRcEQDm4AW6BWlAF/OAY7IFtsAv2QRr8BbIsxH4eARrP1qfMlpzWgJfAbRYQ5jEZkGQB98Fv4HcWI1HJcFSeEOK+EGYPO42wszh4A7wN3gFN4LWGhob42NhYbGpqqiYej9/c2NiI7O/v0zvVLDbCEfNzBHWemETDvhgBnQdXshGaZYypoz63232ju7s7PDg46O/o6NA17Tx4tm27VlZW8hB0vLCwkLQsi5ZhB2yBTeY+96V42fIiQONQkvJXwes8c3J86yZaf39/5cDAgFlXV/evm3Zra8uenp7OzczMpP5A46UgIT+DH8BP3JeRSOgcsvfAHfAlWG9paUnOzc2dnpyc2Fdp9B69T3bIHtu9w34i7LewD2hTfQg+a21tTayurlr2C2xkj+ySffZTK/vPUDYFrcnZ7u5uZmRkJFNRUeGNxWLu62a6zc1N6+DgIEt2lfxQ2IgigB7Set1DqwLerq6ump6enpLrChgdHc0tLy/T5vsRJNhP5uJfkjZhFHwAPgFfgwfDw8MWdrbd3Nwsiu3x8XGb+sLhsPM7Go06vycmJgpj2tvbnT5sXkrND8BX4C54n/34npZqqbMefAy+AL8sLi46e6Gvr69gHOF01rWxsdH5TeKoUb+MGRoacvrm5+ct3vWfg4/AK+ynsAENvuY5LGn+nx5Rjvf5/hZqmuZ5qLgPeeGxZyUl56tVWlrqXINBymmuU7aXYvuZizO/tIkzMUjN6/U+1ie/VZHSPB5PIVddVg/0fyhCOgxo6mwDgUBhkDgUkaqo8vJydbyUcP1ptUe/xDm9oElYxaBhGIWB8kztE6FKtFR7zyXAQYyL4bKysicEqFERobz2sjzPJEDjSkgFqZSvHr/fr6mhVWcoS6AWJXmu67oqTuwGxa4qRFSZXPdruQw7tV4MiTOZmTpzNSoiFMJFkManqAhX2Cj7MUWEwYoqwMtc79/kwYFEIuHa29tzIY06BrPZrGttbc25T6VSzhXngEJfLpdzrtvb207f4eGhi09Tt9m2pON7/Lc81VgRJYh3QSsdQDo7O2O9vb1+5BL92qdeTcvPzs4eLy0t0Znge/At+A78SnnB4PBQ/X8LNE5OTtY3NTWZbW1tmuvFNL26ujqA2lJPGZIPrZSQDiQptYFPwTehUCiZTqftYjSyS/bJD/sjv5Vy+KSdFEwmk6FifYDQZiX7WJIg+yO/boNDQsp28NDPu1YvgoY8+9phf3RvGVyf19npDueBYgk44mP7OvvNasoHRxWfin1X+GR7liYHnxR/yNDJ+UgKhZcdm0qJLkY740+5jPLV9D9vjwQYAGjIX9n8thz0AAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"townhall", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpCOTk0MzA0ODE1MjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MUUxQUNFOUE4OTIxMUU0ODEyRDgxRDdGMzA5NTQzQiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MUUxQUNFOEE4OTIxMUU0ODEyRDgxRDdGMzA5NTQzQiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Qjk5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Qjk5NDMwNDgxNTIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6ouo2KAAAEJElEQVR42uyX208jVRzHzwzDxZa2ZKV1vV+iW3VNFDVeYhCJESUQIg88EB9g2ZhATHzmQUx4MNF/QMKDieKLPvEibwRBIUsQiVyUpaABHhZXC3a7sOmFzvj9lW9JM+mU7dQYHzzJJx2GmXO+53d+t9FUaUMHd4BzoB54gQWSIA2OeX0THIIEyBSbUCtRQDUIgTB4kteKi8nCKRAH18AuuA6OiokoVYAfPAZeBS+CB0BFngWEGNgEP4IVikk4TWi4sICY/yFwYXNz8+n+/v5EMpnMhEIhVVdXZ+3u7h5OTk4GuKhY4KCYgFLHPeBt8AX4NRaLWfYh9/C/NfApeCvvmMqygM7dB2gBOYqqIs9XEP2sYzZuY2FZqBbcKWYHjzACauSBsbEx5ff71d7enorH4yoYDKYZBTE6YNpNFOgUV8sd3wceBhfJ44ZhhA4ODjz19fUqlUrl3stw4Z/BFPkF/AVMp4Xsgipp4nvBE+Al8Dp4EzTqun6xp6fn/Pr6usfn86lIJKL6+voUBCnmBJPzSo4IkgAtqZ1lDUky58HzoAsMiZXBrKZpv3V1dR2tra2ZVoGxsbFhdXd3ZyBQ8kAEfAM+Bu+AF8DdnN9RhOz8LvAKeA+Mgm9lsvb29vji4mLBhe1jdXXV7OzsPBLBePd78Bl4X6zHzVU6CfAwu11mmP3U3Nwcm5uby1guxsLCgtna2hpnMvoSvEv/8ToJCPC8PwAz4+PjSesfGBMTE5IlvwMfgpe5TsEwtPIw0+m0tbS0ZHm9Xi0cDpecsba2tiQsLZnHNrc66wgugc/BsoRPY2Nj2s3O4TfHDMlVOvLlQkeQbwFJGPtgA9RRkAfOVJN7bmZmRs3Pz2cfltBD0skmn5GRkey9hoYG1dLSchJSmnbM+SL0A5k3yorpGIY1jH/J4R+BK01NTfHcrgYHB09NubKykr23s7Nzem9gYODUAh0dHVKiF8AnoA3cXygMdZsPJGm238GfUuexE9NN1eJ7h5znOrNhwu4H9kxosatJUcyxUwq9jWExNefPZZ2Viv/18b+A/5wAjZ1MFUOyqgyRudJew27KKFQJ9QIvBNjHSWX0IaQNVyFw8l4t5wqyx6i0i6iwXfvAg5LUwLPgUdT3QCKRMFAV1fT0tNre3j5pj6ur1fLyspqdnc2STatoSvb395U8OzU1ZUWjUYthKPngBn9T+eGYr6aKXe9z4A2pjL29veG2trZq7EZzkYgstOfJ0dFR+Ua4AibBD/xOSDn1/NJ09oKvhoaGoqZpll2Oh4eH5bvgaxa5C1xHFbOAmP818Az/duuIJnd6jZV1GizZLaDZfMBPH3hKOl8K8JQh4BbYA1f5sbJDX8gUEpCLAh+9NpTXzboRkCtuN1iQ/uD3QtrJCZ3ygFFGnskVtgR/M/aC9LcAAwAKaK/CLreL5QAAAABJRU5ErkJggg=="});
    this.engine_.browser_.setData("layer-icon", {"id":"post_office", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4QzY1N0ExODA4MjA2ODExODA4MzlCMjg0NTNCOUYzMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MkFBNzhFN0E4OTMxMUU0QUEwM0YwRTkwNDEyNzM2NyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MkFBNzhFNkE4OTMxMUU0QUEwM0YwRTkwNDEyNzM2NyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OEM2NTdBMTgwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OEM2NTdBMTgwODIwNjgxMTgwODM5QjI4NDUzQjlGMzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7vzMoFAAAC5UlEQVR42uyWz08TQRTHp9vtDxoVjSnGFDGlEjFpOHjopQkJFy4kQgg9EQP/DAdCE7hyqheNMVx65kBCYiD20AOa9iCg9KCWYtv0h1LLjt83eUtwRS3L4gW+ySfbnc7M982b3Z0nxJUuu1x81YAH+IEP6NzmlCT4AQ7Bd/5tmAG4QRe4De6AWyDA7S6HzI/AN/AVfAEHfH9EK/WCIHgEouA+6OaMOBVAG1TBB/AW5MBnCoICuAbugccgBsLc5nQGGqCXF1xnaEvEA/AUPO/v79/d29sz5AWoUCgYkUhkFz4v2I98vRrvOUXWu7Oz0x2LxcTa2pqjT/rm5qaIx+Nie3ubtjbEGSdfn8b7rR6+lZWVG81m0zU6Oirm5+cFAj9f7jF+cXFRDA8Pi0ql4qL52biHfemNE0/AM/CeUpXP52U0GiVnOTY2Jkulkq2Ul8tlOTExoeah+XK5nGonH/Yj37sUwBR4CT6agxuNhpydnVWD+/r65MbGxpnMM5mMDIfDavzMzIyazxT5sN8Ub71IgFegYJ1oeXlZ+v1+6fF45NLSUkfmNMbn86lx9Nsq8mG/xD8DIGWzWYmnV60mkUjIarV6qnGtVpPT09OqH94mNe40nTkA634ODAz8NvnW1pYcHBxU/1M/6v8n2QqAZBiGTCaTUtf1X9KbSqVkIBBQ7QsLC6rf32Q7AFPr6+syFAqp1Q4NDakr3VN7Jzp3AKRisShHRkaUOV3pvlNZA9DtfGCCwaBYXV0V6XRajI+PC7fbbftjpVsOjY5FppOTk3YPp2NpXBi0zQLhP+ikn9T4SGzStV6vX6gzz3/sR8c0BVABn8D+3Nxcs91uX4g5zUvzkw/7ke8hFRwPuRCJc0XUw6eU5nDaacVFrohegzf0RtBDWALvuOMBn1BdXBE5JbMmpJXn2Y98Wy4uka5zXUjc5DanM9DitO8zNaqOXScqYy+X5V4H60FrXdjisrzF91Jc6dLrpwADAKLdqru6dXf3AAAAAElFTkSuQmCC"});

    this.engine_.browser_.setData("layer-icon", {"id":"toilets", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1OTJCREE3QzA3MjA2ODExODA4M0NFREUyNjE3RDJFNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCREZDQzhFMEE4OTcxMUU0QkI3MEZCMDZFM0YxN0RCMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCREZDQzhERkE4OTcxMUU0QkI3MEZCMDZFM0YxN0RCMyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NTkyQkRBN0MwNzIwNjgxMTgwODNDRURFMjYxN0QyRTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NTkyQkRBN0MwNzIwNjgxMTgwODNDRURFMjYxN0QyRTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4H33JQAAAF70lEQVR42pxXXUxURxSee7m7i7Bll/8G0BaBbbf8lZSmQhshIZoYfx4rPBBjYtCa8q4+ttE0JMaYJr4YE1M1EhMTEy0l0RcCaUoKgdRYxNpIW7CACCyIsnfv7u05m2/I7GUXKZN8ufsz38yZc75z5lxNJA6d4CH4CfmEHEI6IUJYIMzi+YYQS8LJA2cbOIvgzDs4ayPN8d2DRT4gfEKoJ9QSSrGwRggTVgmWgxMA51MHRwcnrHDWhuE4fSZhh7LQTvzG5L8J7xCiMCCCz8k4XnD+IWQpHBO8hE1Vb/Dk7YRKj8dTfe3atVrTNIPDw8M15eXldfR7DaGCkEtwOzmGYVRfvXr143A4HBwZGakJBAKSE1A4KQfHrYrwNeGnjo6OkK2M27dvs/U/E74hfI6Ysz4+InxF+PHYsWOLKqenp4dP+wvhW8IX4CQNgQ4DshFPX1ZWlkud6Pf75WnzcBqvYjh/zsjMzEzg0BoyrNkInwd7xdQQMDKgeo5lMXOvX79uP3v2LD6JXCq6urqimFegzMvH4j425ObNm9bTp0/XOOfOnYvCQJlVPhihqR5wQa0VSrzypqenXVVVVaK+vl48efJE0HcNC+1EKrJ7pwlF0ED27Oysq7q6WuzatUuwIZOTk5qikXLCJCEEriUN8OBUQdYALRA4ffp0XllZWRqNhHAtLi76yDNlJLRVeG4a3LK6urqCM2fOpJeWlq4RQqGQcffuXf/FixdLSBIfwoAZwrKakuyavYTvCb+Nj4/H7LeM3bt3v6C5vxJ6CYPBYPA5GZdy/tmzZ1cxv4vQgj11qQEXhMLu9VLqaOQ6YVnraoaQ8a2srGRBlSBsO06cOJHn8/nE48ePE+bPz8+LqakpceTIEY+u67zpe9COTyaAFGEacjT+I7lNrKysrDPgypUr8aemaS4pLMp9/+HDh10s2EePHiXM93q9goQpiouLxaFDh1hn70IPeRCnJguRpuCtg7yqweCMffv2eQoLC8WdO3fE/v37E+a53e54NrA3yUsy07bDEPZimi62NjTpuaNHj2pkUNxj6enp6ya2tLSI3t5esWfPnrSKiopchG470te9VQPio6CgQBw4cED09fWJxsbGpHM4Jfl/0oA4fvy4vDELoYM1A2xUp9j/MaC1tVW4XC7x4MED0dzcnHJebm4u1xHR3t7uQvnOkHeJgZvKxH1tbrRhJBKRz7jBDx8+1C9duqSxEXzCVINEKk6ePGk3NDTIfVZwW0YF6noT4Tu+OM6fP79KcYvKvL5w4QKX5PjngwcPxjo7O82cnJwQmgxeKDI6OmpvonbwZv8SegidhGp4Il4D+EbrIHQT/iS8lgZQZbT7+/ulASaqHyc859xUTU3NG3sT4/Lly2wAF5IfCF+iJhgGXMGV7Q/U9RLk+LZ10tc0rk5zaE74c0lTU5NvM3ohr2rw2AJatdccAqmBJbiHO5iX6F5ECgNCMIAXM2/duuUtKip6nzRgUK5rdAWLtrY2cerUKVFbWyvu3btnj42NsV5C2OM5jOCD2wYywMSCS7DMSlWDYBx7bIrwamZmxkOXFys6n7Iigw3giri8vBwndHd3R2/cuDEP94/j+VIK3nCkYRRPewNvxnCb/YWONw0hy5CiSuj5dN2CwWOEERjxUvaGxhZrkIlFLGwehKiShS0Gz7LHJiDiFZmCWzUghlBIUa04u90kc5ehnzdqiHVHfGObqIi2I2QW8DZONNnausNSC+61NnBnBHOiQASKjtD/dgqOqbyY2KkM4IVeIc/nBwcHI1S/bWpOwtTjR5eWluyJiYkQXB6CW1dVzsDAgEnz45z79+9bc3Nz9tDQ0AL0siBz33mtrvUPaDgbCI3odrKUPsFET8etVR8q4So65M/ACUCUusLh2jIEzu8wJpbs1SyMtJJtzSSuTF15J5xGOk0qwnuBhQWU7kdqpuLEUnlAw1XpQ6cr33xkmCwo+QVcLhfzwFP5SgmXRltIwTlgwxDI77JVdysnUUWqvpiqHDcaXEPh2KpInZvz+E+AAQBO8e4EEcfTeQAAAABJRU5ErkJggg=="});
    this.engine_.browser_.setData("layer-icon", {"id":"bus_station", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpGQkZCNDNERTEzMjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTlDQ0JDMkE4OTcxMUU0QUMwNUIzM0JDQzg0QTBEMiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTlDQ0JDMUE4OTcxMUU0QUMwNUIzM0JDQzg0QTBEMiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RkJGQjQzREUxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RkJGQjQzREUxMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6ZGDjiAAAFA0lEQVR42syXz08bRxTHZ22vNzY0aQg0bm1+RwGiUlApCESLQOLaQ5B64kaFlBsgBBL01n+APwAh7qk4tAd+SRVSBaqAUEigtOKHoUpSKuKYEqgxXvD2+1ZvrcGswSCkdqSPdnd25s2bNzPvvVGEfVGAE2jgFvCCDH56uM4FHCAOTsAxiCRxxPWnwEg1UHJx8gB3wD2QzdzlutusjMZtSXgM/APegb/BHngLQsw+iHLbCxWgWWUCHygAD0A+f78P3mML0OAq9zfYAlGe8SEr8Rf4A2yAbf6mf3oqBRw8QC4oB5WgFPidTufdysrK27W1tZ7S0lK1uLjYmZ2d7dA0TcRiMREKheJbW1unq6urJ7Ozs0dLS0sHuq6H0fdP8Dt4Dl6Al2ylUzsFaFYfgU/BF6CqpKTkQUdHx72Wlhb14OBALC4uinRKc3OzGBkZ0QcGBsJQKogq6jgNnoFXbKlzhUxcC74BPz5+/HgvEokYVoESBpv7UqwSjUaNtrY2mvFP4FueWJY8cUV60jpXgS+p4fb2dml+fn6i4dHRkdjZ2UnLAkVFRYn3cDgs/H7/JpSZwecPYA685tNzZucXglbwHTq8Nm6wVFVVvYHc78HX4CFv4MSul48enYCMwsJCehejo6NGV1eXHo/HY4qixOyOkd0xxpgkV+vt7XW3t7crubm57oWFBW/S8dVlBVz8gxS4VVBQ4KbK6enp07W1NetIvWXnEr9EAQ+v84cTExPZUEANBAIk382OTJPGPWMBzWoABcz6zc1N0nKHd/EaeJOGFbLYf3wWDAZpxios4JLku3k8YWcB00R5eXlm/fr6+jF7tS2wwuf65ILBadPe52fBxsZGgDwnLODggT3SEqRWALufOggIOJEEW2Z0XWIBlZ2aAd8Rp5PDClxoAWsJPLwECnWEABeb9CFv0v1UQUUq5E39HD/c8JAGFFBYMU8qBRzcgAZR6fzPz88L/vZxuyIOOiINC2RyIPNiHwkcQ0sBtxRFzyngtH6Sjy8vLxednZ0aHEgWjuAdEE9j9mbBMXQAp8PhcNbX1yskT5LvlBWwPB1tljrwFT3ROSBuuGACFAN+JkfHz1dC1uS/Kv9fBQ4PDwUioKioqBBTU1NXErqysiLq6upEU1OTQFBLq0+A1/8pJQ0UQIaHhxPhFcKuFHxaW1sTfXt6esw6Tkae8jiBSy1QXV0tvF6v+d7Y2HglC1B7bDrhcrlEQ0PD9SxABc7IQBS7VghGJmTAByS+U1lAdqsGR7pEtPP5fCbXKWVlZclVlmzDbhNaqXU0OWu9waKz/DN5hWWBGGeru5RFDQ0N5cETqjU1NebPwcFBc0OxN7zQ38DaCk6Ow+o7NzcnlpeXafAwy39n59IpCn4MnvA6Bfv7+3VaO2RDNPgBe67fODd4ZsNzvgOErL5U+vr6aLAgy33C42TYWWCXc3jzFjQzM5OJRDRnbGxM5zxgi5XYT7FMFOlyQPH4+HhRd3c3BSNlcnJyjxV7wfJ3ZQvIWbHGke8T8DldTDwejw9KRPhmQwnJOqdmdgp4OQzTpeaRqqp+c+F1nZT+BVBWvMzp3bG1GZWkbCaDhZCZaBt/wHngNmv/ki1gl5ZpbAHKHR6xHMFWI+V/ZUtG5JOg2FxMM1lQDr/LG8i6ZBopLrUZvIT3+TIrpHtiiC+wp+ncjt3SFTzOJjvmfPCinEDu65b217njZ5V/BRgAeqinnNWK4CcAAAAASUVORK5CYII="});
    this.engine_.browser_.setData("layer-icon", {"id":"information", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowNDgwMTE3NDA3MjA2ODExODA4MzlCMjg0NTNCOUYzMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NzQ1NzYxREE4OTgxMUU0QTJEODk0MkIwQjVCNEUxRSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NzQ1NzYxQ0E4OTgxMUU0QTJEODk0MkIwQjVCNEUxRSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODM5QjI4NDUzQjlGMzMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDQ4MDExNzQwNzIwNjgxMTgwODM5QjI4NDUzQjlGMzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7bSBULAAADoklEQVR42uyXP0wTcRTHf9f7lVpBBWyBREBrQCMOgqnERIRAICGkA4bIwOQCEzAzmbCwsLIwsBAhBBJMYCMkDK5CGBzEthijEgIatVBpubbne+f3mosh9CgFFl/ySX+9+93vfd/7/bl3ishsCiEJF8gjHLhuWopIEHEiRmi4Zmvw44wdXSKuEV7iOnGFcOIem04kid/ED2KH+I7/yUwCZAZxeXBaRdwjfIQHolSLAI74F/GZeA+2iP1MmZAZoudobxGPCD9xG9nIOyIDUeIrUYx7hyAmsjSO8i7xgnjlcrk2pqamtHg8rh9lm5ubqZaWlm/Ud5l4STyBGCVTBhTLQnNa5pejr0D6fYODgxU9PT1ydXVVX1tb0xVF0Y3wdV3x+XxKa2urMjk5WVxVVXUrFott062PmBYVGUphqjQsWH5el3CcTxQRhWiziKtIOQvwdnd3u7a2tkRTU5MWjUYPMYgZRN74+Lizr69PaWxs9CwtLVXStRo43UFfDdP0E4uV2wmJSMvh6CYWmQtCvBBRVFJS4lhfX9fJedIyvzrWg7q4uChZQGlpKU/dDeIhUUpELFuUp+gTESK+cIYknNwnHhN3sOolBnYjEwWWaVP/WYTcV+WpMA6EVEoiCM5iJYQmIYK35wcEyIIOuHMJttiD/v7+2ubm5nxzMPwabY/HI+rq6pS5uTkeWFrXAPcpKysz+g0MDKidnZ2c1QKzj7Gnqb2yshIdGxtzY21wBnb4oQDxjHiqaVq1lNLWFkkm/54xqqra3laJREI4nc4gNd8Qr4m3DqTjMv/adT4/P29kxOv1ioWFBdsCMH7an3mYPSdm+RTTbVpNTY1ubiNun8RwWs7Cb7kjmxOqvr4+3W5oaBCnMZnNQxMTE6Krq8tod3R0nL8Ah8MhAoGAyIWdeApGRkZEW1ub8Pv9orq6WgwNDZ2vgN7eXmP10ztBhEIhEYlEzlcAOx8eHha5sqx2Ab2aL1ZALu2/gKwEmC8i8wVzWgE6KhdbdXwwGBSjo6Pp/zMzM2J6elocHBzY9Wn60s2TUENxoNl5OhwOi9raWkElWPra/v6+IcDtdtsZwuovyQL2iF2u05aXlxNUXB57PLe3t2edbh4f9eAu/GoSZVKYKOMjFsWpM8cL1KyI2fkG/LHfuETV+g4dt1Ejus5AQByRh+GP/cYUFJ6FqA2t335KDgWYn297iHwH5XlcQaQqvoRccK6ewZZPWhZgzPKxcrH2R4ABABj6li/q0rOCAAAAAElFTkSuQmCC"});
    this.engine_.browser_.setData("layer-icon", {"id":"railway_station", "data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpDMzY0RUFGMTEzMjA2ODExODA4Mzg5OTc2RkEyQ0JDMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowM0I4QkI5RkE4OTkxMUU0QTA3NkEwMkQzOEQyRURENCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowM0I4QkI5RUE4OTkxMUU0QTA3NkEwMkQzOEQyRURENCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QzM2NEVBRjExMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QzM2NEVBRjExMzIwNjgxMTgwODM4OTk3NkZBMkNCQzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5pJA4FAAAE5UlEQVR42uyXX0hkVRzHz9y5/tlxdiZHW12lNWFhszVqxb9IVmo+KEggCz4oKJZo4D70LAgS0UO+StJDJCzZQ4ZCGj0FKvkPWnVlbXfbUHNLJ01tXZ3Vmdv3N31H7gwzzl1Y6KUDH+bOub9z7u+c8zu/8z02FbvYgQM8B54HHpDC+gA4Bn6TbQLQ+O4A/AW2+PvYZBtWbGd8XD6WBS6DK+AFkAp0duajE4ofT+K7E7AL1sHP4B54CB5Fc0KP4VQyyASvgCKQT2fOm0Z5EmMG/PzY7yADnKP9BmfGiOeAdOYCL4Jr4kBZWdnVvr6+tOLiYs1ut6vj42M1MTFhSAl6jFJRUWHTdV1J1cLCQqCrqytrcnLyHB3dA3+DI/4/s0ijl0E7+DovL29jb2/PMJepqSmDIzllcXExzObg4MAoKCiQWfgGdIKrjKm4S5DAqb4gYCRpLpcrzCArK0sVFRWpQCAQ/K9pmnK73WE2DodDoa2ntbX1ApfCxb6VlSWQgHLKbHg8HvmvvF6v6u/v9/t8vgBmPFBTUxO2lgMDAzYMXHM6nfb29nYtPT1dZWRkhHaSk3FltxqEdr7TQpUtLS0nY2NjspbbXE9fRLskjjJtenraNTo6qpsGpPNXs+JA1G26vLz8hMG0Bv6gE2a789w5+tramsSRjhmxmd5H3fLxHDAXg/v+MR3ZN20pG59djHLDaqeWHdBlj/07yosgkY6YHZDElSbrjZHbrfarWTVsbm5OQPBJqF8CeeDVCF6Sd7BxNTY2Jj7zGejp6dE6OjpSsL9TmHzCpjm03snJycFt+swdkIJtZeUceaqiqf+4/O+AZQdwAKmqqirV29sbPUngFOzu7lbV1dVqZmZGRQSq8TS5QUTHG+BjMD80NHQsp1t5efnpybe6umpEFhzBp+9ra2uDdUjdkpR+An3gLeaJuDMQUjuSaI729/eDoqOkpCT4Mjc3N3I3nNaHtl9hYWHwd2trS47LQwoUnxUtENIDcnZ3yFleWlq6iRPQ8Pv9xuzsrLG7u2vEKjs7O8bc3JyBYzpoX1lZKZpwFLxPVeWwmhuyQT3oB4v19fWH0aY9VllZWTHq6upE/dwGn4J3qCkt5R0bFXAF+BD8KCKzra0tYNWBzs7OAIXpNPgIvMn116yoYjuNXwNvS/BkZ2dfWVpacqampirMhML0hkV5KA2LXszJyVGIG5Wfn/9ofX39Lqp/AN+DW+DPWPJcRZxqEgNt4Evwy8jIiF9GNjw87OfIROE+oOS+x2ep2xUbsR0fH/ez/ivwHmMgJV4KT6D8rgWfgNmmpqYD6XBzczOA6PdyJN+Cm+BzcpN1t8RGbKUN9KDI8DluwzrGVsJZDjjMOyAzM3MDWjC4rg0NDaKA5sFn4Aa4zkCt5/MNvpsXW2mzvb1tYPkexlPG5uLkXeAD8B2m/lA6Ghwc9DGivwDv8rJyieLkIp+L+E5sbksbaSt9SF/s8xq/ETMIxbscyTvgdQoPN/XffTBD7lOWmW9Gbl7jSshlKiixuwMm2HaVSS6qHhDNtwPuUuV6qfP2GVDLFKWR97zQdWyNaywz9pup7a/sc8d0n4w6A6F7oZsXEw//H1KOezkiX5TDxUan3bxNpzGrHvHDW2x7ZG5ri7EVdXaWxOmVHP7ElM+NM7ZxqG1ixE06att/BBgApC9647x3VVsAAAAASUVORK5CYII="});

    if (mglLayer_ != null) {
        //add layer to export
        this.engine_.export_["layers"].push(mglLayer_);

        //parse layer
        this.parseLayer(mglLayer_);
    } else {
        this.load(this.path_);
    }
};

Vadstena.MglLoader.prototype.load = function(path_) {

    var onLoaded_ = (function(json_){

        //add layers to export
        var layers_ = json_["layers"];
        if (layers_ != null && layers_.length != null) {
            this.engine_.export_["layers"] = this.engine_.export_["layers"].concat(layers_);
        }

        //parse file
        this.json_ = json_;
        this.parseMgl();

    }).bind(this);


    var onError_ = (function(configName_){

    }).bind(this);


    Vadstena.loadJSON(path_, onLoaded_, onError_);//, true);
};

Vadstena.MglLoader.prototype.parseMgl = function() {
    var json_ = this.json_;
    var layers_ = json_["layers"];

    for (var i = 0, li = layers_.length; i < li; i++) {
        this.parseLayer(layers_[i]);
    }

    if (this.onLoaded_ != null) {
        this.onLoaded_({id_:this.id_, path_:this.path_});
    }
};

Vadstena.MglLoader.prototype.parseLayer = function(layer_) {

    var ways_ = layer_["ways"];
    var places_ = layer_["places"];
    var borders_ = layer_["borders"];

    this.layers_ = [];

    for (var i = 0, li = this.totalLayers_; i < li; i++) {
        var sublayer_ = [];

        if (layer_["bbox"] != null) {
            sublayer_.push(["layer-bbox", { "bbox":layer_["bbox"]}]);
        }

        if (layer_["origin"] != null) {
            sublayer_.push(["layer-origin", { "origin":layer_["origin"]}]);
        }

        if (layer_["optimize"] != null) {
            sublayer_.push(["layer-optimize", { "optimize":layer_["optimize"]}]);
        }

        this.layers_[i] = sublayer_;
    }

    var maxDistance_ = this.engine_.browser_.getOption("maxDistance");

    //PLACES
    var placeColor_ = [220,158,158,255];

    for (var i = 0, li = places_.length; i < li; i++) {
        var place_ = places_[i];

        var type_ = place_["type"];
        var pos_ = place_["pos"];
        var name_ = place_["name"];
        //var population_ = place_["population"];

        var info_ = {};

        if (place_["website"] != null) { info_.website_ = place_["website"]; }
        if (place_["phone"] != null) { info_.phone_ = place_["phone"]; }
        if (place_["opening_hours"] != null) { info_.openingHours_ = place_["opening_hours"]; }

        if (!info_.website_ && !info_.phone_ && !info_.openingHours_) {
            info_ = null;
        }

        //LOD 0
        switch(type_) {
            case "country": this.addPlace(0, pos_, 12, placeColor_, "none", name_, maxDistance_*1.2); break;
        }

        //LOD 1
        switch(type_) {
            case "city":    this.addPlace(1, pos_, 12, placeColor_, "none", name_, 400000); break;
        }

        //LOD 2
        switch(type_) {
            case "city":    this.addPlace(2, pos_, 12, placeColor_, "none", name_, 200000); break;
            case "town":    this.addPlace(2, pos_, 12, placeColor_, "none", name_); break;
        }

        //LOD 3
        switch(type_) {
            case "city":   this.addPlace(3, pos_, 12, placeColor_, "none", name_, 100000); break;
            case "town":   this.addPlace(3, pos_, 12, placeColor_, "none", name_); break;
        }

        //LOD 4
        switch(type_) {
            case "city":   this.addPlace(4, pos_, 12, placeColor_, "none", name_, 50000); break;
            case "town":   this.addPlace(4, pos_, 12, placeColor_, "none", name_); break;
            case "suburb": this.addPlace(4, pos_, 12, placeColor_, "none", name_); break;
        }

        //LOD 5-7
        for (var lod_ = 5; lod_ < 8; lod_++) {
            switch(type_) {
                case "city":      this.addPlace(lod_, pos_, 12, placeColor_, "none", name_, 20000); break;
                case "town":      this.addPlace(lod_, pos_, 12, placeColor_, "none", name_); break;
                case "suburb":    this.addPlace(lod_, pos_, 12, placeColor_, "none", name_); break;
                case "locality":  this.addPlace(lod_, pos_, 12, placeColor_, "none", name_, null, info_); break;
            }
        }

        //LOD 8-10
        for (var lod_ = 8; lod_ < 11; lod_++) {

            var minDistance_ = (lod_ == 8) ? 0 : 250;

            switch(type_) {
                //case "city":         this.addPlace(lod_, pos_, 12, placeColor_, "none", name_); break;
                //case "town":         this.addPlace(lod_, pos_, 12, placeColor_, "none", name_); break;
                //case "suburb":       this.addPlace(lod_, pos_, 12, placeColor_, "none", name_); break;
                case "locality":     this.addPlace(lod_, pos_, 10, placeColor_, "none", name_, minDistance_, info_); break;
                case "cafe":         this.addPlace(lod_, pos_, 9, placeColor_, "cafe", name_, minDistance_, info_); break;
                case "restaurant":   this.addPlace(lod_, pos_, 9, placeColor_, "restaurant", name_, minDistance_, info_); break;
                case "fast_food":    this.addPlace(lod_, pos_, 9, placeColor_, "fast_food", name_, minDistance_, info_); break;
                case "bar":          this.addPlace(lod_, pos_, 9, placeColor_, "bar", name_, minDistance_, info_); break;
                case "pub":          this.addPlace(lod_, pos_, 9, placeColor_, "pub", name_, minDistance_, info_); break;
                case "townhall":     this.addPlace(lod_, pos_, 9, placeColor_, "townhall", name_, minDistance_, info_); break;
                case "post_office":  this.addPlace(lod_, pos_, 9, placeColor_, "post_office", name_, minDistance_, info_); break;
                case "toilets":      this.addPlace(lod_, pos_, 9, placeColor_, "toilets", name_, minDistance_, info_); break;
                case "bus_station":  this.addPlace(lod_, pos_, 9, placeColor_, "bus_station", name_, minDistance_, info_); break;
                case "christian":    this.addPlace(lod_, pos_, 9, placeColor_, "christian", name_, minDistance_, info_); break;
                case "muslim":       this.addPlace(lod_, pos_, 9, placeColor_, "muslim", name_, minDistance_, info_); break;
                case "jewish":       this.addPlace(lod_, pos_, 9, placeColor_, "jewish", name_, minDistance_, info_); break;
                case "hotel":
                case "hostel":
                case "guest_house":  this.addPlace(lod_, pos_, 9, placeColor_, "hotel", name_, minDistance_, info_); break;
                case "museum":       this.addPlace(lod_, pos_, 9, placeColor_, "museum", name_, minDistance_, info_); break;
                case "information":  this.addPlace(lod_, pos_, 9, placeColor_, "information", name_, minDistance_, info_); break;
                case "castle":       this.addPlace(lod_, pos_, 9, placeColor_, "castle", name_, minDistance_, info_); break;
                case "station":      this.addPlace(lod_, pos_, 9, placeColor_, "railway_station", name_, minDistance_, info_); break;
            }
        }
    }

    //WAYS
    var primaryColor_ = [220,158,158,255];
    var secundaryColor_ = [248,213,169,255];
    var tertiaryColor_ = [248,248,186,255];
    var residentialColor_ = [254,254,254,255];
    var pedestrianColor_ = [254,254,254,255];
    var footwayColor_ = [254,254,254,255];


    for (var i = 0, li = ways_.length; i < li; i++) {
        var way_ = ways_[i];

        var type_ = way_["type"];
        var wayPoints_ = way_["way"];
        var name_ = way_["name"];

        //LOD 3
        switch(type_) {
            case "primary":   this.addStreet(3, wayPoints_, 16, 16, primaryColor_, name_); break;
        }

        //LOD 4
        switch(type_) {
            case "primary":    this.addStreet(4, wayPoints_, 16, 16, primaryColor_, name_); break;
            case "secundary":  this.addStreet(4, wayPoints_, 12, 15, secundaryColor_, name_); break;
        }

        //LOD 5
        switch(type_) {
            case "primary":    this.addStreet(5, wayPoints_, 11, 14, primaryColor_, name_); break;
            case "secundary":  this.addStreet(5, wayPoints_, 10, 13, secundaryColor_, name_); break;
            case "tertiary":   this.addStreet(5, wayPoints_, 9, 12, tertiaryColor_, name_); break;
        }

        //LOD 6
        switch(type_) {
            case "primary":     this.addStreet(6, wayPoints_, 8, 12, primaryColor_, name_); break;
            case "secundary":   this.addStreet(6, wayPoints_, 7, 11, secundaryColor_, name_); break;
            case "tertiary":    this.addStreet(6, wayPoints_, 6, 10, tertiaryColor_, name_); break;
            case "residential": this.addStreet(6, wayPoints_, 5, 9, residentialColor_, name_); break;
        }

        //LOD 7
        switch(type_) {
            case "primary":     this.addStreet(7, wayPoints_, 7, 9, primaryColor_, name_); break;
            case "secundary":   this.addStreet(7, wayPoints_, 6, 8, secundaryColor_, name_); break;
            case "tertiary":    this.addStreet(7, wayPoints_, 5, 7, tertiaryColor_, name_); break;
            case "residential": this.addStreet(7, wayPoints_, 4, 6, residentialColor_, name_); break;
        }

        //LOD 8
        switch(type_) {
            case "primary":     this.addStreet(8, wayPoints_, 6, 7, primaryColor_, name_); break;
            case "secundary":   this.addStreet(8, wayPoints_, 5, 6, secundaryColor_, name_); break;
            case "tertiary":    this.addStreet(8, wayPoints_, 4, 5, tertiaryColor_, name_); break;
            case "residential": this.addStreet(8, wayPoints_, 3, 4, residentialColor_, name_); break;
        }

        //LOD 9
        switch(type_) {
            case "primary":     this.addStreet(9, wayPoints_, 6, 6, primaryColor_, name_); break;
            case "secundary":   this.addStreet(9, wayPoints_, 5, 5, secundaryColor_, name_); break;
            case "tertiary":    this.addStreet(9, wayPoints_, 4, 4, tertiaryColor_, name_); break;
            case "residential": this.addStreet(9, wayPoints_, 3, 3, residentialColor_, name_); break;
            case "pedestrian":  this.addStreet(9, wayPoints_, 2, 3, pedestrianColor_, name_); break;
        }

        //LOD 10
        /*
        switch(type_) {
            case "primary":     this.addStreet(10, wayPoints_, 5, 2, primaryColor_, name_); break;
            case "secundary":   this.addStreet(10, wayPoints_, 4, 2, secundaryColor_, name_); break;
            case "tertiary":    this.addStreet(10, wayPoints_, 3, 2, tertiaryColor_, name_); break;
            case "residential": this.addStreet(10, wayPoints_, 2, 2, residentialColor_, name_); break;
            case "pedestrian":  this.addStreet(10, wayPoints_, 1, 2, pedestrianColor_, name_); break;
            case "footway":     this.addStreet(10, wayPoints_, 1, 2, footwayColor_, name_); break;
        }*/

    }

    var simpleBorders_ = [];
    var totalSize_ = 0;

    //layer_["borders"] = [];

/*
    for (var i = 0, li = borders_.length; i < li; i++) {
        var border_ = borders_[i];
        var borderPoints_ = border_["border"];
        totalSize_ += (borderPoints_.length - 1)*2;
    }
*/
    //var simpleBorders_ = new Array(totalSize_);
    var index_ = 0;

    //BORDERS
    var stateColor_ = [255,255,0,128];

    for (var i = 0, li = borders_.length; i < li; i++) {
        var border_ = borders_[i];
        var borderPoints_ = border_["border"];

        var hit_ = false;
        /*
        for (var j = 0, lj = borderPoints_.length; j < lj; j++) {
            var p = borderPoints_[j];

            if (p[0] < -1966552 || p[0] > 3168409 || p[1] < 431189 || p[1] > 8333739) {
                hit_ = true;
                break;
            }
        }*/

        if (hit_ != true) {

            layer_["borders"].push({"type":"state","border":borderPoints_});

            for (var j = 0, lj = borderPoints_.length - 1; j < lj; j++) {
                //simpleBorders_[index_] = borderPoints_[j];
                //simpleBorders_[index_+1] = borderPoints_[j+1];
                simpleBorders_.push(borderPoints_[j], borderPoints_[j+1]);
                //index_+=2;
            }
        }
    }

    //LOD 0-10
    if (simpleBorders_.length > 0) {
        for (var lod_ = 0; lod_ < 2; lod_++) {
           this.addBorder(lod_, simpleBorders_, 5, stateColor_);
        }
    }

    this.compileLayer(layer_["id"]);
 };

Vadstena.MglLoader.prototype.compileLayer = function(id_) {

    for (var i = 0, li = this.totalLayers_; i < li; i++) {
        var layer_ = this.layers_[i];

        if (layer_.length > 0) {
            this.engine_.browser_.setData("layer-begin", {"id":id_, "path":this.path_, "lod":i, "group":"basic", "visible":true });

            for (var j = 0, lj = layer_.length; j < lj; j++) {
                var data_ = layer_[j];
                this.engine_.browser_.setData(data_[0], data_[1]);
            }

            this.engine_.browser_.setData("layer-end");
        }
    }

    //this.engine_.browser_.setData("layer-end");
};

Vadstena.MglLoader.prototype.addStreet = function(lod_, wayPoints_, size_, textSize_, color_, text_) {
    var layer_ = this.layers_[lod_];
    color_ = [255, 255, 255, 90];
    //color_ = [255, 248, 230, 90];

    layer_.push(["stencil-line", { "points":wayPoints_, "size":size_, "color": color_}]);

    if (text_!= null) {
        layer_.push(["path-text", { "text":text_, "points":wayPoints_, "size":textSize_, "color":[255,255,255,255]}]);
    }
};

Vadstena.MglLoader.prototype.addPlace = function(lod_, point_, textSize_, color_, icon_, text_, minDistance_, info_) {
    var layer_ = this.layers_[lod_];
    var imageData_ = null;
    var html_ = "";
    var clickable_ = false;


    if (info_ != null) {
        if (info_.website_ != null) {
            if (info_.website_.indexOf("http://") == -1 && info_.website_.indexOf("https://")){
                info_.website_ = "http://" + info_.website_;
            }
        }

        //if (html_ != "") { html_ += "<br/>"; }
        if (info_.website_ != null) { html_ += "<div class='infoKey'>Website:</div><div class='infoValue'><a href="+info_.website_+" target='_blank'>"+info_.website_+"</a></div>"; }
        if (info_.phone_ != null) { html_ += "<div class='infoKey'>Phone:</div><div class='infoValue'>"+info_.phone_.replace(/;/g,"<br/>")+"</div>"; }
        if (info_.openingHours_ != null) { html_ += "<div class='infoKey'>Opening Hours:<br/></div><div class='infoValue'>"+info_.openingHours_.replace(/;/g,"</br>")+"</div>"; }
    }


    if (text_ != null && text_ != "") {
        html_ = "<div class='infoTile"+(html_==""?"2":"")+"'><b>" + text_ + "</b></div>" + html_;
    }


    if (icon_ != "none") {

        var text2_ = "";

        if (html_ == "" || (text_ == null || text_ == "")) {
            switch(icon_) {
                case "cafe":         text2_ = "Caf"; break;
                case "restaurant":   text2_ = "Restaurant"; break;
                case "fast_food":    text2_ = "Fast food"; break;
                case "bar":          text2_ = "Bar"; break;
                case "pub":          text2_ = "Pub"; break;
                case "townhall":     text2_ = "Townhall"; break;
                case "post_office":  text2_ = "Post office"; break;
                case "toilets":      text2_ = "Toilets"; break;
                case "bus_station":  text2_ = "Bus station"; break;
                case "christian":    text2_ = "Church"; break;
                case "muslim":       text2_ = "Mosque"; break;
                case "jewish":       text2_ = "Synagogue"; break;
                case "hotel":
                case "hostel":
                case "guest_house":  text2_ = "Hotel"; break;
                case "museum":       text2_ = "Museum"; break;
                case "information":  text2_ = "Information"; break;
                case "castle":       text2_ = "Castle"; break;
                case "station":      text2_ = "Railway station"; break;
            }

            if (text2_ != "") {
                html_ = "<div class='infoTile"+(html_==""?"2":"")+"'><b>" + text2_ + "</b></div>" + html_;
            }
        }

        imageData_ = { "point":point_, "scale":1.0,
                       "x":0.5, "y":-0.2, "xunits":"fraction", "yunits":"fraction",
                       "icon": icon_, "color": [255,255,255,255], "html":html_};

        layer_.push(["flat-image", imageData_]);
    }

    if (text_ != null && text_ != "") {
        layer_.push(["flat-text", { "text":text_, "point":point_, "scale":textSize_/12, "color": color_,
                     "image":imageData_, "minDistance":(minDistance_!=null) ? (minDistance_ * minDistance_) : null,
                     "html":(icon_ != "none") ? html_ : null}]);
    }

    //var textData_ = { "text":text_, "point":point_, "scale":textSize_/12, "color": color_, "image":imageData_};
    //layer_.push(["flat-place", { "text":textData_, "image":imageData_}]);

};

Vadstena.MglLoader.prototype.addBorder = function(lod_, borderPoints_, size_, color_) {
    var layer_ = this.layers_[lod_];

    //for (var i = 0; li = borderPoints_.length; i < li; i++) {

    //}

//    layer_.push(["pixel-line", { "points":borderPoints_, "size":size_, "color": color_}]);
    layer_.push(["pixel-line2", { "points":borderPoints_, "size":size_, "color": color_}]);
};




if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file

window["VadstenaInterfaceCommand_"] = function(){};
window["VadstenaShareLink_"] = false;
Vadstena.HomepageUrl = "https://www.melown.com/maps/";
Vadstena.UnsupportedFormat = "Unsupported format. Map location can not be displayed.";
Vadstena.SupportedLocationVersion = 1;

//GOOGLE ANALYTICS STUFF
if (window["_gaq"] ==  null) {
    window["_gaq"] = [];
}

//---------------------------
// PUBLIC METHODS
//---------------------------


/**
 * @constructor
 */
Vadstena.Engine = function(config_)
{
    this.Version = "1.0.0";
    this.listeners_ = [];
    this.listenerCounter_ = 0;


    this.locationsData_ = null;
    this.locations_ = null;
    this.firstLocationsInit_ = false;
    this.currentMapUrl_ = "";
    this.visitedLocations_ = [];

    this.currentLocation_ = null;
    this.currentLocationIndex_ = null;
    this.currentLocationPage_ = 0;

    this.lastPlacemarkLocation_ = null;
    this.lastPlacemarkAlias_ = null;

    this.autorotate_ = 0;
    this.autorotateEnabled_ = true;
    this.flying_ = false;
    this.shortflight_ = false;
    this.firstLocation_ = true;

    this.params_ = {};
    this.params_.urlParams_ = this.getParamsFromURL();

    this.mapParams_ = {};
    this.export_ = {"version" : 0.2, "layers":[]};
    this.geoLayers_ = [];

    if (this.params_.urlParams_["notextures"] == "1") {
        Vadstena.noTextures_ = true;
    }

    this.browserConfig_ = {};

    if (this.params_.urlParams_["far"] != null) {
        this.browserConfig_["cameraVisibility"] = parseFloat(this.params_.urlParams_["far"]);
        this.browserConfig_["cameraMaxDistance"] = parseFloat(this.params_.urlParams_["far"]);
    }

    if (this.params_.urlParams_["fov"] != null) {
        this.browserConfig_["cameraFOV"] = Vadstena.clamp(parseFloat(this.params_.urlParams_["fov"]) * 0.5, 1, 179);
    }

    if (this.params_.urlParams_["cache"] != null) {
        this.browserConfig_["cacheSize"] = this.params_.urlParams_["cache"] * 1024 * 1024;
    }

    if (this.params_.urlParams_["gpucache"] != null) {
        this.browserConfig_["gpuCacheSize"] = this.params_.urlParams_["gpucache"] * 1024 * 1024;
    }

    Vadstena.InterfaceBuilder();

    //check vadstena support (webgl)
    if (Vadstena.checkSupport() == false) {
        this.logGA('WebGL', "0");
        //this.gallery_ = new Vadstena.Gallery(document.getElementById("vadstena-engine-gallery"), 4500, 0.07);
    } else {
        this.logGA('WebGL', "1");
        this.browser_ = new Vadstena.Browser('vadstena-engine-canvas-3d', null, this.browserConfig_, null, null, this.params_.urlParams_["screenshots"] == "1");
    }

    this.logGA('OperatingSystem', Vadstena.Platform.OS);
    this.logGA('WebBrowser', Vadstena.Platform.browser + " " + Vadstena.Platform.version);


    this.autopilot_ = new Vadstena.Autopilot(this, this.onAutopilotFlightFinished.bind(this), this.onAutopilotUpdate.bind(this));
    this.interface_ = new Vadstena.Interface(this);

    if (this.browser_ == null) {
        this.interface_.showNoWebGLScreen();
    }

    window["VadstenaInterfaceCommand_"] = this.interface_.command.bind(this.interface_);

    this.frameTime_ = (new Date()).getTime();;
    this.lastFrameTime_ = this.frameTime_;

    this.setConfiguration(config_);
};


//SET CONFIG
Vadstena.Engine.prototype.setConfiguration = function(config_) {

    var urlParams_ = this.params_.urlParams_;
    this.params_.config_ = (config_ != null) ? config_ : {};
    this.params_.urlParams_ = urlParams_;

    this.applyUrlParams();
    this.applyConfigParams();
};

//SET LOCATIONS
Vadstena.Engine.prototype.setLocations = function(locationsData_, startLocation_, softUpdate_, firstTime_) {

    if (locationsData_ == null) {
        return;
    }

    this.firstLocation_ = (firstTime_ == true || firstTime_ == null);

    //typeof;
    this.locationsData_ = locationsData_;
    this.locations_ = locationsData_["locations"];

    if (this.locations_ == null) {
        return;
    }

    this.interface_.parseInfoTexts();

    if (softUpdate_ == true) {
        this.interface_.updateInfoPanel(this.interface_.currentLocationIndex_);
        return;
    }

    this.firstLocationsInit_ = true;
    /*this.mapParams_ = {};*/

    var config_ = this.params_.config_;

    if (config_["forcePositonX"] != null && config_["forcePositonY"] != null) {
        var pos_ = [ config_["forcePositonX"], config_["forcePositonY"], config_["forceDistance"] != null ? config_["forceDistance"] : 300, config_["forceHeightOffset"] != null ? config_["forceHeightOffset"] : 0 ];
        startLocation_ = this.getLocationIndexFromPosition(pos_, true);
    }

    if (startLocation_ != null) {
        switch (typeof startLocation_) {
            case "number": this.setCurrentLocationByIndex(startLocation_); break;
            case "string": this.setCurrentLocationById(startLocation_); break;
            default: this.setCurrentLocationByIndex(0); break;
        }
    } else {
        this.setCurrentLocationByIndex(0);
    }
};

//CURRENT LOCATION
Vadstena.Engine.prototype.getCurrentLocation = function() {
    return  this.currentLocation_;
};

Vadstena.Engine.prototype.getCurrentLocationIndex = function() {
    return  this.currentLocationIndex_;
};

Vadstena.Engine.prototype.setCurrentLocationById = function(id_, fly_) {
    if (this.locationsData_ == null || this.locations_ == null){
        return false;
    }

    this.setCurrentLocationByIndex(this.getLocationIndexById(id_), fly_);

    return (this.getLocationIndexById(id_, true) != -1);
};


Vadstena.Engine.prototype.getCurrentMapData = function() {
    return this.mapParams_;
};

Vadstena.Engine.prototype.setCurrentLocationByIndex = function(index_, fly_, noUpdate_) {
    if (this.locationsData_ == null || this.locations_ == null){
        return false;
    }

    //console.log("setCurrentLocationByIndex " + index_ + " " + fly_ + " " + noUpdate_);

    var inside_ = true;

    //clip index value
    if (index_ >= this.locations_.length) {
        index_ = this.locations_.length - 1;
        inside_ = false;
    }

    if (index_ < 0 ) {
        index_ = 0;
        inside_ = false;
    }

    //set current location
    this.currentLocationIndex_ = index_;
    this.currentLocation_ = this.locations_[this.currentLocationIndex_];
    this.currentLocationPage_ = 0;
    this.lastPlacemarkLocation_ = null;
    this.lastPlacemarkAlias_ = null;

    if (noUpdate_ == true) {

        if (this.browser_ == null) {
            return inside_;
        }

        /*
        if (this.gallery_ != null) {
            var location_ = this.getCurrentLocation();

            if (location_ != null) {
                if (this.checkLocationVersion(location_["version"]) == false) {
                    window.alert(Vadstena.UnsupportedFormat);
                    return false;
                }

                this.gallery_.generateGallery(location_["galleryImageTemplateURL"], location_["galleryImageCount"]);
                this.onGalleryInitialized();
            }
        }*/

        return inside_;
    }

    this.setAutorotate(0);

    //get location data
    var location_ = this.getCurrentLocation();

    if (location_ != null) {
        if (this.checkLocationVersion(location_["version"]) == false) {
            window.alert(Vadstena.UnsupportedFormat);
            return false;
        }

        //reset current location index ....
        if (this.currentMapUrl_ != location_["mapConfigURL"]) {
            this.interface_.reset();
        }

        if (this.browser_ == null) {
            /*
            this.gallery_.generateGallery(location_["galleryImageTemplateURL"], location_["galleryImageCount"]);
            this.onGalleryInitialized();
            */
        } else {
            var newMap_ = false;

            if (this.currentMapUrl_ != location_["mapConfigURL"]) {
                newMap_ = true;
                this.currentMapUrl_ = location_["mapConfigURL"];
                this.browser_.loadMap(this.currentMapUrl_, this.browserConfig_, this.onBrowserInitialized.bind(this), this.onBrowserUpdate.bind(this));
            }

            //set map params
            if (location_["map"] != null) {
                this.mapParams_["distance"] = location_["map"]["distance"] != null ? location_["map"]["distance"] : 8000;
                this.mapParams_["texelSize"] = location_["map"]["texelSize"] != null ? location_["map"]["texelSize"] : 8;
                this.mapParams_["title"] = location_["map"]["title"] != null ? location_["map"]["title"] : "";
                this.mapParams_["credits"] = location_["map"]["credits"] != null ? location_["map"]["credits"] : {};
            }


            var descriptions_ = location_["descriptions"];
            var autorotateValue_ = location_["autorotate"];

            if (descriptions_ != null &&
                descriptions_[0] != null &&
                descriptions_[0]["placemarkAlias"] != null &&
                descriptions_[0]["placemarkAlias"] != "") {

                this.flyToPlacemark(location_, descriptions_[0]["placemarkAlias"], (!fly_));

                var placemark_ = this.getPlacemark(location_, descriptions_[0]["placemarkAlias"]);

                if (placemark_ != null) {
                    autorotateValue_ = placemark_["autorotate"];
                }

            } else {

                //get current browser position an orientation
                var pos_ = this.browser_.getPosition();
                var rot_ = this.browser_.getOrientation();
                var heightOffset_ = this.browser_.getOption("cameraHeightOffset");

                if (newMap_ || (!fly_)) {
                    rot_[2] = 0;
                }

                this.autopilot_.setSource([pos_[0], pos_[1], pos_[2]], [rot_[0], rot_[1], rot_[2]], null, heightOffset_);

                //get new postion and orientation from location data
                if (location_["position"] != null && location_["position"]["x"] != null){ pos_[0] = location_["position"]["x"]; }
                if (location_["position"] != null && location_["position"]["y"] != null){ pos_[1] = location_["position"]["y"]; }
                if (location_["distance"] != null){ pos_[2] = location_["distance"]; }

                if (location_["orientation"] != null && location_["orientation"]["x"] != null){ rot_[0] = location_["orientation"]["x"]; }
                if (location_["orientation"] != null && location_["orientation"]["y"] != null){ rot_[1] = location_["orientation"]["y"]; }


                heightOffset_ = (location_["heightOffset"] != null) ? location_["heightOffset"] : 0;

                this.autopilot_.setDestination(pos_, rot_, null, heightOffset_, (newMap_ || (!fly_)), location_["autorotate"]);

            }

            if (newMap_ || (!fly_)) {
                if (location_["autorotate"] != null) {
                    this.setAutorotate(autorotateValue_);
                }

                this.flying_ = false;
            } else {
                //set small texel size
                this.browser_.setOption("texelSize", 0.01);

                this.flying_ = true;
                this.shortflight_ = false;
            }

            //set new positon and orientation
            //this.browser_.setPosition(pos_[0], pos_[1], pos_[2]);
            //this.browser_.setOrientation(rot_[0], rot_[1], rot_[2]);
        }
    }

    var token_ = this.locations_[index_]["accessToken"];

    if (this.visitedLocations_[token_] == null) {
        this.visitedLocations_[token_] = true;
        this.logGA('LocationView', token_);
    }


    this.callListener("location-changed", {"id": token_, "index": index_ });

    return inside_;
};

//GET LOCATION
Vadstena.Engine.prototype.getLocationByIndex = function(index_) {
    if (this.locations_ == null){
        return null;
    }

    if (index_ >= this.locations_.length || index_ < 0) {
        return null;
    }

    return  this.locations_[index_];
};

Vadstena.Engine.prototype.getLocationById = function(id_) {
    if (this.locations_ == null){
        return null;
    }

    var index_ = this.getLocationIndexById(id_, true);

    if (index_ < 0) {
        return null;
    }

    return  this.locations_[index_];
};

//LOCATIONS
Vadstena.Engine.prototype.getLocations = function() {
    return  this.locations_;
};

Vadstena.Engine.prototype.getLocationsData = function() {
    return  this.locationsData_;
};

//FLIGTH PROGRESS
Vadstena.Engine.prototype.getFlightProgress = function() {
    if(this.flying_ == true) {
        return 0.5;
    } else {
        return 1.0;
    }

};

//NEXT LOCATION INDEX
Vadstena.Engine.prototype.getNextLocationIndex = function() {
    var index_ = this.currentLocationIndex_ + 1;

    //clip index value
    if (index_ >= this.locations_.length) {
        index_ = 0;
    }

    return index_;
};

//PREVIOUS LOCATION INDEX
Vadstena.Engine.prototype.getPreviousLocationIndex = function() {
    var index_ = this.currentLocationIndex_ - 1;

    //clip index value
    if (index_ < 0 ) {
        index_ = this.locations_.length - 1;
    }

    if (index_ < 0 ) {
        index_ = 0;
    }

    return index_;
};

//SET AUTOROTATE
Vadstena.Engine.prototype.setAutorotate = function(speed_) {
    this.autorotate_ = speed_ * 0.001;
    this.autorotateUpdate();
};

//GET AUTOROTATE
Vadstena.Engine.prototype.getAutorotate = function() {
    return this.autorotate_ * 1000;
};

//SET AUTOROTATE ENABLED
Vadstena.Engine.prototype.setAutorotateEnabled = function(state_) {
    this.autorotateEnabled_ = state_;
    this.autorotateUpdate();
};

//GET AUTOROTATE ENABLED
Vadstena.Engine.prototype.getAutorotateEnabled = function() {
    return this.autorotateEnabled_;
};


//BROWSER
Vadstena.Engine.prototype.getBrowser = function() {
    return this.browser_;
};

//INTERFACE
Vadstena.Engine.prototype.getInterface = function() {
    return this.interface_;
};

//AUTOPILOT
Vadstena.Engine.prototype.getAutopilot = function() {
    return this.autopilot_;
};


//GET SUPPORTED VERSION
Vadstena.Engine.prototype.getSupportedLocationVersion = function() {
    return Vadstena.SupportedLocationVersion;
};

//ON
Vadstena.Engine.prototype.on = function(name_, listener_) {
    if (listener_ == null) {
        return;
    }

    this.listenerCounter_++;
    this.listeners_.push({ name_ : name_, listener_ : listener_, id_ : this.listenerCounter_ });

    return (function(id_){ this.removeListener(id_); }).bind(this, this.listenerCounter_);
};

//---------------------------
// PRIVATE METHODS
//---------------------------

//EVENTS
Vadstena.Engine.prototype.onGalleryInitialized = function() {
    this.interface_.onGalleryInitialized();
};

Vadstena.Engine.prototype.onBrowserInitialized = function(success_, message_) {

/*
    var x = 464823, y = 5582535, z = 259;
    var d = 400;

    var points_ = [
        [x,y,z],
        [x+d,y,z],
        [x+d,y+d,z],
        [x,y+d,z],
        [x+d*0.5,y,z],
        [x+d*0.5,y+d*2,z]
     ];

    this.browser_.setData("sketch-begin");
    this.browser_.setData("pixel-line", { points_:points_, size_:20});
    this.browser_.setData("sketch-end");
*/

//    this.kmlDemo_ = new Vadstena.KmlLoader(this, "./test04.kml");

    this.geoLayers_ = [];

    var geoLayersPresent_ = false;

    for (var i = 1; i < 10; i++) {
        var postfix_ = (i == 1) ? "" : ("" + i);

        if (this.params_.urlParams_["kml" + postfix_] != null) {
            this.geoLayers_.push(new Vadstena.KmlLoader("kml", this, decodeURIComponent(this.params_.urlParams_["kml" + postfix_]), this.onImportLoaded.bind(this)));
            geoLayersPresent_ = true;
        }

        if (this.params_.urlParams_["osm" + postfix_] != null) {
            this.geoLayers_.push(new Vadstena.OsmLoader("osm", this, decodeURIComponent(this.params_.urlParams_["osm" + postfix_]), this.params_.urlParams_["osm-language"]), this.onImportLoaded.bind(this));
            geoLayersPresent_ = true;
        }

        if (this.params_.urlParams_["mgl" + postfix_] != null) {
            this.geoLayers_.push(new Vadstena.MglLoader("mgl", this, decodeURIComponent(this.params_.urlParams_["mgl" + postfix_]), null, this.onImportLoaded.bind(this)));
            geoLayersPresent_ = true;
        }
    }

    var currentLocation_ = this.getCurrentLocation();

    if (currentLocation_ != null && currentLocation_["map"] != null) {
        var geoLayers_ = currentLocation_["map"]["geoLayers"];

        if (geoLayers_ != null) {
            for (var i = 0, li = geoLayers_.length; i < li; i++) {
                var url_ = geoLayers_[i]["URL"];

                if (url_ != null) {
                    if (geoLayers_[i]["placemarkControlled"] != true) {
                        this.loadGeoLayer(url_, url_);
                    }

                    geoLayersPresent_ = true;
                }
            }
        }
    }

    if (geoLayersPresent_ == true) {
        this.params_.config_["hideGeo"] = this.params_.config_["initalHideGeo"];
    } else {
        this.params_.config_["hideGeo"] = true;
    }

    if (this.params_.urlParams_["height-lod"] != null) {
        this.browser_.setOption("heightLod", parseInt(this.params_.urlParams_["height-lod"], 10));
    }

    if (this.params_.urlParams_["max-zoom"] != null) {
        this.browser_.setOption("ignoreTexelSize", (this.params_.urlParams_["max-zoom"] == "1"));
    }

    if (this.params_.urlParams_["low-res"] != null) {
        this.browser_.setOption("lowRes", parseFloat(this.params_.urlParams_["low-res"]));
    }

    if (this.params_.urlParams_["degdrade-horizon"] != null) {
        var oldValue_ = this.browser_.getOption("degdradeHorizon");
        var newValue_ = this.params_.urlParams_["degdrade-horizon"].split("+");

        for (var i = 0; i < 4; i++) {
            if (newValue_[i] != null) {
                oldValue_[i] = parseFloat(newValue_[i]);
            }
        }

        this.browser_.setOption("degdradeHorizon", oldValue_);
    }

    //fov hack for Ondra
    var mapConfig_ = this.browser_.getMapConfig()["json"];

    if (mapConfig_ != null && mapConfig_["fov"] != null) {
            this.browserConfig_["cameraFOV"] = mapConfig_["fov"];
    } else {
        if (this.params_.urlParams_["fov"] != null) {
            this.browserConfig_["cameraFOV"] = Vadstena.clamp(parseFloat(this.params_.urlParams_["fov"]) * 0.5, 1, 179);
        } else {
            this.browserConfig_["cameraFOV"] = 90 * 0.5;
        }
    }

    var layers_ = this.browser_.getMapConfig().geoLayers_;
    if (layers_ != null) {

        var addLayer_ = (function(layerProperties_){
            var lp_ = layerProperties_;

            switch(lp_["type"]) {
                case "geodata":

                    var params_ = {
                        "geodata": lp_["layer-data"],
                        "style": lp_["style-data"],
                        "visible" : lp_["visible"] || true,
                        "group" : lp_["group"]
                    };

                    this.browser_.addLayer(lp_["id"], "geodata", params_);
                    break;

                case "tiled-geodata":

                    var params_ = {
                        "style": lp_["style-data"],
                        "url": lp_["url"],
                        "minLod": lp_["minLod"],
                        "maxLod": lp_["maxLod"],
                        "tileWidth": lp_["tileWidth"] || 256,
                        "visible" : lp_["visible"] || true,
                        "group" : lp_["group"]
                    };

                    this.browser_.addLayer(lp_["id"], "tiled-geodata", params_);
                    break;
            }

        });

        var onLayerLoaded_ = (function(layerProperties_, addLayerCall_, layerData_){
            var lp_ = layerProperties_;
            lp_["layer-data"] = layerData_;

            if (lp_["style-data"] != null && lp_["layer-data"] != null) {
                addLayerCall_(lp_);
            }
        });

        var onStyleLoaded_ = (function(layerProperties_, addLayerCall_, styleData_){
            var lp_ = layerProperties_;
            lp_["style-data"] = styleData_;

            if (lp_["style-data"] != null && lp_["layer-data"] != null) {
                addLayerCall_(lp_);
            }
        });

        var onError_ = (function(path_){
        });


        for (var i = 0, li = layers_.length; i < li; i++) {
            var layer_ = layers_[i];

            switch(layer_["type"]) {
                case "geodata":
                    Vadstena.loadJSON(layer_["url"], onLayerLoaded_.bind(this, layer_, addLayer_.bind(this)), onError_.bind(this));
                    Vadstena.loadJSON(layer_["style"], onStyleLoaded_.bind(this, layer_, addLayer_.bind(this)), onError_.bind(this));
                    break;

                case "tiled-geodata":
                    layer_["layer-data"] = {};
                    Vadstena.loadJSON(layer_["style"], onStyleLoaded_.bind(this, layer_, addLayer_.bind(this)), onError_.bind(this));
                    break;
            }
        }
    }

    //this.layerTest();

    this.setCurrentLocationByIndex(this.getCurrentLocationIndex(), false);
    this.onAutopilotFlightFinished();

    this.interface_.onVadstenaInitialized(success_, message_);

    if (success_ == true){
        this.callListener("initialized", {});
    } else {
        this.callListener("error", {message_: message_});
    }
};

Vadstena.Engine.prototype.onBrowserUpdate = function(dirty_) {
    this.frameTime_ = (new Date()).getTime();

    this.autorotateUpdate();

    if (dirty_ == true) {
        this.interface_.onBrowserUpdate();
    }

    if (this.interface_.statsGraphsVisible_ == true) {
        this.interface_.updateStatsGraphs();
    }

    this.lastFrameTime_ = this.frameTime_;

    this.callListener("tick", {});

    if (dirty_ == true) {
        this.callListener("update", {});
    }
};

Vadstena.Engine.prototype.onImportLoaded = function(event_) {

    //console.log("import loaded: " + event_.id_ + " " + event_.path_);

    if (this.getCurrentLocation() != null && this.lastPlacemarkAlias_ != null) {
        this.showPlacemarkGeoLayers(this.getCurrentLocation(), this.lastPlacemarkAlias_);
    }

    this.callListener("import-loaded", event_);
};

Vadstena.Engine.prototype.onAutopilotUpdate = function() {
    this.callListener("flight-update", {});
};

Vadstena.Engine.prototype.onAutopilotFlightFinished = function() {

    //get location data
    var location_ = this.getCurrentLocation();

    if (location_ != null) {
        /*
        if (this.shortflight_ != true && location_["autorotate"] != null) {
            this.setAutorotate(location_["autorotate"]);
        }*/
    }

    this.flying_ = false;
    this.shortflight_ = false;

    this.onBrowserUpdate();

    this.callListener("flight-finished", {});
};

Vadstena.Engine.prototype.autorotateUpdate = function() {
    if (this.autorotateEnabled_ == true && this.autorotate_ != 0 && this.browser_ != null) {
        var rot_ = this.browser_.getOrientation();

        rot_[0] = (rot_[0] + (this.frameTime_ - this.lastFrameTime_) * this.autorotate_) % 360;

        this.browser_.setOrientation(rot_[0], rot_[1], rot_[2]);

        this.interface_.sendWSCoords();

        //call again
        //window.setTimeout(this.onBrowserUpdate.bind(this), 1000 / 60);
    }
};

//PLACEMARKS
Vadstena.Engine.prototype.findPlacemark = function(location_, placemarkAlias_) {
    var placemarks_ = location_["placemarks"];

    if (placemarks_ == null) {
        return null;
    }

    for(var i = 0, li = placemarks_.length; i < li; i++){
        if (placemarks_[i]["alias"] == placemarkAlias_) {
            return placemarks_[i];
        }
    }
    return -1;
};

Vadstena.Engine.prototype.showPlacemarkGeoLayers = function(location_, placemarkAlias_) {
    var browser_ = this.browser_;

    if (browser_ == null || browser_.isReady() == false || location_ == null) {
        return;
    }

    //console.log("showPlacemarkGeoLayers: " + location_["title"] + " " + placemarkAlias_);

    this.lastPlacemarkLocation_ = location_;
    this.lastPlacemarkAlias_ = placemarkAlias_;

    //hide map geolayers
    if (location_["map"] != null) {
        var geoLayers_ = location_["map"]["geoLayers"];

        if (geoLayers_ != null) {
            for (var i = 0, li = geoLayers_.length; i < li; i++) {
                var url_ = geoLayers_[i]["URL"];
                if (url_ != null) {
                    if (geoLayers_[i]["placemarkControlled"] == true) {
                        this.showGeoLayer(geoLayers_[i]["URL"], false);
                        //console.log("---hideGeoLayer: " + i + " " + geoLayers_[i]["URL"]);
                    }
                }
            }
        }
    }

    //show placemark geolayers
    var placemark_ =  this.findPlacemark(location_, placemarkAlias_);

    if (placemark_ != null) {
        var geoLayers_ = placemark_["geoLayers"];

        if (geoLayers_ != null){
            for (var i = 0, li = geoLayers_.length; i < li; i++) {
                this.loadGeoLayer(geoLayers_[i]["URL"], geoLayers_[i]["URL"]);

                //console.log("---showGeoLayer: p" + i + " " + geoLayers_[i]["URL"]);
                this.showGeoLayer(geoLayers_[i]["URL"], true);
            }
        }
    }

};

Vadstena.Engine.prototype.getPlacemark = function(location_, placemarkAlias_) {

    var placemark_ = this.findPlacemark(location_, placemarkAlias_);

    if (placemark_ != null) {
        if (placemark_["autorotate"] === null) {
            placemark_["autorotate"] = 0;
        }

        return placemark_;
    }

    return null;
};

Vadstena.Engine.prototype.flyToPlacemark = function(location_, placemarkAlias_, direct_) {
    var browser_ = this.browser_;

    if (browser_ == null || browser_.isReady() == false || location_ == null) {
        return;
    }

    var placemark_ = this.findPlacemark(location_, placemarkAlias_);

    if (placemark_ != null) {
        if (placemark_["autorotate"] === null) {
            placemark_["autorotate"] = 0;
        }

        this.setAutorotate(0);
        var srcPos_ = browser_.getPosition();
        var srcRot_ = browser_.getOrientation();
        var srcHeightOffset_ = browser_.getOption("cameraHeightOffset");

         //+ ", \"placemark\":\"" + placemark_["alias"] + "\""

        var dstPos_ = [placemark_["position"]["x"], placemark_["position"]["y"], placemark_["distance"]];
        var dstRot_ = [placemark_["orientation"]["x"], placemark_["orientation"]["y"], 0];
        var dstHeightOffset_ = placemark_["height_offset"];

        var autopilot_ = this.getAutopilot();
        autopilot_.setSource( srcPos_, srcRot_, null, srcHeightOffset_);
        autopilot_.setDestination( dstPos_, dstRot_, null, dstHeightOffset_, (direct_ == true), (placemark_["autorotate"] || 0));

        this.showPlacemarkGeoLayers(location_, placemark_["alias"]);
    }
};


//GEO LAYERS
Vadstena.Engine.prototype.findGeoLayer = function(id_) {
    for(var i = 0, li = this.geoLayers_.length; i < li; i++){
        if (this.geoLayers_[i].id_ == id_) {
            return;
        }
    }
    return -1;
};

Vadstena.Engine.prototype.showGeoLayer = function(id_, state_) {
    if (this.findGeoLayer(id_) != -1) {
        //console.log("-----layer-visible: " + id_ + " " + state_);
        this.browser_.setData("layer-visible", {"id":id_, "state":state_});
    }
};

Vadstena.Engine.prototype.loadGeoLayer = function(id_, url_) {
    if (this.findGeoLayer(id_) != -1) {
        return;
    }

    var fileExtension_ = url_.substr((~-url_.lastIndexOf(".") >>> 0) + 2);

    switch(fileExtension_) {
        case "mgl": this.geoLayers_.push(new Vadstena.MglLoader(id_, this, url_, null, this.onImportLoaded.bind(this))); break;
        case "osm": this.geoLayers_.push(new Vadstena.OsmLoader(id_, this, url_, null, this.onImportLoaded.bind(this))); break;
        case "kml": this.geoLayers_.push(new Vadstena.KmlLoader(id_, this, url_, this.onImportLoaded.bind(this))); break;
    }
};

Vadstena.Engine.prototype.checkLocationVersion = function(version_) {
    if (version_ == null || version_ == "") {
        return false;
    }

    var numbers_ = version_.split(".");

    //chech firt number to be equal to 1
    if (numbers_[0] == null || numbers_[0] > this.getSupportedLocationVersion()) {
        return false;
    }

    return true;
};

//URL PARAMS
Vadstena.Engine.prototype.getParamsFromURL = function() {
    var queryString_ = {};
    var query_ = window.location.search.substring(1);
    var vars_ = query_.split("&");
    for (var i=0; i < vars_.length; i++) {
        var pair_ = vars_[i].split("=");
        if (typeof queryString_[pair_[0]] === "undefined") {
            queryString_[pair_[0]] = pair_[1];
        } else if (typeof queryString_[pair_[0]] === "string") {
            var arr_ = [ queryString_[pair_[0]], pair_[1] ];
            queryString_[pair_[0]] = arr_;
        } else {
            queryString_[pair_[0]].push(pair_[1]);
        }
    }
    return queryString_;
};

Vadstena.Engine.prototype.applyUrlParams = function() {

    var urlParams_ = this.params_.urlParams_;
    var config_ = this.params_.config_;

    if (urlParams_["controls"] != null) config_["hideNavigationControls"] = (urlParams_["controls"] == "0");
    if (urlParams_["tool-panel"] != null) config_["hideToolPanel"] = (urlParams_["tool-panel"] == "0");
    if (urlParams_["close-tool-panel"] != null) config_["closeToolPanel"] = (urlParams_["close-tool-panel"] == "0");
    if (urlParams_["toolbar"] != null) config_["hideToolbar"] = (urlParams_["toolbar"] == "0");
    if (urlParams_["info"] != null) config_["hideInfo"] = (urlParams_["info"] == "0");
    if (urlParams_["link-tool"] != null)  config_["hideLink"] = (urlParams_["link-tool"] == "0");
    if (urlParams_["gis-tool"] != null) config_["hideGis"] = (urlParams_["gis-tool"] == "0");
    if (urlParams_["streets-tool"] != null) config_["hideGeo"] = (urlParams_["streets-tool"] == "0");
    if (urlParams_["streets-visible"] != null) config_["hideStreets"] = (urlParams_["hide-streets"] == "1");
    if (urlParams_["credits"] == null) config_["hideCredits"] = (urlParams_["credits"] == "0");

    if (urlParams_["x"] != null){ config_["forcePositonX"] = parseInt(urlParams_["x"], 10); }
    if (urlParams_["y"] != null){ config_["forcePositonY"] = parseInt(urlParams_["y"], 10); }
    if (urlParams_["d"] != null){ config_["forceDistance"] = parseInt(urlParams_["d"], 10); }
    if (urlParams_["ho"] != null){ config_["forceHeightOffset"] = parseInt(urlParams_["ho"], 10); }
    if (urlParams_["rx"] != null){ config_["forceOrientationX"] = parseInt(urlParams_["rx"], 10); }
    if (urlParams_["ry"] != null){ config_["forceOrientationY"] = parseInt(urlParams_["ry"], 10); }
    if (urlParams_["rotate"] != null){ config_["forceAutorotate"] = parseFloat(urlParams_["rotate"]);}
    //if (params_["scc"] != null) { autorotate_ = parseFloat(params_["rotate"]) * 0.001;}

    /*
    if (this.gallery_ != null) {
        config_["hideNavigationControls"] = true;
        config_["hideToolbar"] = true;
    }
    */

};


Vadstena.Engine.prototype.applyConfigParams = function() {

    this.params_.config_["initalHideGis"] = this.params_.config_["hideGis"];
    this.params_.config_["initalHideGeo"] = this.params_.config_["hideGeo"];
    this.interface_.applyConfigParams(this.params_);
};


//LOCATIONS
Vadstena.Engine.prototype.getLocationIndexById = function(id_, noClip_) {
    for (var i = 0, li = this.locations_.length; i < li; i++) {
        if (this.locations_[i]["accessToken"] == id_) {
            return i;
        }
    }

    return (noClip_ == true) ? -1 : 0;
};

//HACK FOR DUPLICIT LOCATIONS
Vadstena.Engine.prototype.isCurrentLocationIndexValid = function(pos_) {

    var location_ = this.getCurrentLocation();

    if (location_ != null &&
        location_["position"] != null &&
        location_["position"]["x"] != null &&
        location_["position"]["y"] != null &&
        location_["radius"] != null &&
        location_["mapConfigURL"] == this.currentMapUrl_){

        var pos2_ = [ location_["position"]["x"], location_["position"]["y"], 0 ];
        var radius_ = location_["radius"];

        var dx_ = pos2_[0] - pos_[0];
        var dy_ = pos2_[1] - pos_[1];

        var distance_ = (dx_*dx_ + dy_*dy_);

        //is current location in range of this location
        if (!(distance_ < radius_*radius_)) {
            return false;
        }

        //check if we zoomed too far
        //in case that some location has bigger radius then global out distance then use location radius
        if (Math.sqrt(distance_) > this.mapParams_["distance"]) {
            if (pos_[2] > radius_) {
                return false;
            }
        } else {
            if (pos_[2] > this.mapParams_["distance"]) {
                return false;
            }
        }

        return true;
    }

    return false;
};

//LOCATION INDEX FROM POSITION
Vadstena.Engine.prototype.getLocationIndexFromPosition = function(pos_, updateMinDistance_) {

    //console.log("getLocationIndexFromPosition: " +  this.getCurrentLocationIndex());

    var locations_ = this.getLocations();

    //do whe have multiple map locations
    if (locations_ != null && locations_.length > 0) {

        var currenLocationIndex_ = -1;
        var bestDistance_ = 99999999999;
        var bestRadius_ = 0;
        var globalTexelSize_ = 0.5;

        var locationsData_ = this.getLocationsData();

        //get global min distance
        if (updateMinDistance_ == true && this.mapParams_["texelSize"] != null) {
            globalTexelSize_ = this.mapParams_["texelSize"];
        }

        var texelSize_ = globalTexelSize_;

        //loop  locations
        for (var i = 0, li = locations_.length; i < li; i++) {

            var location_ = locations_[i];

            if (location_["position"] != null &&
                location_["position"]["x"] != null &&
                location_["position"]["y"] != null &&
                location_["radius"] != null &&
                location_["mapConfigURL"] == this.currentMapUrl_){

                var pos2_ = [ location_["position"]["x"], location_["position"]["y"], 0 ];
                var radius_ = location_["radius"];

                var dx_ = pos2_[0] - pos_[0];
                var dy_ = pos2_[1] - pos_[1];

                var distance_ = (dx_*dx_ + dy_*dy_);

                //is current location in range of this location
                if (distance_ < radius_*radius_ && distance_ < bestDistance_) {
                    currenLocationIndex_ = i;
                    bestDistance_ = distance_;
                    bestRadius_ = radius_;
                }

                var spread_ = 40.0;
                var doubleRadius_ = Math.min(radius_ + 20000, radius_ * spread_);
                var texelSize2_ = location_["texelSize"] != null ? location_["texelSize"] : texelSize_;

                if (updateMinDistance_ == true && texelSize2_ < texelSize_) {

                    if (distance_ < doubleRadius_*doubleRadius_) {

                        if (distance_ > radius_*radius_) {
                            distance_ = Math.sqrt(distance_);

                            //fade texelSize
                            texelSize2_ = texelSize2_ + ((distance_ - radius_) / (doubleRadius_ - radius_)) * (globalTexelSize_ - texelSize2_);
                        }

                        if (texelSize2_ < texelSize_) {
                            texelSize_ = texelSize2_;
                        }
                    }
                }

            }
        }

        //set min distance
        if (updateMinDistance_ == true && this.flying_ != true) {
            if (this.mapParams_["texelSize"] != null) {
                if (this.browser_.getOption("texelSize") != texelSize_) {
                    this.browser_.setOption("texelSize", texelSize_);
                    //console.log("set texelSize: " + texelSize_);
                }
            }
        }


        //check if we zoomed too far
        //this.mapParams_["distance"] = 200000;
        //in case that some location has bigger radius then global out distance then use location radius
        if (bestRadius_ > this.mapParams_["distance"]) {
            if (pos_[2] > bestRadius_) {
                currenLocationIndex_ = -1;
            }
        } else {
            if (pos_[2] > this.mapParams_["distance"]) {
                currenLocationIndex_ = -1;
            }
        }

        if (this.isCurrentLocationIndexValid(pos_) == true) {
                //console.log("isValid true");
            return this.getCurrentLocationIndex();
        } else {
                //console.log("isValid false");
            return currenLocationIndex_;
        }
    }

    return 0;
};

//LOG GOOGLE ANALYTICS
Vadstena.Engine.prototype.logGA = function(action_, label_) {

    if (window.location.href.indexOf("iris-test.citationtech.net") != -1) {
        return;
    }

    window["_gaq"].push(['_trackEvent', 'All', action_, label_]);

    if (window["VadstenaShareLink_"] == true) {
        window["_gaq"].push(['_trackEvent', 'Sharelink', action_, label_]);
    } else {
        window["_gaq"].push(['_trackEvent', 'Homepage', action_, label_]);
    }
};


//LISTENERS
Vadstena.Engine.prototype.callListener = function(name_, event_) {
    for (var i = 0; i < this.listeners_.length; i++) {
        if (this.listeners_[i].name_ == name_) {
            this.listeners_[i].listener_(event_);
        }
    }
};

Vadstena.Engine.prototype.removeListener = function(id_) {
    for (var i = 0; i < this.listeners_.length; i++) {
        if (this.listeners_[i].id_ == id_) {
            //this.listeners_[i].splice(i, 1);
            this.listeners_.splice(i, 1);
            return;
        }
    }
};


Vadstena.Engine.prototype.generateTestLayer = function(x, y, tileSize_) {

    var x1 = x;
    var y1 = y;
    var x2 = x1 + tileSize_;
    var y2 = y1 + tileSize_;
    var h1 = 310;
    var h2 = 315;

    var data_ =
    {
       "version": 1,
       "groups": [{
          "bbox": [
              [x1, y1, h1],
              [x2, y2, h2]
          ],
          "origin": [x1, y1, h1],
          "scale": [1.0, 1.0, 1.0],

          "points": [{
              "style": "sine-point",
              "name": "Test xy 123 456 789",
              "points": [
              ]}],

          "lines": [{
              "style": "sine-line",
              "name": "Test 123456 ABCD abcd",
              "points": [
          ]}]
      }]
    };

    var samples_ = 30;

    for (var i = 0; i < samples_; i++) {
        var x = (i/samples_) * tileSize_;
        var y = (tileSize_*0.5) + (tileSize_*0.5*Math.sin(2*Math.PI*(i/samples_)));

        data_["groups"][0]["lines"][0]["points"].push([x,y,0]);
    }

    var samples_ = 10;

    for (var i = 0; i < samples_; i++) {
        var x = (i/samples_) * tileSize_;
        var y = (tileSize_*0.5) + (tileSize_*0.5*Math.sin(2*Math.PI*(i/samples_)));

        data_["groups"][0]["points"][0]["points"].push([x,y,0]);
    }

    return data_;
};

/*
Vadstena.Engine.prototype.layerTest = function(id_) {

    var style_ =
        {
            "constants" : {
               "@road-width" : 5,
               "@road-width2" : 15,
               "@road-color" : [215,20,20,180],
               "@road-color2" : [20,20,20,120],

               "@road-width3" : 15,
               "@road-width4" : 25,

               "@icon-marker" : ["icons", 0, 0, 63, 63],
            },

            "bitmaps" : {
               "icons" : "http://maps.google.com/mapfiles/kml/paddle/wht-blank.png"
            },

            "styles" : {
                "markers" : {  //seznam switched styles
                    "line" : true,
                    "line-width" : "@road-width",
                    "line-color" : "@road-color",

                    "hover-event": true,
                    "hover-style": "markers4",

                    "line-flat" : false
                },

                "markers4" : {  //seznam switched styles
                    "inherit" : "markers",
                    "line-color" : [20,255,20,180],
                },


                "markers2" : {
                    "line" : true,
                    "line-width" : "@road-width2",
                    "line-color" : "@road-color2",
                    "line-flat" : false
                },

                "markers3" : {
                    "line" : true,
                    "line-width" : "@road-width",
                    "line-color" : "@road-color",
                    "line-flat" : false,

                    "line-label" : true,
                    "line-label-color" : [255,0,200,255],
                    "line-label-source" : "$name",

                    "line-label-offset" : { "lod-scaled" : [10, -250, 1] },

                    //"line-label-size" : { "lod-scaled" : [10, 500, 1] },
                    "line-label-size" : { "lod-scaled" : [10, [[10,500],[16,250]], 1] },
                    //"line-label-size" : { "linear" : [[10, 500], [13, 250], [15, 125]] },
                    //"line-label-size" : { "linear" : [[10, 500], [13, 250]] },
                    //"line-label-size" : { "linear" : [[10, 500]] },
                    //"line-label-size" : { "discrete" : [[10, 500], [13, 250], [15, 125]] },
                    //"line-label-size" : { "discrete" : [[10, 500], [13, 250]] },
                    //"line-label-size" : { "discrete" : [[10, 500]] },

                    //"point" : true,
                    //"point-radius" : "@road-width3",
                    //"point-color" : "@road-color",
                    //"point-flat" : false,

                    "hover-event": true,

                    //"visible" : false,

                    "multi-pass" : [[1, "markers2"]]
                },

                "points2" : {
                    "point" : true,
                    "point-radius" : "@road-width4",
                    "point-color" : "@road-color2",
                    "point-flat" : true,

                    "visible" : true

                },

                "points3" : {

                    "point" : false,
                    "point-radius" : "@road-width3",
                    "point-color" : "@road-color",
                    "point-flat" : true,

                    //"label" : true,
                    //"label-color" : [255,255,255,255],
                    //"label-source" : "$name",
                    //"label-size" : 40,
                    //"label-origin" : "bottom-center",
                    //"label-align" : "center",
                    //"label-offset" : [50,-30],

                    "icon" : true,
                    "icon-source" : ["icons", 0, 0, 63, 63],
                    "icon-color" : [255,0,255,255],
                    "icon-scale" : 1,
                    "icon-origin" : "bottom-center",
                    //"icon-offset" : [50,-30],

                    //"visibility" : 2000,

                    "hover-event": true,
                    "hover-style": "points4",

                    "multi-pass" : [[1, "points2"]]
                },

                "points4" : {  //seznam switched styles
                    "inherit" : "points3",
                    "icon-color" : [20,255,20,180],
                },


                "paths" : {
                    "inherit" : "points3",
                }
            }
        };

    if (SEZNAMCZ != true) {

        //var params_ = {
        //    "style": style_,
        //    "url": "http://localhost:8091/{lod}-{easting}-{northing}.json",
        //    "minLod":3,
        //    "maxLod":15,
        //    "tileWidth":256
        //};

        //this.browser_.addLayer("test", "tiled-geodata", params_);

        //var geodata_ = this.generateTestLayer(617184, 5449248, 4096);

        //var params_ = {
        //    "geodata": geodata_,
        //    "style": style_,
        //    "url": "http://localhost:8091/{lod}-{easting}-{northing}.json"
        //};

        //this.browser_.addLayer("test", "geodata", params_);

    }

};
*/


//prevent minification
Vadstena["Engine"] = Vadstena.Engine;
Vadstena.Engine.prototype["setConfiguration"] = Vadstena.Engine.prototype.setConfiguration;
Vadstena.Engine.prototype["setLocations"] = Vadstena.Engine.prototype.setLocations;
Vadstena.Engine.prototype["getCurrentLocation"] = Vadstena.Engine.prototype.getCurrentLocation;
Vadstena.Engine.prototype["getCurrentLocationIndex"] = Vadstena.Engine.prototype.getCurrentLocationIndex;
Vadstena.Engine.prototype["setCurrentLocationById"] = Vadstena.Engine.prototype.setCurrentLocationById;
Vadstena.Engine.prototype["setCurrentLocationByIndex"] = Vadstena.Engine.prototype.setCurrentLocationByIndex;
Vadstena.Engine.prototype["getCurrentMapData"] = Vadstena.Engine.prototype.getCurrentMapData;
Vadstena.Engine.prototype["getLocationByIndex"] = Vadstena.Engine.prototype.getLocationByIndex;
Vadstena.Engine.prototype["getLocationById"] = Vadstena.Engine.prototype.getLocationById;
Vadstena.Engine.prototype["getLocations"] = Vadstena.Engine.prototype.getLocations;
Vadstena.Engine.prototype["getLocationsData"] = Vadstena.Engine.prototype.getLocationsData;
Vadstena.Engine.prototype["getFlightProgress"] = Vadstena.Engine.prototype.getFlightProgress;
Vadstena.Engine.prototype["getNextLocationIndex"] = Vadstena.Engine.prototype.getNextLocationIndex;
Vadstena.Engine.prototype["getPreviousLocationIndex"] = Vadstena.Engine.prototype.getPreviousLocationIndex;
Vadstena.Engine.prototype["setAutorotate"] = Vadstena.Engine.prototype.setAutorotate;
Vadstena.Engine.prototype["getAutorotate"] = Vadstena.Engine.prototype.getAutorotate;
Vadstena.Engine.prototype["setAutorotateEnabled"] = Vadstena.Engine.prototype.setAutorotateEnabled;
Vadstena.Engine.prototype["getBrowser"] = Vadstena.Engine.prototype.getBrowser;
Vadstena.Engine.prototype["getInterface"] = Vadstena.Engine.prototype.getInterface;
Vadstena.Engine.prototype["getAutopilot"] = Vadstena.Engine.prototype.getAutopilot;
Vadstena.Engine.prototype["getSupportedLocationVersion"] = Vadstena.Engine.prototype.getSupportedLocationVersion;
Vadstena.Engine.prototype["on"] = Vadstena.Engine.prototype.on;


/*
if (VADSTENA_MERGE != true){ if (!Vadstena) { var Vadstena = {}; } } //IE need it in very file
*/

function startEngine() {

    var type_ = window["VadstenaEngineType_"];
    //type_ = "webexport";

    //define engine configuration
    var config_ = {
        "hideNavigationControls" : false,
        "hideToolPanel" : false,
        "closeToolPanel" : false,
        "hideToolbar" : false,
        "hideInfo" : false,
        "hideLink" : false,
        "hideGis" : false,
        "hideGeo" : false,
        "hideStreets" : false,
        "hideCredits" : false,
        "shareLink" : location.protocol + '//' + location.host + location.pathname +"?{params}#{accessToken}"
    };

    if (type_ == "webexport") {
        config_["hideInfo"] = true;
    }

    var engine_ = new Vadstena.Engine(config_);

    var onLocationsLoaded_ = (function(data_) {

        //set locations
        engine_.setLocations(data_, 0);

    }).bind(this);

    var onError_ = function() {

        engine_.setLocations(null, 0);

    };


    if (type_ == "webexport") {

        var path_ = window["VadstenaEngineMapPath_"];

        if (path_ == null) {
            path_ = "./mapConfig.json";
        }

        //define location
        var location_ = {};
        location_["version"] = engine_.getSupportedLocationVersion() + ".0.0";
        location_["mapConfigURL"] = path_;

        //define loactions
        var locations_ = {};
        locations_["locations"] = [location_];

        //set locations
        engine_.setLocations(locations_, 0);

    } else {

        var path_ = window["VadstenaEngineLocationsPath_"];

        if (path_ == null) {
            path_ = "demo-examples2.json";
        }

        Vadstena.loadJSON(path_, onLocationsLoaded_, onError_.bind(this));
    }
/*
    var testHover_ = (function(data_){
        console.log("adf");
    });

    var testClick_ = (function(data_){
        console.log("adf");
    });

    engine_.getBrowser().on("geo-feature-hover", testHover_);
    engine_.getBrowser().on("geo-feature-click", testClick_);
*/
}

window["startEngine"] = startEngine;







    </script>
</head>
<body style = "padding: 0; margin: 0;" onload="startEngine()">
    <div id="vadstena-engine" style="width:100%; height:100%;"></div>
</body>
</html>